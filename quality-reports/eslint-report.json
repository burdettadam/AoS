[
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/App.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token <",
        "line": 26,
        "column": 5,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Routes, Route } from 'react-router-dom';\nimport { GameProvider } from './context/GameContext.tsx';\nimport { Suspense, lazy, useEffect } from 'react';\nimport ErrorBoundary from './components/ErrorBoundary.tsx';\nimport { logger } from './utils/logger.ts';\n\nconst HomePage = lazy(() => import('./pages/HomePage.tsx'));\nconst GamePage = lazy(() => import('./pages/GamePage.tsx'));\nconst LobbyPage = lazy(() => import('./pages/LobbyPage.tsx'));\nconst JoinPage = lazy(() => import('./pages/JoinPage.tsx'));\nconst RoleRevealPage = lazy(() => import('./pages/RoleRevealPage.tsx'));\nconst SetupPage = lazy(() => import('./pages/SetupPage.tsx'));\nimport Navigation from './components/Navigation.tsx';\nimport ProtectedRoute from './components/ProtectedRoute.tsx';\n\nfunction App() {\n  useEffect(() => {\n    logger.info('Application started', { \n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      url: window.location.href \n    });\n  }, []);\n\n  return (\n    <ErrorBoundary onError={(error, errorInfo) => {\n      logger.error('React Error Boundary caught error', { errorInfo }, error);\n    }}>\n      <GameProvider>\n        <div className=\"min-h-screen bg-gray-900 text-white\">\n          <Navigation />\n          <main className=\"container mx-auto px-4 py-8\">\n            <ErrorBoundary fallback={\n              <div className=\"text-center py-12\">\n                <p className=\"text-red-400\">Failed to load page content</p>\n              </div>\n            }>\n              <Suspense fallback={\n                <div className=\"flex items-center justify-center py-12\">\n                  <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\"></div>\n                </div>\n              }>\n                <Routes>\n                  <Route path=\"/\" element={<HomePage />} />\n                  <Route path=\"/join\" element={<JoinPage />} />\n                  <Route \n                    path=\"/lobby/:gameId\" \n                    element={\n                      <ProtectedRoute>\n                        <LobbyPage />\n                      </ProtectedRoute>\n                    } \n                  />\n                  <Route \n                    path=\"/setup/:gameId\" \n                    element={\n                      <ProtectedRoute>\n                        <SetupPage />\n                      </ProtectedRoute>\n                    } \n                  />\n                  <Route \n                    path=\"/game/:gameId\" \n                    element={\n                      <ProtectedRoute>\n                        <GamePage />\n                      </ProtectedRoute>\n                    } \n                  />\n                  <Route \n                    path=\"/reveal/:gameId\" \n                    element={\n                      <ProtectedRoute>\n                        <RoleRevealPage />\n                      </ProtectedRoute>\n                    } \n                  />\n                </Routes>\n              </Suspense>\n            </ErrorBoundary>\n          </main>\n        </div>\n      </GameProvider>\n    </ErrorBoundary>\n  );\n}\n\nexport default App;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/__tests__/HomePage.test.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token <",
        "line": 9,
        "column": 7,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport { BrowserRouter } from 'react-router-dom';\nimport HomePage from '../pages/HomePage';\n\ndescribe('HomePage', () => {\n  it('renders welcome message', () => {\n    render(\n      <BrowserRouter>\n        <HomePage />\n      </BrowserRouter>\n    );\n    \n    expect(screen.getByText(/blood on the clocktower/i)).toBeInTheDocument();\n  });\n\n  it('has navigation links', () => {\n    render(\n      <BrowserRouter>\n        <HomePage />\n      </BrowserRouter>\n    );\n    \n    const joinLink = screen.getByRole('link', { name: /join game/i });\n    expect(joinLink).toBeInTheDocument();\n  });\n});",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/api/authApi.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token static",
        "line": 4,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useKeycloak } from '../context/KeycloakContext';\n\nexport class AuthenticatedApi {\n  private static getAuthHeaders(token: string | null): HeadersInit {\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n    };\n    \n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n    \n    return headers;\n  }\n\n  static async fetch(\n    url: string, \n    options: RequestInit = {}, \n    token: string | null = null\n  ): Promise<Response> {\n    const authHeaders = this.getAuthHeaders(token);\n    \n    return fetch(url, {\n      ...options,\n      headers: {\n        ...authHeaders,\n        ...options.headers,\n      },\n    });\n  }\n\n  static async get(url: string, token: string | null = null): Promise<Response> {\n    return this.fetch(url, { method: 'GET' }, token);\n  }\n\n  static async post(\n    url: string, \n    body: any, \n    token: string | null = null\n  ): Promise<Response> {\n    return this.fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(body),\n    }, token);\n  }\n\n  static async put(\n    url: string, \n    body: any, \n    token: string | null = null\n  ): Promise<Response> {\n    return this.fetch(url, {\n      method: 'PUT',\n      body: JSON.stringify(body),\n    }, token);\n  }\n\n  static async delete(url: string, token: string | null = null): Promise<Response> {\n    return this.fetch(url, { method: 'DELETE' }, token);\n  }\n}\n\n// Hook to get authenticated API instance\nexport const useAuthenticatedApi = () => {\n  const { token } = useKeycloak();\n  \n  return {\n    get: (url: string) => AuthenticatedApi.get(url, token),\n    post: (url: string, body: any) => AuthenticatedApi.post(url, body, token),\n    put: (url: string, body: any) => AuthenticatedApi.put(url, body, token),\n    delete: (url: string) => AuthenticatedApi.delete(url, token),\n  };\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/api/setupApi.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token interface",
        "line": 3,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameId, SeatId } from '@botc/shared';\n\nexport interface SetupApiResponse {\n  success: boolean;\n  error?: string;\n  details?: string[];\n  valid?: boolean;\n}\n\nexport interface SetupStateResponse {\n  setupState: any;\n  grimoireState: any;\n  phase: string;\n}\n\nexport class SetupApi {\n  private static baseUrl = '/api/games';\n\n  static async enterSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<SetupApiResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/${gameId}/setup/enter`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ storytellerSeatId })\n      });\n\n      const data = await response.json();\n      \n      if (!response.ok) {\n        return { success: false, error: data.error || 'Failed to enter setup' };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: 'Network error entering setup' };\n    }\n  }\n\n  static async selectCharacters(\n    gameId: GameId, \n    storytellerSeatId: SeatId, \n    characterIds: string[]\n  ): Promise<SetupApiResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/${gameId}/setup/characters`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ storytellerSeatId, characterIds })\n      });\n\n      const data = await response.json();\n      \n      if (!response.ok) {\n        return { success: false, error: data.error || 'Failed to select characters' };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: 'Network error selecting characters' };\n    }\n  }\n\n  static async validateSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<SetupApiResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/${gameId}/setup/validate`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ storytellerSeatId })\n      });\n\n      const data = await response.json();\n      \n      if (!response.ok) {\n        return { \n          success: false, \n          error: data.error || 'Setup validation failed',\n          details: data.details\n        };\n      }\n\n      return { success: true, valid: data.valid === true, details: data.details };\n    } catch (error) {\n      return { success: false, error: 'Network error validating setup' };\n    }\n  }\n\n  static async completeSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<SetupApiResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/${gameId}/setup/complete`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ storytellerSeatId })\n      });\n\n      const data = await response.json();\n      \n      if (!response.ok) {\n        return { success: false, error: data.error || 'Failed to complete setup' };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: 'Network error completing setup' };\n    }\n  }\n\n  static async getSetupState(gameId: GameId): Promise<SetupStateResponse | null> {\n    try {\n      const response = await fetch(`${this.baseUrl}/${gameId}/setup`);\n      \n      if (!response.ok) {\n        return null;\n      }\n\n      return await response.json();\n    } catch (error) {\n      return null;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/CarouselScroller.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 7,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useRef, useEffect, useCallback } from 'react';\nimport { useKeenSlider } from 'keen-slider/react';\nimport 'keen-slider/keen-slider.min.css';\n\nconsole.log('CarouselScroller component initialized.');\n\ninterface CarouselScrollerProps<T> {\n  items: T[];\n  renderSlide: (item: T, index: number) => React.ReactNode;\n  selectedIdx?: number;\n  onSelect?: (index: number) => void;\n  className?: string;\n  centered?: boolean;\n  loop?: boolean;\n  slidesPerView?: number;\n}\n\nexport function CarouselScroller<T>({\n  items,\n  renderSlide,\n  selectedIdx,\n  onSelect,\n  className,\n  centered = false,\n  loop = false,\n  slidesPerView = 1\n}: CarouselScrollerProps<T>) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const internalSelected = useRef<number>(selectedIdx ?? 0);\n  if (selectedIdx !== undefined) internalSelected.current = selectedIdx; // keep in sync\n  const sliderReady = useRef(false);\n  const pendingSelection = useRef<number | null>(null);\n  const programmaticChange = useRef(false); // Flag to prevent slideChanged interference\n\n  const changeSelection = (next: number) => {\n    console.log('changeSelection called with target index:', next);\n    if (items.length === 0) {\n      console.log('No items available, exiting changeSelection.');\n      return;\n    }\n    const total = items.length;\n    const target = ((next % total) + total) % total; // wrap\n    console.log('Calculated target index:', target);\n    \n    // Set flag to prevent slideChanged from interfering\n    programmaticChange.current = true;\n    \n    if (onSelect) {\n      console.log('Calling onSelect with target index:', target);\n      onSelect(target);\n    } else {\n      internalSelected.current = target;\n      console.log('Updated internalSelected to:', internalSelected.current);\n    }\n    if (!sliderReady.current || !slider.current) {\n      console.log('Slider not ready, queuing pending selection:', target);\n      pendingSelection.current = target;\n      return;\n    }\n    if (centered) {\n      console.log('Centering on target index:', target);\n      centerOn(target);\n    } else {\n      console.log('Moving slider to target index:', target);\n      slider.current.moveToIdx(target, false);\n    }\n    \n    // Clear the flag after a short delay to allow animation to complete\n    setTimeout(() => {\n      programmaticChange.current = false;\n    }, 1000);\n  };\n\n  const centerOn = (target: number) => {\n    console.log('centerOn called with target index:', target);\n    if (!slider.current || !sliderReady.current) {\n      console.log('Slider not ready, exiting centerOn.');\n      return;\n    }\n    const offset = Math.floor(slidesPerView / 2);\n    let base = target - offset;\n    \n    // Handle wraparound properly for loop mode\n    if (loop && items.length > 0) {\n      const total = items.length;\n      // Ensure base is within valid range [0, total-1]\n      base = ((base % total) + total) % total;\n    } else if (base < 0) {\n      console.log('Base index negative, clamping to 0. Previous base:', base);\n      base = 0;\n    }\n    \n    console.log('Moving slider to base index for centering:', base, 'Target:', target, 'Offset:', offset, 'Total items:', items.length);\n    slider.current.moveToIdx(base, false);\n  };\n\n  const [sliderRef, slider] = useKeenSlider<HTMLDivElement>({\n    loop,\n    slides: {\n      perView: slidesPerView,\n      spacing: 16,\n      // Keep origin auto; we'll manually center a chosen slide so that ANY slide can be centered\n      origin: 'auto',\n    },\n    mode: 'free-snap',\n    renderMode: 'precision',\n    created() {\n      console.log('Slider created.');\n      sliderReady.current = true;\n      // If an external selection exists or a pending one queued before ready, center it\n      const target = selectedIdx !== undefined ? selectedIdx : internalSelected.current;\n      pendingSelection.current = null;\n      if (centered) {\n        console.log('Centering on initial target index:', target);\n        centerOn(target);\n      }\n    },\n    slideChanged(s) {\n      const rel = s.track.details.rel; // relative index within original set\n      console.log('Slide changed, new relative index:', rel);\n      \n      // Don't override internalSelected during programmatic changes (keyboard navigation)\n      if (selectedIdx === undefined && !programmaticChange.current) {\n        internalSelected.current = rel;\n        console.log('Updated internalSelected to:', internalSelected.current);\n      } else if (programmaticChange.current) {\n        console.log('Ignoring slide change during programmatic navigation');\n      }\n      // Only center if this change was not triggered by our changeSelection\n      // This prevents animation loops when centering\n    },\n    destroyed() {\n      console.log('Slider destroyed.');\n      sliderReady.current = false;\n    }\n  });\n\n  // Keyboard navigation handler\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log('KeyDown event triggered:', e.key);\n      console.log('Current selectedIdx:', selectedIdx, 'Internal selected:', internalSelected.current, 'Slider ready:', sliderReady.current);\n    }\n    \n    const current = selectedIdx !== undefined ? selectedIdx : internalSelected.current;\n    if (e.key === 'ArrowLeft') {\n      e.preventDefault();\n      if (process.env.NODE_ENV === 'development') {\n        console.log('ArrowLeft pressed, changing selection to:', current - 1);\n      }\n      changeSelection(current - 1);\n    } else if (e.key === 'ArrowRight') {\n      e.preventDefault();\n      if (process.env.NODE_ENV === 'development') {\n        console.log('ArrowRight pressed, changing selection to:', current + 1);\n      }\n      changeSelection(current + 1);\n    }\n  }, [selectedIdx, changeSelection]);\n\n  // Center external selectedIdx when it changes\n  useEffect(() => {\n    if (selectedIdx === undefined) {\n      console.log('Uncontrolled mode, skipping external selectedIdx handling.');\n      return;\n    }\n    if (!slider.current || !slider.current.track?.details) {\n      console.log('Slider or track details are not ready, queuing pending selection:', selectedIdx);\n      pendingSelection.current = selectedIdx;\n      return;\n    }\n    console.log('Centering on external selectedIdx:', selectedIdx);\n    if (centered) centerOn(selectedIdx); else slider.current.moveToIdx(selectedIdx, false);\n  }, [selectedIdx, centered]);\n\n  // Mouse wheel scrolling with threshold accumulation for smoother feel\n  useEffect(() => {\n    const el = containerRef.current;\n    if (!el || !slider.current) {\n      console.log('Container or slider is not ready for wheel handling.');\n      return;\n    }\n    let accum = 0;\n    const threshold = 40; // pixels needed to advance one slide\n\n    const handleWheel = (e: WheelEvent) => {\n      const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;\n      accum += delta;\n      console.log('Wheel event delta:', delta, 'Accumulated delta:', accum);\n      if (Math.abs(accum) >= threshold) {\n        const dir = accum > 0 ? 1 : -1;\n        // Use visible relative index (view position) for pure scrolling\n        const rel = slider.current?.track?.details?.rel ?? (selectedIdx !== undefined ? selectedIdx : internalSelected.current);\n        const total = items.length || 1;\n        const targetViewIdx = ((rel + dir) % total + total) % total;\n        console.log('Threshold reached - wheel scrolling view only.', 'Direction:', dir, 'From view index:', rel, 'To view index:', targetViewIdx);\n        // Direct movement WITHOUT changeSelection => no logical selection change / centering\n        slider.current?.moveToIdx(targetViewIdx, true);\n        accum = 0;\n      }\n    };\n    el.addEventListener('wheel', handleWheel, { passive: false });\n    return () => {\n      console.log('Removing wheel event listener.');\n      el.removeEventListener('wheel', handleWheel);\n    };\n  }, [slider, selectedIdx, items.length]);\n\n  // If a pending selection exists once ready, apply it\n  useEffect(() => {\n    if (sliderReady.current && pendingSelection.current !== null) {\n      const target = pendingSelection.current;\n      console.log('Applying pending selection:', target);\n      pendingSelection.current = null;\n      if (centered) centerOn(target); else slider.current?.moveToIdx(target, false);\n    }\n  }, [sliderReady.current]);\n\n  // Re-initialize slider on container resize\n  useEffect(() => {\n    if (!containerRef.current || !slider.current) {\n      console.log('Container or slider is not ready for resize observer.');\n      return;\n    }\n    const observer = new window.ResizeObserver(() => {\n      console.log('Resize observer triggered, updating slider.');\n      slider.current?.update();\n    });\n    observer.observe(containerRef.current);\n    return () => {\n      console.log('Disconnecting resize observer.');\n      observer.disconnect();\n    };\n  }, [slider]);\n\n  // Focus carousel container on click or mouse enter for keyboard navigation\n  useEffect(() => {\n    const el = containerRef.current;\n    if (!el) {\n      console.log('Container is not ready for focus handling.');\n      return;\n    }\n    const handleFocus = () => {\n      console.log('Container focused.');\n      el.focus();\n    };\n    el.addEventListener('mouseenter', handleFocus);\n    el.addEventListener('click', handleFocus);\n    return () => {\n      console.log('Removing focus event listeners.');\n      el.removeEventListener('mouseenter', handleFocus);\n      el.removeEventListener('click', handleFocus);\n    };\n  }, []);\n\n  return (\n    <div\n      className={`relative w-full focus:outline focus:outline-2 focus:outline-blue-400 ${className || ''}`}\n      ref={containerRef}\n      tabIndex={0}\n      onMouseEnter={() => containerRef.current?.focus()}\n    >\n      {/* Left Arrow */}\n      <button\n        type=\"button\"\n        className=\"absolute left-0 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/80 hover:bg-clocktower-dark/90 border border-gray-700 rounded-full w-10 h-10 flex items-center justify-center text-2xl text-gray-300 shadow-lg\"\n        style={{ marginLeft: '4px' }}\n        onClick={() => changeSelection((selectedIdx !== undefined ? selectedIdx : internalSelected.current) - 1)}\n        aria-label=\"Scroll left\"\n        disabled={!sliderReady.current}\n      >\n        &#8592;\n      </button>\n\n      {/* Carousel */}\n            <div \n        ref={sliderRef} \n        className=\"keen-slider carousel-scroller\"\n        role=\"listbox\"\n        aria-label={`${items.length} items carousel`}\n        tabIndex={0}\n        onKeyDown={handleKeyDown}\n      >\n        {(items as any[]).map((item: any, idx: number) => {\n          const isSelected = (selectedIdx !== undefined ? selectedIdx : internalSelected.current) === idx;\n          return (\n          <div\n            className={`keen-slider__slide flex items-center justify-center ${isSelected ? 'ring-2 ring-clocktower-accent scale-[1.03]' : 'opacity-90 hover:opacity-100'}`}\n            key={idx}\n            tabIndex={-1}\n            onClick={() => changeSelection(idx)}\n            style={{ transition: 'none' }}\n            role=\"option\"\n            aria-selected={(selectedIdx !== undefined ? selectedIdx : internalSelected.current) === idx}\n          >\n                        {renderSlide(item, idx)}\n          </div>\n          );\n        })}\n      </div>\n\n      {/* Right Arrow */}\n      <button\n        type=\"button\"\n        className=\"absolute right-0 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/80 hover:bg-clocktower-dark/90 border border-gray-700 rounded-full w-10 h-10 flex items-center justify-center text-2xl text-gray-300 shadow-lg\"\n        style={{ marginRight: '4px' }}\n        onClick={() => changeSelection((selectedIdx !== undefined ? selectedIdx : internalSelected.current) + 1)}\n        aria-label=\"Scroll right\"\n        disabled={!sliderReady.current}\n      >\n        &#8594;\n      </button>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/ErrorBoundary.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children?: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  public state: State = {\n    hasError: false\n  };\n\n  public static getDerivedStateFromError(error: Error): State {\n    // Update state so the next render will show the fallback UI\n    return { hasError: true, error };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n    \n    // Log to external service in production\n    if (process.env.NODE_ENV === 'production') {\n      this.logError(error, errorInfo);\n    }\n\n    // Call custom error handler if provided\n    this.props.onError?.(error, errorInfo);\n  }\n\n  private logError = (error: Error, errorInfo: ErrorInfo) => {\n    // Send to error tracking service (Sentry, LogRocket, etc.)\n    const errorPayload = {\n      message: error.message,\n      stack: error.stack,\n      componentStack: errorInfo.componentStack,\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      timestamp: new Date().toISOString(),\n      gameState: this.getGameContext()\n    };\n\n    // Send via beacon API to not block user experience\n    if ('sendBeacon' in navigator) {\n      navigator.sendBeacon('/api/errors', JSON.stringify(errorPayload));\n    } else {\n      fetch('/api/errors', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(errorPayload)\n      }).catch(() => {\n        // Silently fail - don't cause more errors\n      });\n    }\n  };\n\n  private getGameContext = () => {\n    try {\n      // Capture relevant game state for debugging\n      const gameData = localStorage.getItem('game-state');\n      return gameData ? JSON.parse(gameData) : null;\n    } catch {\n      return null;\n    }\n  };\n\n  private handleRetry = () => {\n    this.setState({ hasError: false, error: undefined });\n  };\n\n  public render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"min-h-screen bg-gray-900 flex items-center justify-center p-4\">\n          <div className=\"bg-gray-800 rounded-lg shadow-xl p-6 max-w-md w-full\">\n            <div className=\"flex items-center mb-4\">\n              <div className=\"flex-shrink-0\">\n                <svg className=\"h-8 w-8 text-red-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n                </svg>\n              </div>\n              <div className=\"ml-3\">\n                <h3 className=\"text-lg font-medium text-white\">\n                  Something went wrong\n                </h3>\n              </div>\n            </div>\n            \n            <div className=\"text-sm text-gray-300 mb-4\">\n              <p>We've encountered an unexpected error. The error has been logged and we'll investigate.</p>\n              \n              {process.env.NODE_ENV === 'development' && this.state.error && (\n                <details className=\"mt-4 p-3 bg-gray-900 rounded text-xs\">\n                  <summary className=\"cursor-pointer text-red-300\">Debug Info</summary>\n                  <pre className=\"mt-2 whitespace-pre-wrap text-red-200\">\n                    {this.state.error.message}\n                    {'\\n\\n'}\n                    {this.state.error.stack}\n                  </pre>\n                </details>\n              )}\n            </div>\n            \n            <div className=\"flex space-x-3\">\n              <button\n                onClick={this.handleRetry}\n                className=\"flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm font-medium transition-colors\"\n              >\n                Try Again\n              </button>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded text-sm font-medium transition-colors\"\n              >\n                Reload Page\n              </button>\n            </div>\n            \n            <div className=\"mt-4 text-xs text-gray-400 text-center\">\n              If this problem persists, please{' '}\n              <a href=\"https://github.com/burdettadam/botct/issues\" className=\"text-blue-400 hover:text-blue-300\">\n                report an issue\n              </a>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/Navigation.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 5,
        "column": 17,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { Link } from 'react-router-dom';\nimport { useKeycloak } from '../context/KeycloakContext';\n\nconst Navigation: React.FC = () => {\n  const { authenticated, logout, userInfo, loading } = useKeycloak();\n\n  return (\n    <nav className=\"bg-clocktower-dark border-b border-gray-700\">\n      <div className=\"container mx-auto px-4\">\n        <div className=\"flex items-center justify-between h-16\">\n          <Link to=\"/\" className=\"text-xl font-medieval font-bold text-clocktower-accent\">\n            BotC Digital\n          </Link>\n          \n          <div className=\"flex items-center space-x-4\">\n            <Link to=\"/\" className=\"text-gray-300 hover:text-white transition-colors\">\n              Home\n            </Link>\n            <Link to=\"/about\" className=\"text-gray-300 hover:text-white transition-colors\">\n              About\n            </Link>\n            \n            {!loading && authenticated && (\n              <>\n                <span className=\"text-gray-400\">\n                  Welcome, {userInfo?.preferred_username || 'User'}\n                </span>\n                <button\n                  onClick={logout}\n                  className=\"text-gray-300 hover:text-white transition-colors\"\n                >\n                  Logout\n                </button>\n              </>\n            )}\n          </div>\n        </div>\n      </div>\n    </nav>\n  );\n};\n\nexport default Navigation;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/PTTButton.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 5,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { PTTState, PTTMode } from '@botc/shared';\nimport { MicrophoneIcon, MicrophoneIcon as MicOffIcon } from '@heroicons/react/24/outline';\n\ninterface PTTButtonProps {\n  pttState: PTTState;\n  onToggleMode: (mode: PTTMode) => void;\n  onStart: () => void;\n  onEnd: () => void;\n  className?: string;\n}\n\nexport const PTTButton: React.FC<PTTButtonProps> = ({\n  pttState,\n  onToggleMode,\n  onStart,\n  onEnd,\n  className = ''\n}) => {\n  const isOnCooldown = pttState.cooldownEndTime && pttState.cooldownEndTime > new Date();\n\n  const handleClick = () => {\n    if (isOnCooldown) return;\n\n    if (pttState.isSpeaking) {\n      onEnd();\n    } else {\n      onStart();\n    }\n  };\n\n  const handleModeToggle = (event: React.MouseEvent) => {\n    event.stopPropagation();\n    onToggleMode(pttState.mode === 'hold' ? 'toggle' : 'hold');\n  };\n\n  return (\n    <div className={`flex items-center gap-2 ${className}`}>\n      <button\n        onClick={handleClick}\n        disabled={isOnCooldown}\n        className={`\n          relative flex items-center justify-center w-12 h-12 rounded-full transition-all duration-200\n          ${pttState.isSpeaking\n            ? 'bg-red-500 hover:bg-red-600 text-white shadow-lg shadow-red-500/30'\n            : 'bg-gray-700 hover:bg-gray-600 text-gray-300'\n          }\n          ${isOnCooldown ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}\n        `}\n        title={pttState.isSpeaking ? 'Click to stop speaking' : 'Click to start speaking'}\n      >\n        {pttState.isSpeaking ? (\n          <MicrophoneIcon className=\"w-6 h-6\" />\n        ) : (\n          <MicOffIcon className=\"w-6 h-6\" />\n        )}\n\n        {/* Speaking indicator */}\n        {pttState.isSpeaking && (\n          <div className=\"absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full animate-pulse\" />\n        )}\n\n        {/* Cooldown indicator */}\n        {isOnCooldown && (\n          <div className=\"absolute inset-0 rounded-full border-2 border-yellow-400 animate-spin\" />\n        )}\n      </button>\n\n      {/* Mode toggle */}\n      <button\n        onClick={handleModeToggle}\n        className=\"px-3 py-1 text-xs bg-gray-800 hover:bg-gray-700 text-gray-300 rounded transition-colors\"\n        title={`Current mode: ${pttState.mode}. Click to switch to ${pttState.mode === 'hold' ? 'toggle' : 'hold'}`}\n      >\n        {pttState.mode === 'hold' ? 'Hold (Space)' : 'Toggle (T)'}\n      </button>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/ProtectedRoute.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect } from 'react';\nimport { useKeycloak } from '../context/KeycloakContext';\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode;\n}\n\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {\n  const { authenticated, loading, login } = useKeycloak();\n\n  // Automatically redirect to Keycloak login when not authenticated\n  useEffect(() => {\n    if (!loading && !authenticated) {\n      login();\n    }\n  }, [loading, authenticated, login]);\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"card p-8\">\n          <div className=\"text-center\">\n            <div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-clocktower-accent mx-auto mb-4\"></div>\n            <p>Initializing authentication...</p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!authenticated) {\n    // Show loading state while redirecting to Keycloak\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"card p-8\">\n          <div className=\"text-center\">\n            <div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-clocktower-accent mx-auto mb-4\"></div>\n            <p>Redirecting to login...</p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n};\n\nexport default ProtectedRoute;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/VideoTile.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 5,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { VideoTileState } from '@botc/shared';\nimport { MicrophoneIcon, SpeakerWaveIcon } from '@heroicons/react/24/outline';\n\ninterface VideoTileProps {\n  seatId: string;\n  playerName?: string;\n  videoStream?: MediaStream;\n  pttState?: VideoTileState;\n  isStoryteller?: boolean;\n  className?: string;\n}\n\nexport const VideoTile: React.FC<VideoTileProps> = ({\n  seatId,\n  playerName,\n  videoStream,\n  pttState,\n  isStoryteller = false,\n  className = ''\n}) => {\n  const videoRef = React.useRef<HTMLVideoElement>(null);\n\n  React.useEffect(() => {\n    if (videoRef.current && videoStream) {\n      videoRef.current.srcObject = videoStream;\n    }\n  }, [videoStream]);\n\n  return (\n    <div className={`relative bg-gray-800 rounded-lg overflow-hidden ${className}`}>\n      {/* Video element */}\n      <video\n        ref={videoRef}\n        autoPlay\n        muted\n        playsInline\n        className=\"w-full h-full object-cover\"\n      />\n\n      {/* PTT Indicators */}\n      {pttState && (\n        <div className=\"absolute top-2 left-2 flex gap-1\">\n          {/* Speaking indicator */}\n          {pttState.isSpeaking && (\n            <div className=\"flex items-center gap-1 bg-red-500 text-white px-2 py-1 rounded text-xs\">\n              <MicrophoneIcon className=\"w-3 h-3\" />\n              <span>Speaking</span>\n            </div>\n          )}\n\n          {/* Muted indicator */}\n          {pttState.isMuted && !pttState.isSpeaking && (\n            <div className=\"flex items-center gap-1 bg-gray-600 text-gray-300 px-2 py-1 rounded text-xs\">\n              <MicrophoneIcon className=\"w-3 h-3\" />\n              <span>Muted</span>\n            </div>\n          )}\n\n          {/* Ducked indicator */}\n          {pttState.isDucked && (\n            <div className=\"flex items-center gap-1 bg-yellow-500 text-black px-2 py-1 rounded text-xs\">\n              <SpeakerWaveIcon className=\"w-3 h-3\" />\n              <span>Ducked</span>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Player info overlay */}\n      <div className=\"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-3\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"text-white font-medium\">\n            {playerName || `Player ${seatId.slice(0, 8)}`}\n          </div>\n          {isStoryteller && (\n            <div className=\"bg-yellow-500 text-black px-2 py-1 rounded text-xs font-medium\">\n              Storyteller\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Volume indicator */}\n      {pttState && (\n        <div className=\"absolute bottom-2 right-2\">\n          <div className=\"w-16 h-1 bg-gray-600 rounded\">\n            <div\n              className=\"h-full bg-green-500 rounded transition-all duration-200\"\n              style={{ width: `${pttState.volume * 100}%` }}\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/BottomBar.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ninterface BottomBarProps {\n  children?: React.ReactNode;\n}\n\nexport const BottomBar: React.FC<BottomBarProps> = ({ children }) => (\n  <div className=\"fixed bottom-0 left-0 w-full bg-clocktower-dark/80 border-t border-gray-700 shadow-lg z-20 flex items-center justify-between px-6 py-3\">\n    {children}\n  </div>\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/CharacterGrid.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useRef } from 'react';\nimport { buildCharacterTokenClass } from '../../constants/visual';\n\ninterface Character {\n  id: string;\n  name: string;\n  team: string;\n  [key: string]: any;\n}\n\ninterface CharacterGridProps {\n  characters?: Character[];\n  onCharacterHover: (character: Character | null) => void;\n  onCharacterSelect?: (character: Character) => void;\n  selectedCharacterId?: string;\n  teamRing: Record<string, string>;\n  className?: string;\n  modifierTypesByCharacterId?: Record<string, string[]>; // list of modifier types that apply to given character\n}\n\nconst CharacterGrid: React.FC<CharacterGridProps> = ({\n  characters,\n  onCharacterHover,\n  onCharacterSelect,\n  selectedCharacterId,\n  teamRing,\n  className = '',\n  modifierTypesByCharacterId,\n}) => {\n  const scrollerRef = useRef<HTMLDivElement | null>(null);\n  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const scrollContainerBy = (delta: number) => {\n    if (scrollerRef.current) {\n      scrollerRef.current.scrollBy({ left: delta, behavior: 'smooth' });\n    }\n  };\n\n  const handleCharacterHover = (character: Character | null) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n\n    if (character) {\n      onCharacterHover(character);\n    } else {\n      hoverTimeoutRef.current = setTimeout(() => {\n        onCharacterHover(null);\n        hoverTimeoutRef.current = null;\n      }, 100);\n    }\n  };\n\n  // Cleanup timeout on unmount\n  React.useEffect(() => {\n    return () => {\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  const showScrollArrows = (characters?.length || 0) > 25; // 5 rows * 5 cols visible approx\n\n  return (\n    <div className={`card p-4 flex flex-col h-[500px] ${className}`}>\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm text-gray-300\">Characters</div>\n        {characters && (\n          <div className=\"text-xs text-gray-500\">{characters.length} roles</div>\n        )}\n      </div>\n      \n      <div className=\"relative mt-3 flex-1 h-[420px]\">\n        {showScrollArrows && (\n          <button\n            type=\"button\"\n            className=\"absolute left-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n            onClick={() => scrollContainerBy(-240)}\n            aria-label=\"Scroll characters left\"\n          >\n            ←\n          </button>\n        )}\n        \n        {characters?.length ? (\n          <div\n            ref={scrollerRef}\n            data-testid=\"character-grid\"\n            className=\"grid grid-flow-col auto-cols-[100px] grid-rows-5 gap-2 overflow-x-auto overflow-y-hidden no-scrollbar h-full px-12\"\n          >\n            {characters.map((character) => {\n              const imgSrc = `/artwork/characters/${(character.id || '').toLowerCase()}.png`;\n              const ring = teamRing[character.team] || 'ring-gray-500/50';\n              const modifierTypes = modifierTypesByCharacterId?.[character.id] || [];\n              const isSelected = selectedCharacterId === character.id;\n              const baseImageWrapper = `w-16 h-16 rounded-full overflow-hidden ring-2 ${ring} bg-black/40 border ${isSelected ? 'border-clocktower-accent shadow-[0_0_0_2px_rgba(255,215,0,0.35)]' : 'border-gray-700'}`;\n              const wrapperClass = buildCharacterTokenClass(baseImageWrapper, modifierTypes);\n              \n              return (\n                <button\n                  key={character.id}\n                  onMouseEnter={() => handleCharacterHover(character)}\n                  onMouseLeave={() => handleCharacterHover(null)}\n                  onClick={() => onCharacterSelect && onCharacterSelect(character)}\n                  className=\"flex flex-col items-center text-center p-1 rounded hover:bg-white/5 transition\"\n                  title={character.name}\n                  aria-pressed={isSelected}\n                  data-selected={isSelected || undefined}\n                >\n                  <div className={wrapperClass}>\n                    <img\n                      src={imgSrc}\n                      onError={(e) => {\n                        (e.currentTarget as HTMLImageElement).src = '/script-art/placeholder.svg';\n                      }}\n                      alt={character.name}\n                      className=\"w-full h-full object-cover\"\n                      draggable={false}\n                    />\n                  </div>\n                  <div className=\"mt-1 text-[9px] font-medium leading-tight w-full text-gray-100 break-words\">\n                    {character.name}\n                  </div>\n                </button>\n              );\n            })}\n          </div>\n        ) : (\n          <div className=\"text-gray-400 text-sm py-6 px-4 text-center\">\n            Select a script to view its characters.\n          </div>\n        )}\n        \n        {showScrollArrows && (\n          <button\n            type=\"button\"\n            className=\"absolute right-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n            onClick={() => scrollContainerBy(240)}\n            aria-label=\"Scroll characters right\"\n          >\n            →\n          </button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CharacterGrid;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/CharacterScroller.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { CarouselScroller } from '../CarouselScroller';\n\ninterface CharacterScrollerProps {\n  characters: any[];\n  onHover?: (character: any) => void;\n  onUnhover?: () => void;\n}\n\nexport const CharacterScroller: React.FC<CharacterScrollerProps> = ({ characters, onHover, onUnhover }) => (\n  <CarouselScroller\n    items={characters}\n    slidesPerView={4}\n  centered\n  renderSlide={(c: any) => {\n      const imgSrc = `/artwork/characters/${(c.id || '').toLowerCase()}.png`;\n      const ring = c.team ? `ring-${c.team}-500/60` : 'ring-gray-500/50';\n      return (\n        <button\n          key={c.id}\n          onMouseEnter={() => onHover?.(c)}\n          onMouseLeave={onUnhover}\n          className=\"w-[110px] flex flex-col items-center text-center p-1 rounded hover:bg-white/5\"\n          title={c.name}\n        >\n          <div className={`w-20 h-20 rounded-full overflow-hidden ring-2 ${ring} bg-black/40 border border-gray-700`}>\n            <img\n              src={imgSrc}\n              onError={(e) => { (e.currentTarget as HTMLImageElement).src = '/script-art/placeholder.svg'; }}\n              alt={c.name}\n              className=\"w-full h-full object-cover\"\n              draggable={false}\n            />\n          </div>\n          <div className=\"mt-1 text-[10px] font-medium leading-tight truncate w-full\">{c.name}</div>\n        </button>\n      );\n    }}\n  />\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/ModifiersPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ninterface ModifiersPanelProps {\n  modifiers?: any[];\n}\n\nconst CharacterIcon: React.FC<{ characterId: string; size?: 'sm' | 'md' }> = ({ characterId, size = 'sm' }) => {\n  const imgSrc = `/artwork/characters/${(characterId || '').toLowerCase()}.png`;\n  const sizeClass = size === 'sm' ? 'w-4 h-4' : 'w-6 h-6';\n  \n  return (\n    <div className={`${sizeClass} rounded-full overflow-hidden bg-black/40 border border-gray-600 flex-shrink-0`}>\n      <img\n        src={imgSrc}\n        onError={(e) => { (e.currentTarget as HTMLImageElement).src = '/script-art/placeholder.svg'; }}\n        alt={characterId}\n        className=\"w-full h-full object-cover\"\n        draggable={false}\n      />\n    </div>\n  );\n};\n\nconst ModifierItem: React.FC<{ modifier: any }> = ({ modifier }) => {\n  const renderModifier = () => {\n    switch (modifier.type) {\n      case 'requires':\n        return (\n          <div className=\"flex items-center gap-2 text-xs\">\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-6 h-6 rounded-full bg-purple-600/20 border border-purple-500/50 flex items-center justify-center\">\n                <span className=\"text-[8px] font-bold text-purple-300\">R</span>\n              </div>\n              <CharacterIcon characterId={modifier.whenCharacter} size=\"md\" />\n              <span className=\"text-gray-200 font-medium\">{modifier.whenCharacter}</span>\n            </div>\n            <div className=\"text-gray-400\">→</div>\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-4 h-4 rounded-full bg-blue-600/20 border border-blue-500/50 flex items-center justify-center\">\n                <span className=\"text-[6px] font-bold text-blue-300\">+</span>\n              </div>\n              <div className=\"flex items-center gap-1\">\n                {modifier.requireCharacters?.map((charId: string, idx: number) => (\n                  <CharacterIcon key={idx} characterId={charId} />\n                ))}\n                {modifier.requireCharacters?.length > 3 && (\n                  <span className=\"text-xs text-gray-400\">+{modifier.requireCharacters.length - 3}</span>\n                )}\n              </div>\n            </div>\n          </div>\n        );\n      \n      case 'adjustCounts':\n        return (\n          <div className=\"flex items-center gap-2 text-xs\">\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-6 h-6 rounded-full bg-amber-600/20 border border-amber-500/50 flex items-center justify-center\">\n                <span className=\"text-[8px] font-bold text-amber-300\">±</span>\n              </div>\n              <CharacterIcon characterId={modifier.whenCharacter} size=\"md\" />\n              <span className=\"text-gray-200 font-medium\">{modifier.whenCharacter}</span>\n            </div>\n            <div className=\"text-gray-400\">→</div>\n            <div className=\"flex gap-2\">\n              {Object.entries(modifier.delta || {}).map(([team, count]) => (\n                <div key={team} className=\"flex items-center gap-1\">\n                  <div className={`w-4 h-4 rounded-full flex items-center justify-center text-[6px] font-bold ${\n                    Number(count) > 0 \n                      ? 'bg-green-600/20 border border-green-500/50 text-green-300' \n                      : 'bg-red-600/20 border border-red-500/50 text-red-300'\n                  }`}>\n                    {Number(count) > 0 ? '+' : ''}\n                  </div>\n                  <span className=\"text-gray-200\">{String(count)} {team}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n        );\n      \n      case 'mutuallyExclusive':\n        return (\n          <div className=\"flex items-center gap-2 text-xs\">\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-6 h-6 rounded-full bg-red-600/20 border border-red-500/50 flex items-center justify-center\">\n                <span className=\"text-[8px] font-bold text-red-300\">✗</span>\n              </div>\n              <span className=\"text-red-200 font-medium\">Exclusive</span>\n            </div>\n            <div className=\"text-gray-400\">→</div>\n            <div className=\"flex items-center gap-2\">\n              {modifier.characters?.map((charId: string, idx: number) => (\n                <React.Fragment key={charId}>\n                  <div className=\"flex items-center gap-1\">\n                    <CharacterIcon characterId={charId} />\n                    <span className=\"text-gray-200\">{charId}</span>\n                  </div>\n                  {idx < modifier.characters.length - 1 && (\n                    <span className=\"text-red-400 font-bold\">VS</span>\n                  )}\n                </React.Fragment>\n              ))}\n            </div>\n          </div>\n        );\n      \n      case 'atLeastOneOf':\n        return (\n          <div className=\"flex items-center gap-2 text-xs\">\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-6 h-6 rounded-full bg-green-600/20 border border-green-500/50 flex items-center justify-center\">\n                <span className=\"text-[8px] font-bold text-green-300\">1+</span>\n              </div>\n              <span className=\"text-green-200 font-medium\">Min One</span>\n            </div>\n            <div className=\"text-gray-400\">→</div>\n            <div className=\"flex items-center gap-1\">\n              {modifier.characters?.map((charId: string) => (\n                <CharacterIcon key={charId} characterId={charId} />\n              ))}\n            </div>\n          </div>\n        );\n      \n      case 'specialRule':\n        return (\n          <div className=\"flex items-center gap-2 text-xs\">\n            <div className=\"flex items-center gap-1\">\n              <div className=\"w-6 h-6 rounded-full bg-sky-600/20 border border-sky-500/50 flex items-center justify-center\">\n                <span className=\"text-[8px] font-bold text-sky-300\">F</span>\n              </div>\n              <span className=\"text-sky-200 font-medium\">Fabled</span>\n            </div>\n            <div className=\"text-gray-400\">→</div>\n            <div className=\"flex items-center gap-1\">\n              {modifier.fabled && <CharacterIcon characterId={modifier.fabled} />}\n              <span className=\"text-gray-200 capitalize\">{modifier.fabled?.replace('-', ' ')}</span>\n            </div>\n          </div>\n        );\n      \n      default:\n        return (\n          <div className=\"text-xs text-gray-300\">\n            <span className=\"font-medium capitalize\">{modifier.type}:</span>\n            <span className=\"ml-2\">{JSON.stringify(modifier)}</span>\n          </div>\n        );\n    }\n  };\n\n  return (\n    <div className=\"p-2 rounded bg-clocktower-dark/40 border border-gray-700 hover:border-gray-600 transition-colors\">\n      {renderModifier()}\n      {modifier.note && (\n        <div className=\"text-[10px] text-gray-400 mt-1 italic border-t border-gray-700 pt-1\">\n          {modifier.note}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport const ModifiersPanel: React.FC<ModifiersPanelProps> = ({ modifiers }) => (\n  <div className=\"card p-3 mb-3 max-h-[140px] overflow-y-auto custom-scrollbar\">\n    <div className=\"text-sm font-semibold text-gray-200 mb-2 flex items-center gap-2\">\n      <span>Script Modifiers</span>\n      {modifiers && modifiers.length > 0 && (\n        <span className=\"text-xs text-gray-400 bg-gray-700 px-2 py-0.5 rounded-full\">\n          {modifiers.length}\n        </span>\n      )}\n    </div>\n    {modifiers && modifiers.length > 0 ? (\n      <div className=\"space-y-2\">\n        {modifiers.map((modifier: any, idx: number) => (\n          <ModifierItem key={idx} modifier={modifier} />\n        ))}\n      </div>\n    ) : (\n      <div className=\"text-gray-400 text-xs py-2 text-center italic\">\n        No special rules for this script\n      </div>\n    )}\n  </div>\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/NightOrderPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 5,
        "column": 25,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\n// Generic night order reference (not script specific)\n// Intentionally minimal – goal is quick glance reading left→right.\nconst NIGHT_ORDER_GROUPS: { label: string; description: string }[] = [\n  { label: 'TOWNSFOLK', description: 'Good info & utility roles act earliest' },\n  { label: 'OUTSIDERS', description: 'Edge-case good roles (rarely act)' },\n  { label: 'MINIONS', description: 'Evil support roles (some act at night)' },\n  { label: 'DEMONS', description: 'Primary evil role(s) act last' },\n];\n\nexport const NightOrderPanel: React.FC = () => {\n  return (\n    <div className=\"card p-3 mb-3\">\n      <div className=\"text-sm font-semibold text-gray-200 mb-2\">Night Order</div>\n      <div className=\"flex gap-4 text-[11px]\">\n        {NIGHT_ORDER_GROUPS.map((g) => (\n          <div key={g.label} className=\"flex-1 min-w-[0]\">\n            <div className=\"text-[10px] uppercase tracking-wide text-gray-400 font-semibold mb-1\">{g.label}</div>\n            <div className=\"p-2 rounded bg-clocktower-dark/40 border border-gray-700 text-gray-300 leading-snug\">\n              {g.description}\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/PlayerControls.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ninterface PlayerControlsProps {\n  onAddNPC: () => void;\n  onCopyLink: () => void;\n  onLeaveGame: () => void;\n  canLeave?: boolean;\n}\n\nexport const PlayerControls: React.FC<PlayerControlsProps> = ({ onAddNPC, onCopyLink, onLeaveGame, canLeave }) => (\n  <div className=\"space-y-2 mt-3\">\n    <button className=\"w-full btn-secondary text-sm\" onClick={onAddNPC}>Add NPC</button>\n    <button className=\"w-full btn-secondary text-sm\" onClick={onCopyLink}>Copy Lobby Link</button>\n    {canLeave && (\n      <button className=\"w-full btn-secondary text-sm\" onClick={onLeaveGame}>Leave Game</button>\n    )}\n  </div>\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/PlayersList.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ninterface PlayersListProps {\n  players: any[];\n  storytellerSeatId?: string;\n  seatId?: string;\n  isStoryteller?: boolean;\n  onMakeStoryteller?: (targetSeatId: string) => void;\n}\n\nexport const PlayersList: React.FC<PlayersListProps> = ({ players, storytellerSeatId, seatId, isStoryteller, onMakeStoryteller }) => (\n  <div className=\"card p-3 flex-1 flex flex-col\">\n    <div className=\"text-xs text-gray-400 mb-2\">Players ({players.length})</div>\n    <div className=\"flex-1 overflow-y-auto space-y-1\">\n      {players.map((s: any, i: number) => (\n        <div key={s.id} className=\"flex items-center justify-between text-sm font-mono p-1 rounded hover:bg-white/5\">\n          <span className=\"truncate\">{s.playerId || `NPC ${i + 1}`}</span>\n          {isStoryteller && storytellerSeatId === seatId && (\n            <button\n              onClick={() => onMakeStoryteller?.(s.id)}\n              className=\"text-[10px] btn-secondary ml-2 px-1 py-0.5\"\n              title=\"Make Storyteller\"\n            >👑</button>\n          )}\n        </div>\n      ))}\n    </div>\n  </div>\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/PreviewPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\ninterface PreviewPanelProps {\n  artworkSrc: string;\n  hoverCharacter?: any;\n  selectedCharacter?: any;\n  selectedScript?: any;\n}\n\nexport const PreviewPanel: React.FC<PreviewPanelProps> = ({ artworkSrc, hoverCharacter, selectedCharacter, selectedScript }) => {\n  const character = hoverCharacter || selectedCharacter;\n  const title = character ? character.name : selectedScript?.name || 'Pick a script';\n  const subtitle = character ? character.team : selectedScript?.meta?.complexity;\n\n  const deriveCharacterDescription = (c: any): string | undefined => {\n    if (!c) return undefined;\n    // Primary fields\n    const direct = c.ability || c.description || c.abilityText || c.text;\n    if (direct && direct.trim()) return direct.trim();\n    // Look inside actions for the first non-empty description\n    const actionsObj = c.actions;\n    if (actionsObj && typeof actionsObj === 'object') {\n      const actionLists = Object.values(actionsObj).filter(Array.isArray) as any[][];\n      for (const list of actionLists) {\n        for (const action of list) {\n          if (action && typeof action.description === 'string' && action.description.trim()) {\n            return action.description.trim();\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n\n  const description = character ? deriveCharacterDescription(character) : selectedScript?.meta?.description;\n  const imageSrc = character ? `/artwork/characters/${(character.id || '').toLowerCase()}.png` : artworkSrc;\n\n  return (\n    <div className=\"card p-4 mb-3 flex flex-col h-[500px]\" data-testid=\"preview-panel\">\n      <div className=\"text-sm text-gray-300\">Preview</div>\n      <div className=\"mt-2 w-full bg-black/40 border border-gray-700 rounded flex items-center justify-center overflow-hidden\" style={{ height: '180px' }} data-testid=\"preview-art\">\n        <img\n          src={imageSrc}\n          onError={(e) => { (e.currentTarget as HTMLImageElement).src = '/script-art/placeholder.svg'; }}\n          alt={title}\n          className=\"object-contain w-full h-full\"\n        />\n      </div>\n      <div className=\"mt-4 pt-3 border-t border-gray-800 flex-1 flex flex-col min-h-0\" data-testid=\"preview-description\">\n        <div className=\"text-lg font-semibold text-gray-100 truncate\" title={title}>{title}</div>\n        {subtitle && (\n          <div className=\"text-xs text-gray-400 uppercase tracking-wide mt-1 mb-2\">\n            {subtitle}\n          </div>\n        )}\n        <div className=\"flex-1 min-h-0\">\n          <div className=\"h-full overflow-y-auto text-sm text-gray-200 whitespace-pre-wrap leading-relaxed pr-2 custom-scrollbar\">\n            {description || 'Select a script or hover over a character to view its description.'}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/ScriptCarousel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token {",
        "line": 2,
        "column": 13,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useRef } from 'react';\nimport type { LoadedScript } from '@botc/shared';\n\ninterface ScriptCarouselProps {\n  scripts: LoadedScript[];\n  selectedScriptId?: string;\n  title: string;\n  subtitle?: string;\n  keyboardNavigation?: boolean;\n  onScriptSelect: (scriptId: string) => void;\n  onScriptAction?: (scriptId: string) => void;\n  getActionProps?: (script: LoadedScript) => {\n    label: string;\n    isActive: boolean;\n    'data-testid'?: string;\n  };\n  testId?: string;\n  className?: string;\n  onKeyDown?: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n}\n\nconst ScriptCarousel: React.FC<ScriptCarouselProps> = ({\n  scripts,\n  selectedScriptId,\n  title,\n  subtitle,\n  keyboardNavigation = false,\n  onScriptSelect,\n  onScriptAction,\n  getActionProps,\n  testId,\n  className = '',\n  onKeyDown,\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  const scrollContainerBy = (delta: number) => {\n    if (containerRef.current) {\n      containerRef.current.scrollBy({ left: delta, behavior: 'smooth' });\n    }\n  };\n\n  if (scripts.length === 0) {\n    return (\n      <div className={`card w-full p-4 ${className}`}>\n        <div className=\"flex items-center justify-between mb-3\">\n          <div className=\"text-sm text-gray-300\">{title}</div>\n          {subtitle && <div className=\"text-xs text-gray-500\">{subtitle}</div>}\n        </div>\n        <div className=\"text-gray-400 text-sm py-6 px-4 w-full text-center\">\n          {title.includes('Storyteller') ? 'No scripts are available yet.' : 'Waiting for storyteller to share scripts.'}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`card w-full p-4 ${className}`}>\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"text-sm text-gray-300\">{title}</div>\n        {subtitle && <div className=\"text-xs text-gray-500\">{subtitle}</div>}\n        {keyboardNavigation && scripts.length > 0 && (\n          <div className=\"text-xs text-gray-500 uppercase tracking-wide\">Use ← → to navigate</div>\n        )}\n      </div>\n      \n      <div className=\"relative\">\n        <button\n          type=\"button\"\n          className=\"absolute left-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n          onClick={() => scrollContainerBy(-360)}\n          aria-label=\"Scroll scripts left\"\n        >\n          ←\n        </button>\n        \n        <div\n          ref={containerRef}\n          data-testid={testId}\n          className=\"flex gap-4 overflow-x-auto no-scrollbar scroll-smooth px-12\"\n          tabIndex={keyboardNavigation ? 0 : undefined}\n          onKeyDown={onKeyDown}\n        >\n          {scripts.map((script) => {\n            const isSelected = selectedScriptId === script.id;\n            const actionProps = getActionProps?.(script);\n            \n            return (\n              <div key={script.id} className=\"relative shrink-0 w-52\">\n                <button\n                  className={`w-full text-left border rounded-lg px-3 py-3 bg-clocktower-dark transition focus:outline-none focus:ring-2 focus:ring-clocktower-accent ${\n                    isSelected \n                      ? 'border-clocktower-accent shadow-[0_0_0_2px_rgba(56,189,248,0.3)]' \n                      : 'border-gray-700 hover:border-gray-500'\n                  }`}\n                  onClick={() => onScriptSelect(script.id)}\n                  data-testid={`script-${script.id}`}\n                >\n                  <div className=\"text-base font-semibold text-gray-100 truncate\" title={script.name}>\n                    {script.name}\n                  </div>\n                  <div className=\"flex items-center justify-between mt-1\">\n                    <div className=\"flex flex-col gap-1\">\n                      {script.meta?.complexity && (\n                        <div className=\"text-[11px] text-gray-400 uppercase tracking-wide\">\n                          {script.meta.complexity}\n                        </div>\n                      )}\n                      {script.meta?.playerCount && (\n                        <div className=\"text-[11px] text-gray-500\">\n                          Players {script.meta.playerCount.min ?? '?'}\n                          {script.meta.playerCount.max ? `–${script.meta.playerCount.max}` : ''}\n                        </div>\n                      )}\n                    </div>\n                    {script.modifiers && script.modifiers.length > 0 && (\n                      <div className=\"flex gap-1\">\n                        {script.modifiers.slice(0, 3).map((modifier: any, idx: number) => {\n                          let tokenColor = 'bg-gray-600/20 border-gray-500/50 text-gray-400';\n                          let tokenIcon = '?';\n                          \n                          switch (modifier.type) {\n                            case 'requires':\n                              tokenColor = 'bg-purple-600/20 border-purple-500/50 text-purple-300';\n                              tokenIcon = 'R';\n                              break;\n                            case 'adjustCounts':\n                              tokenColor = 'bg-amber-600/20 border-amber-500/50 text-amber-300';\n                              tokenIcon = '±';\n                              break;\n                            case 'mutuallyExclusive':\n                              tokenColor = 'bg-red-600/20 border-red-500/50 text-red-300';\n                              tokenIcon = '✗';\n                              break;\n                            case 'atLeastOneOf':\n                              tokenColor = 'bg-green-600/20 border-green-500/50 text-green-300';\n                              tokenIcon = '1+';\n                              break;\n                            case 'specialRule':\n                              tokenColor = 'bg-sky-600/20 border-sky-500/50 text-sky-300';\n                              tokenIcon = 'F';\n                              break;\n                          }\n                          \n                          return (\n                            <div\n                              key={idx}\n                              className={`w-4 h-4 rounded-full border flex items-center justify-center ${tokenColor}`}\n                              title={`${modifier.type}: ${modifier.note || 'Special rule applies'}`}\n                            >\n                              <span className=\"text-[6px] font-bold\">{tokenIcon}</span>\n                            </div>\n                          );\n                        })}\n                        {script.modifiers.length > 3 && (\n                          <div className=\"w-4 h-4 rounded-full bg-gray-600/20 border border-gray-500/50 flex items-center justify-center text-gray-400\">\n                            <span className=\"text-[6px] font-bold\">+{script.modifiers.length - 3}</span>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                </button>\n                \n                {actionProps && onScriptAction && (\n                  <button\n                    type=\"button\"\n                    className={`absolute -top-2 -right-2 w-7 h-7 rounded-full border text-sm font-bold transition ${\n                      actionProps.isActive \n                        ? 'bg-emerald-400 text-black border-emerald-200' \n                        : 'bg-gray-700 text-gray-200 border-gray-500 hover:bg-gray-600'\n                    }`}\n                    onClick={(event) => {\n                      event.stopPropagation();\n                      onScriptAction(script.id);\n                    }}\n                    aria-pressed={actionProps.isActive}\n                    aria-label={actionProps.label}\n                    data-testid={actionProps['data-testid']}\n                  >\n                    +\n                  </button>\n                )}\n              </div>\n            );\n          })}\n        </div>\n        \n        <button\n          type=\"button\"\n          className=\"absolute right-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n          onClick={() => scrollContainerBy(360)}\n          aria-label=\"Scroll scripts right\"\n        >\n          →\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default ScriptCarousel;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/ScriptProposalCard.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token {",
        "line": 2,
        "column": 13,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport type { LoadedScript } from '@botc/shared';\n\ninterface ScriptProposalCardProps {\n  proposal: any;\n  script?: LoadedScript;\n  upVotes: number;\n  downVotes: number;\n  myVote?: boolean | null;\n  isProposer: boolean;\n  score: number;\n  proposerCount: number;\n  onScriptSelect: (scriptId: string) => void;\n  onVote: (proposalId: string, vote: boolean | null) => void;\n}\n\nconst ScriptProposalCard: React.FC<ScriptProposalCardProps> = ({\n  proposal,\n  script,\n  upVotes,\n  downVotes,\n  myVote,\n  isProposer,\n  score,\n  proposerCount,\n  onScriptSelect,\n  onVote,\n}) => {\n  const scriptName = script?.name || proposal.scriptId;\n  const complexity = script?.meta?.complexity;\n  const voteUpActive = myVote === true;\n  const voteDownActive = myVote === false;\n\n  return (\n    <div\n      data-testid={`proposal-card-${proposal.id}`}\n      className={`shrink-0 w-60 border rounded-lg px-3 py-3 bg-clocktower-dark border-gray-700 transition ${\n        myVote != null ? 'shadow-[0_0_0_1px_rgba(56,189,248,0.15)]' : ''\n      }`}\n    >\n      <button\n        className=\"text-left w-full\"\n        onClick={() => onScriptSelect(proposal.scriptId)}\n      >\n        <div className=\"text-base font-semibold text-gray-100 truncate\" title={scriptName}>\n          {scriptName}\n        </div>\n        {complexity && (\n          <div className=\"text-[11px] text-gray-400 uppercase tracking-wide mt-1\">\n            {complexity}\n          </div>\n        )}\n      </button>\n      \n      <div className=\"mt-2 text-xs text-gray-400 flex items-center gap-2\">\n        <span>{proposerCount} proposer{proposerCount === 1 ? '' : 's'}</span>\n        {isProposer && (\n          <span className=\"px-2 py-0.5 rounded-full bg-emerald-500/20 text-emerald-200\">\n            You proposed\n          </span>\n        )}\n      </div>\n      \n      <div className=\"flex items-center gap-2 mt-3\">\n        <button\n          type=\"button\"\n          className={`px-3 py-1 rounded border text-sm font-semibold transition ${\n            voteUpActive \n              ? 'bg-emerald-400 text-black border-emerald-300' \n              : 'border-gray-700 text-gray-100 hover:border-gray-500'\n          }`}\n          onClick={() => onVote(proposal.id, voteUpActive ? null : true)}\n          aria-pressed={voteUpActive}\n          data-testid={`vote-up-${proposal.id}`}\n        >\n          👍 {upVotes}\n        </button>\n        <button\n          type=\"button\"\n          className={`px-3 py-1 rounded border text-sm font-semibold transition ${\n            voteDownActive \n              ? 'bg-rose-500 text-black border-rose-300' \n              : 'border-gray-700 text-gray-100 hover:border-gray-500'\n          }`}\n          onClick={() => onVote(proposal.id, voteDownActive ? null : false)}\n          aria-pressed={voteDownActive}\n          data-testid={`vote-down-${proposal.id}`}\n        >\n          👎 {downVotes}\n        </button>\n      </div>\n      \n      <div className=\"mt-2 text-xs text-gray-500\">\n        Popularity score: {score}\n      </div>\n    </div>\n  );\n};\n\nexport default ScriptProposalCard;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/ScriptScroller.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { CarouselScroller } from '../CarouselScroller';\n\ninterface ScriptScrollerProps {\n  scripts: any[];\n  selectedScriptId?: string;\n  onSelect?: (id: string) => void;\n}\n\nexport const ScriptScroller: React.FC<ScriptScrollerProps> = ({ scripts, selectedScriptId, onSelect }) => (\n  <CarouselScroller\n    items={scripts}\n    slidesPerView={7}\n  centered\n  renderSlide={(s: any) => (\n      <div key={s.id}>\n        <button\n          className={`px-3 py-2 rounded border text-xs ${selectedScriptId === s.id ? 'border-blue-400 bg-blue-900/20' : 'border-gray-700 bg-clocktower-dark hover:border-gray-500'}`}\n          onClick={() => onSelect?.(s.id)}\n        >\n          <div className=\"text-sm\">{s.name}</div>\n          {s.meta?.complexity && <div className=\"text-[10px] text-gray-400 capitalize\">{s.meta.complexity}</div>}\n        </button>\n      </div>\n    )}\n  />\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/lobby/ScriptVotingPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token {",
        "line": 2,
        "column": 13,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useRef } from 'react';\nimport type { LoadedScript } from '@botc/shared';\nimport ScriptProposalCard from './ScriptProposalCard';\n\ninterface ScriptProposalData {\n  proposal: any;\n  script?: LoadedScript;\n  upVotes: number;\n  downVotes: number;\n  myVote?: boolean | null;\n  isProposer: boolean;\n  createdAt: number;\n  score: number;\n  proposers: string[];\n}\n\ninterface ScriptVotingPanelProps {\n  scriptProposalsData: ScriptProposalData[];\n  onScriptSelect: (scriptId: string) => void;\n  onVote: (proposalId: string, vote: boolean | null) => void;\n  className?: string;\n}\n\nconst ScriptVotingPanel: React.FC<ScriptVotingPanelProps> = ({\n  scriptProposalsData,\n  onScriptSelect,\n  onVote,\n  className = '',\n}) => {\n  const scrollerRef = useRef<HTMLDivElement | null>(null);\n\n  const scrollContainerBy = (delta: number) => {\n    if (scrollerRef.current) {\n      scrollerRef.current.scrollBy({ left: delta, behavior: 'smooth' });\n    }\n  };\n\n  return (\n    <div className={`card p-4 ${className}`}>\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm text-gray-300\">Player Voting</div>\n        {scriptProposalsData.length > 0 && (\n          <div className=\"text-xs text-gray-500\">\n            Sorted by popularity (👍 minus 👎)\n          </div>\n        )}\n      </div>\n      \n      <div className=\"relative mt-3\">\n        <button\n          type=\"button\"\n          className=\"absolute left-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n          onClick={() => scrollContainerBy(-320)}\n          aria-label=\"Scroll proposed scripts left\"\n        >\n          ←\n        </button>\n        \n        <div\n          ref={scrollerRef}\n          data-testid=\"proposal-carousel\"\n          className=\"flex gap-3 overflow-x-auto no-scrollbar scroll-smooth px-12\"\n        >\n          {scriptProposalsData.length > 0 ? (\n            scriptProposalsData.map((entry) => (\n              <ScriptProposalCard\n                key={entry.proposal.id}\n                proposal={entry.proposal}\n                script={entry.script}\n                upVotes={entry.upVotes}\n                downVotes={entry.downVotes}\n                myVote={entry.myVote}\n                isProposer={entry.isProposer}\n                score={entry.score}\n                proposerCount={entry.proposers.length}\n                onScriptSelect={onScriptSelect}\n                onVote={onVote}\n              />\n            ))\n          ) : (\n            <div className=\"text-gray-400 text-sm py-6 px-4 w-full text-center\">\n              No proposed scripts yet. Press + above to start a vote.\n            </div>\n          )}\n        </div>\n        \n        <button\n          type=\"button\"\n          className=\"absolute right-1 top-1/2 -translate-y-1/2 z-10 bg-clocktower-dark/85 hover:bg-clocktower-dark/95 border border-gray-700 rounded-full w-9 h-9 flex items-center justify-center text-lg text-gray-200 shadow\"\n          onClick={() => scrollContainerBy(320)}\n          aria-label=\"Scroll proposed scripts right\"\n        >\n          →\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default ScriptVotingPanel;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/setup/DetailedNightOrderPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { extractNightOrder, NightOrderEntry } from '../../utils/setupUtils';\n\ninterface DetailedNightOrderPanelProps {\n  selectedScript?: any;\n}\n\nexport const DetailedNightOrderPanel: React.FC<DetailedNightOrderPanelProps> = ({ selectedScript }) => {\n  const nightOrder: NightOrderEntry[] = React.useMemo(() => extractNightOrder(selectedScript), [selectedScript]);\n  if (!nightOrder.length) return null;\n\n  return (\n    <div className=\"card p-3 mb-3\" data-testid=\"detailed-night-order-panel\">\n      <div className=\"text-sm font-semibold text-gray-200 mb-2 flex items-center justify-between\">\n        <span>Detailed Night Order</span>\n        <span className=\"text-xs text-gray-500\">{nightOrder.length} steps</span>\n      </div>\n      <ol className=\"space-y-1 max-h-64 overflow-y-auto custom-scrollbar text-xs pr-1\">\n        {nightOrder.map((e, idx) => (\n          <li key={idx} className=\"flex gap-2 items-start\">\n            <span className=\"text-gray-500 w-5 text-right flex-shrink-0\">{idx + 1}.</span>\n            <div className=\"flex-1 min-w-0\">\n              <div className=\"text-gray-200 truncate\" title={e.id}>{e.id}</div>\n              {e.description && <div className=\"text-[10px] text-gray-400 leading-tight whitespace-pre-wrap\">{e.description}</div>}\n            </div>\n          </li>\n        ))}\n      </ol>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/setup/GameSetupInfoPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { RoleDistribution, computeExpectedDistribution } from '../../utils/setupUtils';\n\ninterface GameSetupInfoPanelProps {\n  playerCount: number;\n  selectedScript?: any;\n  selectedCharacterIds: string[];\n}\n\nexport const GameSetupInfoPanel: React.FC<GameSetupInfoPanelProps> = ({ playerCount, selectedScript, selectedCharacterIds }) => {\n  const hasScript = !!selectedScript;\n  const distribution: RoleDistribution = React.useMemo(\n    () => (hasScript ? computeExpectedDistribution(playerCount, selectedScript, selectedCharacterIds) : { townsfolk: 0, outsiders: 0, minions: 0, demons: 0 }),\n    [playerCount, selectedScript, selectedCharacterIds, hasScript]\n  );\n  const scriptName = hasScript ? selectedScript?.name : 'No Script Selected';\n  const complexity = hasScript ? (selectedScript?.meta?.complexity || selectedScript?.complexity) : '—';\n\n  return (\n    <div className=\"card p-3 mb-3\" data-testid=\"game-setup-info-panel\">\n      <div className=\"flex items-center justify-between mb-2\">\n        <div className=\"text-sm font-semibold text-gray-200\">Game Setup</div>\n        <div className=\"text-xs text-gray-400\">Players: {playerCount}</div>\n      </div>\n      <div className=\"text-xs text-gray-400 mb-2\">Script: <span className=\"text-gray-200 font-medium\">{scriptName}</span> • Difficulty: {complexity}</div>\n      <div className=\"grid grid-cols-4 gap-2 text-center text-[11px]\">\n        {(['townsfolk','outsiders','minions','demons'] as const).map(team => (\n          <div key={team} className={`bg-clocktower-dark/40 border rounded p-2 ${hasScript ? 'border-gray-700' : 'border-gray-800 opacity-50'}`}>            \n            <div className=\"uppercase tracking-wide text-[10px] text-gray-400 mb-1\">{team}</div>\n            <div className=\"text-lg font-bold text-gray-100\">{hasScript ? distribution[team] : '—'}</div>\n          </div>\n        ))}\n      </div>\n      {hasScript && selectedScript?.modifiers?.length ? (\n        <div className=\"mt-3 text-[10px] text-gray-400 italic\">Distribution reflects active script modifiers.</div>\n      ) : !hasScript ? (\n        <div className=\"mt-3 text-[10px] text-gray-500 italic\">Select a script to calculate distribution.</div>\n      ) : null}\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/components/setup/GameStatisticsPanel.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { detectScriptIssues, summarizeDifficulty, validateSetup, computeExpectedDistribution } from '../../utils/setupUtils';\n\ninterface GameStatisticsPanelProps {\n  selectedScript?: any;\n  playerCount: number;\n  selectedCharacterIds: string[];\n}\n\nexport const GameStatisticsPanel: React.FC<GameStatisticsPanelProps> = ({ selectedScript, playerCount, selectedCharacterIds }) => {\n  const difficulty = summarizeDifficulty(selectedScript) || 'Unknown';\n  const scriptIssues = React.useMemo(() => detectScriptIssues(selectedScript), [selectedScript]);\n  const expected = React.useMemo(() => computeExpectedDistribution(playerCount, selectedScript, selectedCharacterIds), [playerCount, selectedScript, selectedCharacterIds]);\n  const validation = React.useMemo(() => validateSetup(selectedScript, selectedCharacterIds, expected), [selectedScript, selectedCharacterIds, expected]);\n\n  return (\n    <div className=\"card p-3\" data-testid=\"game-statistics-panel\">\n      <div className=\"text-sm font-semibold text-gray-200 mb-1\">Game Statistics</div>\n      <div className=\"text-[11px] text-gray-400 mb-2\">Difficulty: <span className=\"text-gray-200\">{difficulty}</span></div>\n      {scriptIssues.length > 0 && (\n        <div className=\"mb-3\">\n          <div className=\"text-[10px] uppercase tracking-wide text-gray-500 mb-1\">Heuristic Issues</div>\n          <ul className=\"list-disc ml-5 space-y-0.5 text-[11px] text-gray-300\">\n            {scriptIssues.map((issue, idx) => <li key={idx}>{issue}</li>)}\n          </ul>\n        </div>\n      )}\n      <div>\n        <div className=\"text-[10px] uppercase tracking-wide text-gray-500 mb-1\">Validation</div>\n        {validation.issues.length === 0 ? (\n          <div className=\"text-[11px] text-green-400\">All good.</div>\n        ) : (\n          <ul className=\"list-disc ml-5 space-y-0.5 text-[11px] text-red-300\">\n            {validation.issues.map((i, idx) => <li key={idx}>{i.message}</li>)}\n          </ul>\n        )}\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/constants/visual.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 4,
        "column": 31,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Central visual style constants for lobby character & modifier rings.\n// Keep in sync with legend and CharacterGrid.\n\nexport const TEAM_RING_CLASSES: Record<string, string> = {\n  townsfolk: 'ring-green-500/60',\n  outsider: 'ring-blue-400/60',\n  minion: 'ring-purple-500/60',\n  demon: 'ring-red-500/70',\n  traveller: 'ring-amber-400/60',\n  fabled: 'ring-purple-400/60',\n};\n\n// Script modifier ring accents (when applied directly to a character token)\n// Using subtle colored shadow to avoid replacing team ring color; we add an outer ring via box-shadow.\nexport const MODIFIER_RING_DECORATION: Record<string, string> = {\n  requires: 'after:content-[\" \"] after:absolute after:inset-0 after:rounded-full after:ring-2 after:ring-purple-400/70',\n  adjustCounts: 'after:content-[\" \"] after:absolute after:inset-0 after:rounded-full after:ring-2 after:ring-amber-400/70',\n  mutuallyExclusive: 'after:content-[\" \"] after:absolute after:inset-0 after:rounded-full after:ring-2 after:ring-red-400/70',\n  atLeastOneOf: 'after:content-[\" \"] after:absolute after:inset-0 after:rounded-full after:ring-2 after:ring-green-400/70',\n  specialRule: 'after:content-[\" \"] after:absolute after:inset-0 after:rounded-full after:ring-2 after:ring-sky-400/70',\n};\n\nexport type ModifierType = keyof typeof MODIFIER_RING_DECORATION;\n\nexport function buildCharacterTokenClass(base: string, modifierTypes: string[] = []) {\n  const decorations = modifierTypes\n    .map((t) => MODIFIER_RING_DECORATION[t])\n    .filter(Boolean)\n    .join(' ');\n  if (!decorations) return base;\n  return `${base  } relative ${  decorations}`;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/context/GameContext.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { createContext, useContext, ReactNode } from 'react';\n\ninterface GameContextType {\n  // Add game context properties here\n}\n\nconst GameContext = createContext<GameContextType | undefined>(undefined);\n\ninterface GameProviderProps {\n  children: ReactNode;\n}\n\nexport const GameProvider: React.FC<GameProviderProps> = ({ children }) => {\n  // Game context logic here\n  const value: GameContextType = {\n    // Context values\n  };\n\n  return (\n    <GameContext.Provider value={value}>\n      {children}\n    </GameContext.Provider>\n  );\n};\n\nexport const useGameContext = () => {\n  const context = useContext(GameContext);\n  if (context === undefined) {\n    throw new Error('useGameContext must be used within a GameProvider');\n  }\n  return context;\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/context/KeycloakContext.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { createContext, useContext, useEffect, useState, ReactNode, useRef } from 'react';\nimport Keycloak, { KeycloakInitOptions } from 'keycloak-js';\n\ninterface KeycloakContextType {\n  keycloak: Keycloak | null;\n  authenticated: boolean;\n  loading: boolean;\n  login: () => void;\n  logout: () => void;\n  token: string | null;\n  userInfo: any;\n}\n\nconst KeycloakContext = createContext<KeycloakContextType | undefined>(undefined);\n\nexport const useKeycloak = () => {\n  const context = useContext(KeycloakContext);\n  if (!context) {\n    throw new Error('useKeycloak must be used within a KeycloakProvider');\n  }\n  return context;\n};\n\ninterface KeycloakProviderProps {\n  children: ReactNode;\n}\n\nexport const KeycloakProvider: React.FC<KeycloakProviderProps> = ({ children }) => {\n  const [keycloak, setKeycloak] = useState<Keycloak | null>(null);\n  const [authenticated, setAuthenticated] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [token, setToken] = useState<string | null>(null);\n  const [userInfo, setUserInfo] = useState<any>(null);\n\n  const initRef = useRef(false);\n\n  useEffect(() => {\n    if (initRef.current) return; // guard against React strict double invoke in dev\n    initRef.current = true;\n\n    const hash = window.location.hash;\n    if (hash.startsWith('#error=login_required')) {\n      // Remove error hash so we don't loop\n      console.warn('Detected login_required hash from Keycloak. Showing login prompt.');\n      history.replaceState(null, '', window.location.pathname + window.location.search);\n      setLoading(false);\n      return; // Let user click Login\n    }\n\n    const run = async () => {\n      try {\n        const kcConfig = {\n          url: import.meta.env.VITE_KEYCLOAK_URL || 'http://localhost:8080',\n          realm: 'botct',\n          clientId: 'botct-client'\n        };\n        console.log('Initializing Keycloak with config', kcConfig);\n        const kc = new Keycloak(kcConfig);\n        setKeycloak(kc);\n\n        const options: KeycloakInitOptions = {\n            onLoad: 'check-sso',\n            checkLoginIframe: false,\n            // silent check only if the file exists (served from public/)\n        };\n        // Try to detect silent-check file existence cheaply\n        fetch('/silent-check-sso.html', { method: 'HEAD' })\n          .then(r => { if (r.ok) (options as any).silentCheckSsoRedirectUri = `${window.location.origin  }/silent-check-sso.html`; })\n          .catch(() => {} )\n          .finally(async () => {\n            let authenticated = false;\n            try {\n              authenticated = await kc.init(options);\n            } catch (e: any) {\n              console.warn('Keycloak init (check-sso) failed, will fallback to unauth state:', e?.message || e);\n              authenticated = false;\n            }\n            setAuthenticated(authenticated);\n            if (authenticated) {\n              setToken(kc.token || null);\n              try {\n                const profile = await kc.loadUserInfo();\n                setUserInfo(profile);\n                  try {\n                    const existing = localStorage.getItem('botc-player-name');\n                    if (!existing || !existing.trim()) {\n                      const u: any = profile || {};\n                      // Priority order for avatar name generation:\n                      // 1. preferred_username (if not email-like)\n                      // 2. first name + last initial\n                      // 3. name field\n                      // 4. first name only\n                      // 5. username (if not email-like)\n                      let candidate = '';\n                      \n                      // Check preferred_username (but skip if it looks like an email)\n                      if (u.preferred_username && !u.preferred_username.includes('@')) {\n                        candidate = u.preferred_username;\n                      }\n                      // Try first name + last initial\n                      else if (u.given_name && u.family_name) {\n                        candidate = `${u.given_name} ${u.family_name.charAt(0).toUpperCase()}.`;\n                      }\n                      // Try the full name field\n                      else if (u.name && !u.name.includes('@')) {\n                        candidate = u.name;\n                      }\n                      // Try just first name\n                      else if (u.given_name) {\n                        candidate = u.given_name;\n                      }\n                      // Last resort: username if not email-like\n                      else if (u.sub && !u.sub.includes('@')) {\n                        candidate = u.sub;\n                      }\n                      \n                      if (candidate && candidate.trim()) {\n                        console.log('Setting avatar name from Keycloak profile:', candidate.trim());\n                        localStorage.setItem('botc-player-name', candidate.trim());\n                      }\n                    }\n                  } catch (e) {\n                    console.warn('Could not set avatar name from profile:', e);\n                  }\n              } catch (e) {\n                console.warn('Could not load user profile', e);\n              }\n              // refresh loop\n              const refreshHandle = setInterval(() => {\n                kc.updateToken(30).then(refreshed => {\n                  if (refreshed) setToken(kc.token || null);\n                }).catch(err => {\n                  console.error('Token refresh failed, clearing auth', err);\n                  clearInterval(refreshHandle);\n                  setAuthenticated(false);\n                  setToken(null);\n                  setUserInfo(null);\n                });\n              }, 10000);\n            }\n            setLoading(false);\n          });\n      } catch (err) {\n        console.error('Keycloak bootstrap failure', err);\n        setLoading(false);\n      }\n    };\n    run();\n  }, []);\n\n  const login = () => {\n    if (!keycloak) {\n      console.warn('Login requested before Keycloak ready');\n      return;\n    }\n    // Use redirect login, not prompt=none\n    keycloak.login({ prompt: 'login' });\n  };\n\n  const logout = () => {\n    if (keycloak) {\n      setAuthenticated(false);\n      setToken(null);\n      setUserInfo(null);\n      keycloak.logout();\n    }\n  };\n\n  const value: KeycloakContextType = {\n    keycloak,\n    authenticated,\n    loading,\n    login,\n    logout,\n    token,\n    userInfo\n  };\n\n  return (\n    <KeycloakContext.Provider value={value}>\n      {children}\n    </KeycloakContext.Provider>\n  );\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/data/fetchScriptDataSource.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token implements",
        "line": 3,
        "column": 36,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ScriptDataSource } from '@botc/shared';\n\nexport class FetchScriptDataSource implements ScriptDataSource {\n  constructor(private baseUrl: string = '/api/data') {}\n\n  async loadCharacters(scriptPath: string): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/scripts/${scriptPath}/characters`);\n    if (!response.ok) {\n      throw new Error(`Failed to load characters for ${scriptPath}: ${response.statusText}`);\n    }\n    return response.json();\n  }\n\n  async loadMetadata(scriptPath: string): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/scripts/${scriptPath}/metadata`);\n    if (!response.ok) {\n      throw new Error(`Failed to load metadata for ${scriptPath}: ${response.statusText}`);\n    }\n    return response.json();\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/hooks/useGameState.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token {",
        "line": 5,
        "column": 13,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useMemo } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useGameStore } from '../store/gameStore';\nimport * as Enums from '@botc/shared';\nimport type { GameState } from '@botc/shared';\n\nexport const useGameConnection = () => {\n  const { gameId } = useParams();\n  const navigate = useNavigate();\n  const { connect, setSeat, seatId, isStoryteller } = useGameStore();\n  \n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [playerId] = useState(() => {\n    const nameKey = 'botc-player-name';\n    const name = (localStorage.getItem(nameKey) || '').trim();\n    return name;\n  });\n\n  useEffect(() => {\n    if (!gameId) return;\n    \n    // Require player name; redirect to join page if missing and gameId known\n    if (!playerId || !playerId.trim()) {\n      navigate(`/join/${gameId}`);\n      return;\n    }\n    \n    let cancelled = false;\n    \n    async function init() {\n      try {\n        // Fetch initial state\n        const res = await fetch(`/api/games/${gameId}`);\n        if (!res.ok) throw new Error('Game not found');\n        const game: GameState = await res.json();\n        if (cancelled) return;\n\n        const storedSeat = localStorage.getItem('botc-seat-id');\n        \n        if (game.phase === Enums.GamePhase.LOBBY) {\n          // Try to reuse existing seat first by playerId or stored seatId\n          const mySeat = game.seats.find((s: any) => \n            (storedSeat && s.id === storedSeat) || s.playerId === playerId\n          );\n          \n          if (!mySeat) {\n            // Join the game\n            const joinRes = await fetch(`/api/games/${gameId}/join`, {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ playerId })\n            });\n            if (!joinRes.ok) throw new Error('Failed to join game');\n            const joinData = await joinRes.json();\n            setSeat(joinData.seatId, joinData.isStoryteller);\n            connect(game.id, joinData.seatId);\n          } else {\n            setSeat(mySeat.id, mySeat.id === (game as any).storytellerSeatId);\n            connect(game.id, mySeat.id);\n          }\n        } else {\n          // Game already advanced; try to find existing seat by playerId\n          const mySeat = game.seats.find((s: any) => \n            (storedSeat && s.id === storedSeat) || s.playerId === playerId\n          );\n          \n          if (!mySeat) {\n            setError('Game already started. Ask the Storyteller to add you.');\n          } else {\n            setSeat(mySeat.id, mySeat.id === (game as any).storytellerSeatId);\n            connect(game.id, mySeat.id);\n          }\n        }\n      } catch (e: any) {\n        setError(e.message || 'Failed to load lobby');\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    init();\n    return () => { cancelled = true; };\n  }, [gameId, playerId, navigate, connect, setSeat]);\n\n  return {\n    gameId,\n    playerId,\n    loading,\n    error,\n    seatId,\n    isStoryteller,\n  };\n};\n\nexport const useScriptSelection = () => {\n  const { \n    availableScripts, \n    loadScripts, \n    currentGame, \n    seatId,\n    isStoryteller \n  } = useGameStore();\n  \n  const [selectedScriptId, setSelectedScriptId] = useState<string>('');\n\n  // Aggressively preload scripts immediately when hook is used\n  useEffect(() => {\n    loadScripts();\n  }, [loadScripts]);\n\n  // Default the dropdown to the game's current script (if any) once available\n  useEffect(() => {\n    if (!selectedScriptId && currentGame?.scriptId) {\n      setSelectedScriptId(currentGame.scriptId);\n    }\n  }, [currentGame?.scriptId, selectedScriptId]);\n\n  // Get available scripts from game state, fallback to empty array\n  const storytellerSelectedScripts = currentGame?.availableScriptIds || [];\n  \n  // For storytellers: all scripts available for selection\n  // For players: only scripts the storyteller has approved\n  const visibleScripts = useMemo(() => {\n    if (isStoryteller) {\n      return availableScripts;\n    }\n    return availableScripts.filter((script: any) => \n      storytellerSelectedScripts.includes(script.id)\n    );\n  }, [availableScripts, isStoryteller, storytellerSelectedScripts]);\n\n  const selectedScript = useMemo(() => {\n    // Prefer manual selection; otherwise fall back to the game's current script\n    const manual = visibleScripts.find((s: any) => s.id === selectedScriptId);\n    if (manual) return manual;\n    if (currentGame?.scriptId) {\n      return visibleScripts.find((s: any) => s.id === currentGame.scriptId);\n    }\n    return undefined;\n  }, [visibleScripts, selectedScriptId, currentGame?.scriptId]);\n\n  const scriptLookup = useMemo(() => {\n    const byId: Record<string, any> = {};\n    for (const script of availableScripts) {\n      byId[script.id] = script;\n    }\n    return byId;\n  }, [availableScripts]);\n\n  const storytellerScriptObjects = useMemo(() => {\n    return storytellerSelectedScripts\n      .map((id: string) => scriptLookup[id])\n      .filter(Boolean);\n  }, [storytellerSelectedScripts, scriptLookup]);\n\n  const scriptUsedName = useMemo(() => {\n    if (selectedScript?.name) return selectedScript.name;\n    if (currentGame?.scriptId) {\n      return scriptLookup[currentGame.scriptId]?.name || currentGame.scriptId;\n    }\n    return undefined;\n  }, [selectedScript?.name, currentGame?.scriptId, scriptLookup]);\n\n  // Helper function to update available scripts on server\n  const updateAvailableScripts = async (scriptIds: string[]) => {\n    if (!currentGame?.id || !seatId) return;\n    try {\n      await fetch(`/api/games/${currentGame.id}/scripts/available`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ storytellerSeatId: seatId, scriptIds })\n      });\n    } catch (error) {\n      console.error('Failed to update available scripts:', error);\n    }\n  };\n\n  const toggleStorytellerScript = async (scriptId: string) => {\n    if (!isStoryteller || !currentGame?.id || !seatId) return;\n    const nextIds = storytellerSelectedScripts.includes(scriptId)\n      ? storytellerSelectedScripts.filter((id: string) => id !== scriptId)\n      : Array.from(new Set([...storytellerSelectedScripts, scriptId]));\n    await updateAvailableScripts(nextIds);\n  };\n\n  return {\n    selectedScriptId,\n    setSelectedScriptId,\n    selectedScript,\n    visibleScripts,\n    availableScripts,\n    storytellerSelectedScripts,\n    storytellerScriptObjects,\n    scriptLookup,\n    scriptUsedName,\n    toggleStorytellerScript,\n  };\n};",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/hooks/useScriptProposals.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 8,
        "column": 15,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMemo } from 'react';\nimport { useGameStore } from '../store/gameStore';\n\nexport const useScriptProposals = () => {\n  const { currentGame, seatId, availableScripts } = useGameStore();\n\n  const scriptLookup = useMemo(() => {\n    const byId: Record<string, any> = {};\n    for (const script of availableScripts) {\n      byId[script.id] = script;\n    }\n    return byId;\n  }, [availableScripts]);\n\n  const scriptProposalsData = useMemo(() => {\n    const raw = currentGame?.scriptProposals || [];\n    return raw.map((proposal: any) => {\n      const script = scriptLookup[proposal.scriptId] || \n        availableScripts.find((s: any) => s.id === proposal.scriptId);\n      const votes = proposal.votes || {};\n      const entries = Object.entries(votes) as Array<[string, boolean]>;\n      const upVotes = entries.filter(([, vote]) => vote === true).length;\n      const downVotes = entries.filter(([, vote]) => vote === false).length;\n      const myVote = seatId ? votes[seatId] : undefined;\n      const proposers: string[] = Array.isArray(proposal.proposers)\n        ? proposal.proposers\n        : proposal.proposedBy\n          ? [proposal.proposedBy]\n          : [];\n      const isProposer = seatId ? proposers.includes(seatId) : false;\n      const createdAt = proposal.createdAt ? new Date(proposal.createdAt).getTime() : 0;\n      const score = upVotes - downVotes;\n      return {\n        proposal,\n        script,\n        upVotes,\n        downVotes,\n        myVote,\n        isProposer,\n        createdAt,\n        score,\n        proposers\n      };\n    }).sort((a: any, b: any) => {\n      if (b.score !== a.score) return b.score - a.score;\n      if (b.upVotes !== a.upVotes) return b.upVotes - a.upVotes;\n      if (a.downVotes !== b.downVotes) return a.downVotes - b.downVotes;\n      return a.createdAt - b.createdAt;\n    });\n  }, [currentGame?.scriptProposals, scriptLookup, availableScripts, seatId]);\n\n  const proposalByScriptId = useMemo(() => {\n    const map = new Map<string, any>();\n    for (const entry of scriptProposalsData) {\n      map.set(entry.proposal.scriptId, entry);\n    }\n    return map;\n  }, [scriptProposalsData]);\n\n  const togglePlayerProposal = async (scriptId: string) => {\n    if (!currentGame?.id || !seatId) return;\n    const existing = proposalByScriptId.get(scriptId);\n    const alreadyProposer = existing ? existing.proposers.includes(seatId) : false;\n    try {\n      await fetch(`/api/games/${currentGame.id}/scripts/propose`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          proposerSeatId: seatId, \n          scriptId, \n          active: !alreadyProposer \n        })\n      });\n    } catch (error) {\n      console.error('Failed to toggle script proposal', error);\n    }\n  };\n\n  const submitProposalVote = async (proposalId: string, vote: boolean | null) => {\n    if (!currentGame?.id || !seatId) return;\n    try {\n      await fetch(`/api/games/${currentGame.id}/scripts/vote`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ voterSeatId: seatId, proposalId, vote })\n      });\n    } catch (error) {\n      console.error('Failed to submit script vote', error);\n    }\n  };\n\n  return {\n    scriptProposalsData,\n    proposalByScriptId,\n    togglePlayerProposal,\n    submitProposalVote,\n  };\n};",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/main.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token !",
        "line": 8,
        "column": 52,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App.tsx';\nimport { KeycloakProvider } from './context/KeycloakContext.tsx';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <KeycloakProvider>\n      <BrowserRouter>\n        <App />\n      </BrowserRouter>\n    </KeycloakProvider>\n  </React.StrictMode>,\n);\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/GamePage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 9,
        "column": 15,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { useGameStore } from '../store/gameStore';\nimport { useNavigate } from 'react-router-dom';\nimport { usePTT } from '../utils/usePTT';\nimport { PTTButton } from '../components/PTTButton';\nimport { VideoTile } from '../components/VideoTile';\n\nconst GamePage: React.FC = () => {\n  const { gameId } = useParams();\n  const navigate = useNavigate();\n  const { connect, currentGame, seatId, isStoryteller, leaveGame } = useGameStore() as any;\n  const { pttState, startPTT, endPTT, setMode } = usePTT();\n\n  useEffect(() => {\n    if (!gameId) return;\n  connect(gameId as any, seatId || (typeof localStorage !== 'undefined' ? localStorage.getItem('botc-seat-id') : undefined) || undefined);\n  }, [gameId]);\n\n  if (!currentGame) {\n    return (\n      <div className=\"max-w-6xl mx-auto\">\n        <div className=\"card p-8 text-center\">Loading game...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-6xl mx-auto\">\n  <h1 className=\"text-4xl font-medieval font-bold text-center mb-8\">Blood on the Clocktower</h1>\n      <div className=\"flex justify-end mb-2\">\n        <button\n          className=\"btn-secondary\"\n          onClick={async () => {\n            const ok = await leaveGame();\n            if (ok) navigate('/');\n          }}\n        >\n          Leave Game\n        </button>\n      </div>\n      \n      {/* Game Status */}\n      <div className=\"card p-6 mb-6\">\n        <div className=\"flex justify-between items-center\">\n          <div className=\"flex gap-8\">\n            <div>\n              <span className=\"text-gray-400\">Phase:</span> \n              <span className=\"font-semibold ml-2\">{currentGame.phase}</span>\n            </div>\n            <div>\n              <span className=\"text-gray-400\">Day:</span> \n              <span className=\"font-semibold ml-2\">{currentGame.day}</span>\n            </div>\n            <div>\n              <span className=\"text-gray-400\">Players:</span> \n              <span className=\"font-semibold ml-2\">{currentGame.seats.length}</span>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-4\">\n            <PTTButton\n              pttState={pttState}\n              onToggleMode={setMode}\n              onStart={startPTT}\n              onEnd={endPTT}\n            />\n            <div className=\"text-sm text-gray-400 flex items-center gap-3\">\n              <span>Script: {currentGame.scriptId}</span>\n              {isStoryteller && <span className=\"px-2 py-0.5 rounded bg-yellow-700 text-yellow-200\">Storyteller</span>}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Video Grid */}\n      <div className=\"card p-6\">\n        <h2 className=\"text-xl font-semibold mb-4\">Players</h2>\n        <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4\">\n          {currentGame.seats.map((seat: any, index: number) => {\n            // Mock PTT state - in real implementation this would come from WebSocket events\n            const mockPttState = {\n              seatId: seat.id,\n              isMuted: true,\n              isSpeaking: false,\n              volume: 0.8,\n              isDucked: false\n            };\n\n            return (\n              <VideoTile\n                key={seat.id}\n                seatId={seat.id}\n                playerName={seat.playerId ? seat.playerId.slice(0, 8) : `NPC ${index + 1}`}\n                pttState={mockPttState}\n                isStoryteller={isStoryteller && seatId === seat.id}\n                className={`aspect-video ${\n                  seat.isAlive\n                    ? 'ring-2 ring-gray-700 hover:ring-gray-600'\n                    : 'opacity-50'\n                }`}\n              />\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default GamePage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/HomePage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 5,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { useKeycloak } from '../context/KeycloakContext';\nimport { useNavigate } from 'react-router-dom';\n\ninterface PublicGame {\n  id: string;\n  gameName?: string;\n  scriptId: string;\n  phase: string;\n  seats: Array<{ playerId?: string; isNPC: boolean; position: number }>;\n  createdAt: string;\n}\n\n\nconst HomePage: React.FC = () => {\n  const navigate = useNavigate();\n  const { userInfo, authenticated, loading } = useKeycloak();\n  const [joinId, setJoinId] = useState('');\n  const [gameName, setGameName] = useState('');\n  const [isPublic, setIsPublic] = useState(true);\n  const [playerName, setPlayerName] = useState<string>(localStorage.getItem('botc-player-name') || '');\n  const [publicGames, setPublicGames] = useState<PublicGame[]>([]);\n  const [loadingGames, setLoadingGames] = useState(false);\n\n  // Generate a unique game name with timestamp\n  const generateGameName = () => {\n    const adjectives = ['Mystical', 'Ancient', 'Shadowy', 'Whispering', 'Haunted', 'Moonlit', 'Cursed', 'Enchanted', 'Dark', 'Forgotten'];\n    const nouns = ['Clocktower', 'Village', 'Manor', 'Castle', 'Tavern', 'Cathedral', 'Mansion', 'Fortress', 'Chapel', 'Abbey'];\n    const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];\n    const noun = nouns[Math.floor(Math.random() * nouns.length)];\n    const timestamp = new Date().toLocaleTimeString('en-US', { \n      hour12: false, \n      hour: '2-digit', \n      minute: '2-digit' \n    });\n    return `${adjective} ${noun} (${timestamp})`;\n  };\n\n  // Generate a default player name\n  const generatePlayerName = () => {\n    const names = ['Traveler', 'Wanderer', 'Seeker', 'Guardian', 'Shadow', 'Mystic', 'Oracle', 'Sage'];\n    const name = names[Math.floor(Math.random() * names.length)];\n    const number = Math.floor(Math.random() * 1000);\n    return `${name}${number}`;\n  };\n\n  // Auto-populate game name if empty when component loads\n  useEffect(() => {\n    if (!gameName) {\n      setGameName(generateGameName());\n    }\n  }, []);\n\n  // Update playerName from Keycloak profile if available and not already set\n  useEffect(() => {\n    if (authenticated && userInfo) {\n      const existing = localStorage.getItem('botc-player-name');\n      if (!existing || !existing.trim()) {\n        let candidate = '';\n        if (userInfo.preferred_username && !userInfo.preferred_username.includes('@')) {\n          candidate = userInfo.preferred_username;\n        } else if (userInfo.given_name && userInfo.family_name) {\n          candidate = `${userInfo.given_name} ${userInfo.family_name.charAt(0).toUpperCase()}.`;\n        } else if (userInfo.name && !userInfo.name.includes('@')) {\n          candidate = userInfo.name;\n        } else if (userInfo.given_name) {\n          candidate = userInfo.given_name;\n        } else if (userInfo.sub && !userInfo.sub.includes('@')) {\n          candidate = userInfo.sub;\n        }\n        if (candidate && candidate.trim()) {\n          setPlayerName(candidate.trim());\n          localStorage.setItem('botc-player-name', candidate.trim());\n        }\n      }\n    }\n    \n    // Ensure we always have a player name for the Create Game button to work\n    if (authenticated && (!playerName || !playerName.trim())) {\n      const defaultName = generatePlayerName();\n      setPlayerName(defaultName);\n      localStorage.setItem('botc-player-name', defaultName);\n    }\n  }, [authenticated, userInfo, playerName]);\n\n  // Keep localStorage in sync with input\n  useEffect(() => {\n    if (playerName && playerName.trim()) {\n      localStorage.setItem('botc-player-name', playerName.trim());\n    }\n  }, [playerName]);\n\n  // Fetch public games when authenticated\n  const fetchPublicGames = async () => {\n    if (!authenticated) return;\n    \n    try {\n      setLoadingGames(true);\n      const response = await fetch('/api/games/public');\n      if (response.ok) {\n        const games = await response.json();\n        setPublicGames(games);\n      }\n    } catch (error) {\n      console.error('Failed to fetch public games:', error);\n    } finally {\n      setLoadingGames(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchPublicGames();\n  }, [authenticated]);\n\n  const handleCreateGame = async () => {\n    if (!playerName.trim()) return; // guard\n    \n    // Auto-generate game name if empty\n    const finalGameName = gameName.trim() || generateGameName();\n    \n    try {\n      const response = await fetch('/api/games', { \n        method: 'POST', \n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          gameName: finalGameName,\n          isPublic \n        })\n      });\n  const data = await response.json();\n      // Navigate to lobby\n      window.location.href = `/lobby/${data.gameId}`;\n    } catch (error) {\n      console.error('Failed to create game:', error);\n    }\n  };\n\n  const handleJoin = () => {\n    if (!playerName.trim()) return;\n    if (!joinId) return;\n    navigate(`/lobby/${joinId}`);\n  };\n\n  const handleJoinPublicGame = (gameId: string) => {\n    if (!playerName.trim()) return;\n    navigate(`/lobby/${gameId}`);\n  };\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"card p-8\">\n          <div className=\"text-center\">\n            <div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-clocktower-accent mx-auto mb-4\"></div>\n            <p>Initializing authentication...</p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-4xl mx-auto text-center\">\n      <header className=\"mb-12\">\n        <h1 className=\"text-6xl font-medieval font-bold text-clocktower-accent mb-4\">\n          Blood on the Clocktower\n        </h1>\n        <p className=\"text-xl text-gray-300 mb-8\">\n          Digital Implementation with AI-Assisted Gameplay\n        </p>\n      </header>\n\n      {/* Avatar Name Panel */}\n      <div className=\"card p-8 mb-8\">\n        <h2 className=\"text-2xl font-semibold mb-4\">Your Avatar Name</h2>\n        <p className=\"text-gray-300 mb-4\">Choose the name other players will see in the lobby.</p>\n        <div className=\"flex flex-col sm:flex-row gap-3 items-stretch sm:items-center\">\n          <input\n            value={playerName}\n            onChange={(e) => setPlayerName(e.target.value)}\n            type=\"text\"\n            placeholder=\"Enter your name\"\n            className=\"w-full px-4 py-2 bg-clocktower-dark border border-gray-600 rounded-lg focus:border-clocktower-accent focus:outline-none\"\n          />\n          <div className=\"text-left text-sm text-gray-400 sm:ml-2\">\n            {playerName.trim() ? 'Name saved' : 'Name is required to create or join a game'}\n          </div>\n        </div>\n      </div>\n\n      <div className=\"grid md:grid-cols-2 gap-8 mb-12\">\n        <div className=\"card p-8\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Create New Game</h2>\n          <p className=\"text-gray-300 mb-6\">\n            Start a new game of Blood on the Clocktower with AI-powered characters\n          </p>\n          <div className=\"space-y-4 text-left\">\n            <div>\n              <label className=\"block text-sm mb-2\">Game Name</label>\n              <div className=\"flex gap-2\">\n                <input\n                  value={gameName}\n                  onChange={(e) => setGameName(e.target.value)}\n                  type=\"text\"\n                  placeholder=\"e.g., Friday Night in Ravenswood\"\n                  className=\"flex-1 px-4 py-2 bg-clocktower-dark border border-gray-600 rounded-lg focus:border-clocktower-accent focus:outline-none\"\n                />\n                <button\n                  type=\"button\"\n                  onClick={() => setGameName(generateGameName())}\n                  className=\"px-3 py-2 bg-clocktower-dark border border-gray-600 rounded-lg hover:border-clocktower-accent transition-colors text-sm\"\n                  title=\"Generate random name\"\n                >\n                  🎲\n                </button>\n              </div>\n              <p className=\"text-xs text-gray-400 mt-1\">Shown in the lobby for everyone.</p>\n            </div>\n            <div>\n              <label className=\"block text-sm mb-2\">Game Privacy</label>\n              <div className=\"flex items-center space-x-4\">\n                <label className=\"flex items-center\">\n                  <input\n                    type=\"radio\"\n                    checked={isPublic}\n                    onChange={() => setIsPublic(true)}\n                    className=\"mr-2 text-clocktower-accent focus:ring-clocktower-accent\"\n                  />\n                  <span>Public - Anyone can find and join</span>\n                </label>\n                <label className=\"flex items-center\">\n                  <input\n                    type=\"radio\"\n                    checked={!isPublic}\n                    onChange={() => setIsPublic(false)}\n                    className=\"mr-2 text-clocktower-accent focus:ring-clocktower-accent\"\n                  />\n                  <span>Private - Join by invite only</span>\n                </label>\n              </div>\n              <p className=\"text-xs text-gray-400 mt-1\">\n                {isPublic \n                  ? \"Your game will appear in the public games list for others to join.\" \n                  : \"Only people with the game ID can join this game.\"}\n              </p>\n            </div>\n          </div>\n          <button \n            onClick={handleCreateGame}\n            disabled={!playerName.trim()}\n            className={`w-full py-3 text-lg btn-primary mt-4 ${!playerName.trim() ? 'opacity-50 cursor-not-allowed' : ''}`}\n          >\n            Create Game\n          </button>\n        </div>\n\n        <div className=\"card p-8\">\n          <h2 className=\"text-2xl font-semibold mb-4\">Join Existing Game</h2>\n          <p className=\"text-gray-300 mb-6\">\n            Enter a game ID to join an existing game\n          </p>\n          <div className=\"space-y-4\">\n            <input\n              value={joinId}\n              onChange={(e) => setJoinId(e.target.value)}\n              type=\"text\"\n              placeholder=\"Game ID\"\n              className=\"w-full px-4 py-2 bg-clocktower-dark border border-gray-600 rounded-lg focus:border-clocktower-accent focus:outline-none\"\n            />\n            <button\n              className={`btn-secondary w-full py-3 text-lg ${(!playerName.trim() || !joinId) ? 'opacity-50 cursor-not-allowed' : ''}`}\n              disabled={!playerName.trim() || !joinId}\n              onClick={handleJoin}\n            >\n              Join Game\n            </button>\n          </div>\n        </div>\n      </div>\n\n      {/* Public Games List */}\n      {authenticated && (\n        <div className=\"card p-8 mb-12\">\n          <div className=\"flex items-center justify-between mb-6\">\n            <h2 className=\"text-2xl font-semibold\">Join Public Games</h2>\n            <button\n              onClick={fetchPublicGames}\n              disabled={loadingGames}\n              className=\"btn-secondary px-4 py-2 text-sm\"\n            >\n              {loadingGames ? 'Refreshing...' : 'Refresh'}\n            </button>\n          </div>\n          <p className=\"text-gray-300 mb-6\">\n            Jump into any of these public games - no invitation needed!\n          </p>\n          \n          {loadingGames ? (\n            <div className=\"text-center py-8\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-clocktower-accent mx-auto mb-2\"></div>\n              <p className=\"text-gray-400\">Loading public games...</p>\n            </div>\n          ) : publicGames.length === 0 ? (\n            <div className=\"text-center py-8\">\n              <p className=\"text-gray-400\">No public games available right now.</p>\n              <p className=\"text-sm text-gray-500 mt-2\">Be the first to create one!</p>\n            </div>\n          ) : (\n            <div className=\"grid gap-4\">\n              {publicGames.map((game) => {\n                const playerCount = game.seats.filter(seat => seat.playerId && !seat.isNPC).length;\n                const maxPlayers = game.seats.length || 15; // Default max if no seats setup yet\n                \n                return (\n                  <div key={game.id} className=\"bg-clocktower-dark rounded-lg p-4 border border-gray-600\">\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex-1\">\n                        <h3 className=\"font-semibold text-lg\">\n                          {game.gameName || `Game ${game.id.substring(0, 8)}`}\n                        </h3>\n                        <div className=\"flex items-center space-x-4 text-sm text-gray-400 mt-1\">\n                          <span>Script: {game.scriptId.replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())}</span>\n                          <span>Players: {playerCount}/{maxPlayers}</span>\n                          <span>Phase: {game.phase}</span>\n                        </div>\n                        <p className=\"text-xs text-gray-500 mt-1\">\n                          Created: {new Date(game.createdAt).toLocaleDateString()} at {new Date(game.createdAt).toLocaleTimeString()}\n                        </p>\n                      </div>\n                      <div className=\"ml-4\">\n                        <button\n                          onClick={() => handleJoinPublicGame(game.id)}\n                          disabled={!playerName.trim()}\n                          className={`btn-primary px-6 py-2 ${!playerName.trim() ? 'opacity-50 cursor-not-allowed' : ''}`}\n                        >\n                          Join\n                        </button>\n                      </div>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          )}\n        </div>\n      )}\n\n      <div className=\"card p-8\">\n        <h2 className=\"text-2xl font-semibold mb-6\">Features</h2>\n        <div className=\"grid md:grid-cols-3 gap-6 text-left\">\n          <div>\n            <h3 className=\"text-lg font-semibold text-clocktower-accent mb-2\">🤖 AI Characters</h3>\n            <p className=\"text-gray-300\">\n              Intelligent NPCs that play with appropriate knowledge limitations\n            </p>\n          </div>\n          <div>\n            <h3 className=\"text-lg font-semibold text-clocktower-accent mb-2\">⚖️ Fair Play</h3>\n            <p className=\"text-gray-300\">\n              Built-in fairness scoring to help Storytellers balance games\n            </p>\n          </div>\n          <div>\n            <h3 className=\"text-lg font-semibold text-clocktower-accent mb-2\">🎮 Real-time</h3>\n            <p className=\"text-gray-300\">\n              Live gameplay with WebSocket communication and voice chat support\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default HomePage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/JoinPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 4,
        "column": 15,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect, useState } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\n\nconst JoinPage: React.FC = () => {\n  const { gameId } = useParams();\n  const navigate = useNavigate();\n  const [playerName, setPlayerName] = useState<string>(localStorage.getItem('botc-player-name') || '');\n  const [gameName, setGameName] = useState<string>('');\n\n  useEffect(() => {\n    if (!gameId) {\n      navigate('/');\n    }\n    // Fetch public game info to show name if available\n    const load = async () => {\n      try {\n        const res = await fetch(`/api/games/${gameId}`);\n        if (res.ok) {\n          const g = await res.json();\n          if ((g as any)?.gameName) setGameName((g as any).gameName);\n        }\n      } catch {}\n    };\n    load();\n  }, [gameId, navigate]);\n\n  const onContinue = () => {\n    const name = playerName.trim();\n    if (!name) return;\n    localStorage.setItem('botc-player-name', name);\n  // Don't clear existing seat; LobbyPage will reuse if present\n    navigate(`/lobby/${gameId}`);\n  };\n\n  return (\n    <div className=\"max-w-xl mx-auto\">\n      <h1 className=\"text-3xl font-semibold mb-2\">Join Game{gameName ? `: ${gameName}` : ''}</h1>\n      <div className=\"card p-6\">\n        {gameName ? (\n          <div className=\"text-sm text-gray-400 mb-4\">Game ID: <span className=\"font-mono\">{gameId}</span></div>\n        ) : (\n          <>\n            <div className=\"text-sm text-gray-400 mb-2\">Game</div>\n            <div className=\"font-mono text-sm mb-6\">{gameId}</div>\n          </>\n        )}\n\n        <label className=\"block text-sm text-gray-300 mb-2\" htmlFor=\"playerName\">Your Avatar Name</label>\n        <input\n          id=\"playerName\"\n          value={playerName}\n          onChange={(e) => setPlayerName(e.target.value)}\n          type=\"text\"\n          placeholder=\"Enter your name\"\n          className=\"w-full px-4 py-2 bg-clocktower-dark border border-gray-600 rounded-lg focus:border-clocktower-accent focus:outline-none\"\n        />\n        <button\n          onClick={onContinue}\n          disabled={!playerName.trim()}\n          className={`btn-primary mt-4 ${!playerName.trim() ? 'opacity-50 cursor-not-allowed' : ''}`}\n        >\n          Continue to Lobby\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default JoinPage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/LobbyPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 21,
        "column": 16,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect, useMemo, useState, useRef } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useGameStore } from '../store/gameStore';\nimport * as Enums from '@botc/shared';\nimport { PTTButton } from '../components/PTTButton';\nimport { usePTT } from '../utils/usePTT';\n\nimport { PlayersList } from '../components/lobby/PlayersList';\nimport { PlayerControls } from '../components/lobby/PlayerControls';\nimport { PreviewPanel } from '../components/lobby/PreviewPanel';\nimport { ModifiersPanel } from '../components/lobby/ModifiersPanel';\nimport { NightOrderPanel } from '../components/lobby/NightOrderPanel';\nimport { BottomBar } from '../components/lobby/BottomBar';\nimport ScriptCarousel from '../components/lobby/ScriptCarousel';\nimport CharacterGrid from '../components/lobby/CharacterGrid';\nimport ScriptVotingPanel from '../components/lobby/ScriptVotingPanel';\nimport { useGameConnection, useScriptSelection } from '../hooks/useGameState';\nimport { useScriptProposals } from '../hooks/useScriptProposals';\nimport { TEAM_RING_CLASSES, MODIFIER_RING_DECORATION } from '../constants/visual';\n\nconst LobbyPage: React.FC = () => {\n  const navigate = useNavigate();\n  const { connected, currentGame, leaveGame } = useGameStore();\n  const { gameId, loading, error, seatId, isStoryteller } = useGameConnection();\n  const {\n    selectedScriptId,\n    setSelectedScriptId,\n    selectedScript,\n    availableScripts,\n    storytellerSelectedScripts,\n    storytellerScriptObjects,\n    scriptUsedName,\n    toggleStorytellerScript,\n  } = useScriptSelection();\n  const {\n    scriptProposalsData,\n    proposalByScriptId,\n    togglePlayerProposal,\n    submitProposalVote,\n  } = useScriptProposals();\n  const playerCount = useMemo(() => {\n    if (!currentGame?.seats) return 0;\n    return currentGame.seats.filter((seat: any) => seat.id !== currentGame.storytellerSeatId).length;\n  }, [currentGame?.seats, currentGame?.storytellerSeatId]);\n  \n  const [hoverCharacter, setHoverCharacter] = useState<any | null>(null);\n  const [selectedCharacter, setSelectedCharacter] = useState<any | null>(null);\n  const topScriptButtonRefs = useRef<Record<string, HTMLButtonElement | null>>({});\n  \n  // PTT functionality\n  const { \n    pttState, \n    startPTT, \n    endPTT, \n    setMode\n  } = usePTT();\n  \n  // Team ring colors for character icons (centralized)\n  const teamRing = TEAM_RING_CLASSES;\n\n  // Build mapping of modifier types affecting characters for ring overlays\n  const modifierTypesByCharacterId = useMemo(() => {\n    const mapping: Record<string, string[]> = {};\n    (selectedScript?.modifiers || []).forEach((m: any) => {\n      switch (m.type) {\n        case 'requires':\n          if (m.whenCharacter) {\n            (mapping[m.whenCharacter] ||= []).push('requires');\n          }\n          (m.requireCharacters || []).forEach((cid: string) => {\n            (mapping[cid] ||= []).push('requires');\n          });\n          break;\n        case 'adjustCounts':\n          if (m.whenCharacter) {\n            (mapping[m.whenCharacter] ||= []).push('adjustCounts');\n          }\n          break;\n        case 'mutuallyExclusive':\n          (m.characters || []).forEach((cid: string) => {\n            (mapping[cid] ||= []).push('mutuallyExclusive');\n          });\n          break;\n        case 'atLeastOneOf':\n          (m.characters || []).forEach((cid: string) => {\n            (mapping[cid] ||= []).push('atLeastOneOf');\n          });\n          break;\n        case 'specialRule':\n          if (m.fabled) {\n            (mapping[m.fabled] ||= []).push('specialRule');\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    return mapping;\n  }, [selectedScript?.modifiers]);\n\n  // Resolve a local artwork path; fall back to placeholder if missing\n  const artworkSrc = useMemo(() => {\n    const id = selectedScript?.id;\n    if (!id) return '/script-art/placeholder.svg';\n    // Prefer .png or .jpg. We don't check existence here; the img onError will swap to placeholder.\n    return `/script-art/${id}.png`;\n  }, [selectedScript?.id]);\n\n  const centerScriptButton = (scriptId: string) => {\n    const btn = topScriptButtonRefs.current[scriptId];\n    btn?.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });\n  };\n\n  const handleTopScriptsKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;\n    if (!availableScripts.length) return;\n    event.preventDefault();\n    const direction = event.key === 'ArrowLeft' ? -1 : 1;\n    const currentIndex = (() => {\n      if (selectedScriptId) {\n        const idx = availableScripts.findIndex((s: any) => s.id === selectedScriptId);\n        if (idx >= 0) return idx;\n      }\n      if (currentGame?.scriptId) {\n        const idx = availableScripts.findIndex((s: any) => s.id === currentGame.scriptId);\n        if (idx >= 0) return idx;\n      }\n      return 0;\n    })();\n    const nextIndex = (currentIndex + direction + availableScripts.length) % availableScripts.length;\n    const nextScript = availableScripts[nextIndex];\n    setSelectedScriptId(nextScript.id);\n    centerScriptButton(nextScript.id);\n  };\n\n  useEffect(() => {\n    if (selectedScript?.id) {\n      centerScriptButton(selectedScript.id);\n    }\n  }, [selectedScript?.id]);\n\n  const minPlayersRequired = useMemo(() => selectedScript?.meta?.playerCount?.min ?? 5, [selectedScript]);\n  const hasEnoughPlayers = playerCount >= minPlayersRequired;\n\n  // Redirect to setup page if game is in setup phase and user is storyteller\n  useEffect(() => {\n  if (currentGame?.phase === Enums.GamePhase.SETUP && isStoryteller) {\n      navigate(`/setup/${gameId}`);\n    }\n  }, [currentGame?.phase, isStoryteller, gameId, navigate]);\n\n  const handleSetup = () => {\n    if (gameId) {\n      navigate(`/setup/${gameId}`);\n    }\n  };\n\n  const handleStart = async () => {\n    if (!gameId) return;\n    const res = await fetch(`/api/games/${gameId}/start`, { method: 'POST' });\n    if (!res.ok) {\n      console.error('Failed to start game');\n      return;\n    }\n  // Show personal role reveal screen first\n  navigate(`/reveal/${gameId}`);\n  };\n\n  if (loading) {\n    return (\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-4xl font-medieval font-bold text-center mb-8\">Game Lobby</h1>\n        <div className=\"card p-8 text-center\">Loading...</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-4xl font-medieval font-bold text-center mb-8\">Game Lobby</h1>\n        <div className=\"card p-8 text-center text-red-400\">{error}</div>\n      </div>\n    );\n  }\n\n  // Wireframe-inspired layout updated to match design\n  return (\n    <div className=\"max-w-[1400px] mx-auto\">\n      <h1 className=\"text-4xl font-medieval font-bold text-center mb-2\">Game Lobby{(currentGame as any)?.gameName ? `: ${(currentGame as any).gameName}` : ''}</h1>\n      \n      {isStoryteller && currentGame?.phase === Enums.GamePhase.LOBBY && (\n        <div className=\"flex items-center justify-center gap-2 mb-4\">\n          <input\n            defaultValue={(currentGame as any)?.gameName || ''}\n            placeholder=\"Set game name (visible to all)\"\n            onBlur={async (e) => {\n              const name = e.currentTarget.value.trim();\n              if (!gameId || !seatId || !name) return;\n              await fetch(`/api/games/${gameId}/name`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ storytellerSeatId: seatId, name }) });\n            }}\n            className=\"px-3 py-1 bg-clocktower-dark border border-gray-600 rounded focus:outline-none focus:border-clocktower-accent w-[360px]\"\n          />\n          <span className=\"text-xs text-gray-500\">Press Tab/Click away to save</span>\n        </div>\n      )}\n\n      {/* Storyteller-only: All scripts selector - with keyboard navigation */}\n      {isStoryteller && (\n        <div className=\"pt-6 pb-2\">\n          <ScriptCarousel\n            scripts={availableScripts}\n            selectedScriptId={selectedScript?.id}\n            title=\"All Scripts (Storyteller Only)\"\n            subtitle=\"Use ← → to navigate\"\n            keyboardNavigation={true}\n            onScriptSelect={setSelectedScriptId}\n            onScriptAction={toggleStorytellerScript}\n            getActionProps={(script) => ({\n              label: storytellerSelectedScripts.includes(script.id) \n                ? 'Remove script from storyteller proposals' \n                : 'Add script for players',\n              isActive: storytellerSelectedScripts.includes(script.id),\n              'data-testid': `master-toggle-${script.id}`\n            })}\n            testId=\"all-scripts-carousel\"\n            onKeyDown={handleTopScriptsKeyDown}\n          />\n        </div>\n      )}\n\n      {/* Player-only: Game selector spanning full width */}\n      {!isStoryteller && (\n        <div className=\"pt-6 pb-2\">\n          <ScriptCarousel\n            scripts={storytellerScriptObjects}\n            selectedScriptId={selectedScript?.id}\n            title=\"Available Games\"\n            subtitle=\"Use ← → to navigate\"\n            onScriptSelect={setSelectedScriptId}\n            onScriptAction={togglePlayerProposal}\n            getActionProps={(script) => {\n              const proposalEntry = proposalByScriptId.get(script.id);\n              const iPropose = proposalEntry ? proposalEntry.isProposer : false;\n              return {\n                label: iPropose ? 'Withdraw script proposal' : 'Propose this script',\n                isActive: iPropose,\n                'data-testid': `player-proposal-toggle-${script.id}`\n              };\n            }}\n            testId=\"player-games-carousel\"\n          />\n        </div>\n      )}\n\n      {/* Storyteller Shared Scripts - full width */}\n      {storytellerScriptObjects.length > 0 && (\n        <div className=\"pt-6 pb-2\">\n          <ScriptCarousel\n            scripts={storytellerScriptObjects}\n            selectedScriptId={selectedScript?.id}\n            title=\"Storyteller Shared Scripts\"\n            subtitle=\"Press + to propose this script to the group.\"\n            onScriptSelect={setSelectedScriptId}\n            onScriptAction={togglePlayerProposal}\n            getActionProps={(script) => {\n              const proposalEntry = proposalByScriptId.get(script.id);\n              const iPropose = proposalEntry ? proposalEntry.isProposer : false;\n              return {\n                label: iPropose ? 'Withdraw script proposal' : 'Propose this script',\n                isActive: iPropose,\n                'data-testid': `player-proposal-toggle-${script.id}`\n              };\n            }}\n            testId=\"shared-scripts-carousel\"\n          />\n        </div>\n      )}\n\n      <div className=\"grid grid-cols-12 gap-4\">\n        {/* Left Column: Players and Management */}\n        <div className=\"col-span-2 flex flex-col min-h-[500px]\">\n          {/* Storyteller section */}\n          {currentGame?.storytellerSeatId ? (\n            <div className=\"card p-3 mb-3 border-yellow-600/50\">\n              <div className=\"text-xs text-yellow-400 mb-2 flex items-center gap-1\">\n                <span>👑</span>\n                <span>Storyteller</span>\n              </div>\n              {(() => {\n                const storytellerSeat = currentGame.seats.find((s: any) => s.id === currentGame.storytellerSeatId);\n                return (\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"font-mono text-sm truncate text-yellow-100\">{storytellerSeat?.playerId || 'Unknown'}</div>\n                    <span className=\"text-lg\">👑</span>\n                  </div>\n                );\n              })()}\n            </div>\n          ) : (\n            <div className=\"card p-3 mb-3 border-gray-600/50\">\n              <div className=\"text-xs text-gray-400 mb-2\">Storyteller</div>\n              <div className=\"text-sm text-gray-500 italic\">No storyteller assigned yet</div>\n            </div>\n          )}\n\n          {/* Players list - simple scrollable list */}\n              <PlayersList\n                players={currentGame?.seats?.filter((s: any) => s.id !== currentGame.storytellerSeatId) || []}\n                isStoryteller={isStoryteller}\n                storytellerSeatId={currentGame?.storytellerSeatId}\n                seatId={seatId ?? undefined}\n                onMakeStoryteller={async (targetSeatId: string) => {\n                  await fetch(`/api/games/${gameId}/storyteller`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ setterSeatId: seatId ?? '', targetSeatId })\n                  });\n                }}\n              />\n\n          {/* Player Management Buttons */}\n            <PlayerControls\n              onAddNPC={async () => { if (gameId) await fetch(`/api/games/${gameId}/npc`, { method: 'POST' }); }}\n              onCopyLink={() => {\n                if (!gameId) return;\n                const origin = window.location.origin;\n                const joinUrl = `${origin}/join/${gameId}`;\n                navigator.clipboard.writeText(joinUrl);\n              }}\n              onLeaveGame={async () => {\n                const ok = await leaveGame();\n                if (ok) navigate('/');\n              }}\n              canLeave={currentGame?.phase === Enums.GamePhase.LOBBY}\n            />\n\n          {/* Push to Talk */}\n          <div className=\"mt-3 p-3 card\">\n            <div className=\"text-xs text-gray-400 mb-2\">Voice Chat</div>\n            <div className=\"flex items-center justify-center\">\n              <PTTButton\n                pttState={pttState}\n                onToggleMode={(mode) => setMode(mode)}\n                onStart={startPTT}\n                onEnd={endPTT}\n                className=\"w-full\"\n              />\n            </div>\n            <div className=\"text-xs text-gray-500 text-center mt-1\">\n              {pttState.mode === 'hold' ? 'Hold to talk' : 'Click to toggle'}\n            </div>\n          </div>\n        </div>\n\n        {/* Center Column: Scripts (narrower to give more space to preview) */}\n        <div className={`${isStoryteller ? 'col-span-5' : 'col-span-5'} flex flex-col min-h-[500px]`}>\n          {/* Characters grid for selected script */}\n          <CharacterGrid\n            characters={selectedScript?.characters}\n            onCharacterHover={setHoverCharacter}\n            onCharacterSelect={(c) => setSelectedCharacter(c)}\n            selectedCharacterId={selectedCharacter?.id}\n            teamRing={teamRing}\n            modifierTypesByCharacterId={modifierTypesByCharacterId}\n          />\n          {/* Player Voting now sits below the characters */}\n          <div className=\"mt-4 flex-1\">\n            <ScriptVotingPanel\n              scriptProposalsData={scriptProposalsData}\n              onScriptSelect={setSelectedScriptId}\n              onVote={submitProposalVote}\n            />\n          </div>\n        </div>\n\n        {/* Right Column: Preview */}\n          <div className={`${isStoryteller ? 'col-span-5' : 'col-span-5'} flex flex-col min-h-[500px]`}>\n            <PreviewPanel\n              hoverCharacter={hoverCharacter}\n              selectedCharacter={selectedCharacter}\n              artworkSrc={artworkSrc}\n              selectedScript={selectedScript}\n            />\n            {/* Stacked modifiers then generic night order full width */}\n            <div className=\"mt-3\">\n              <ModifiersPanel modifiers={selectedScript?.modifiers || []} />\n              <NightOrderPanel />\n            </div>\n          </div>\n      </div>\n      \n\n      {/* Phase Information */}\n      {currentGame?.phase === Enums.GamePhase.SETUP && (\n        <div className=\"bg-blue-900/30 border border-blue-700 rounded-lg p-4 mt-4\">\n          <h3 className=\"text-lg font-semibold text-blue-300 mb-2\">Setup in Progress</h3>\n          <p className=\"text-gray-300 text-sm\">\n            {isStoryteller\n              ? \"You are configuring the game setup. Click 'Continue Setup' to manage character selection.\"\n              : 'The Storyteller is setting up the game. Please wait...'}\n          </p>\n        </div>\n      )}\n\n      {/* Bottom Component: Game Controls and Character Count */}\n        <BottomBar>\n          <div className=\"flex items-center gap-6\">\n            <div className=\"text-sm text-gray-300\">\n              <span className=\"font-semibold\">Players:</span> {playerCount}\n              {selectedScript?.meta?.playerCount && (\n                <span className=\"text-gray-400 ml-1\">\n                  (min {minPlayersRequired})\n                </span>\n              )}\n            </div>\n            <div className=\"text-sm text-gray-300\">\n              <span className=\"font-semibold\">Storyteller:</span> 1\n            </div>\n            <div className=\"text-sm text-gray-300\" data-testid=\"bottom-bar-script\">\n              <span className=\"font-semibold\">Script:</span> {scriptUsedName ?? 'Not selected'}\n            </div>\n          </div>\n\n          <div className=\"flex gap-3\">\n            {isStoryteller && currentGame?.phase === Enums.GamePhase.LOBBY && (\n              <button\n                className=\"btn-primary px-8 py-3 text-lg font-semibold\"\n                onClick={handleSetup}\n                disabled={!connected || !hasEnoughPlayers}\n              >\n                Begin Game Setup{scriptUsedName ? ` • ${scriptUsedName}` : ''}\n              </button>\n            )}\n            {isStoryteller && currentGame?.phase === Enums.GamePhase.SETUP && (\n              <button className=\"btn-primary px-8 py-3 text-lg font-semibold\" onClick={handleSetup}>Continue Setup</button>\n            )}\n            {currentGame?.phase === Enums.GamePhase.NIGHT && (\n              <button className=\"btn-primary px-8 py-3 text-lg font-semibold\" onClick={handleStart}>View Game</button>\n            )}\n          </div>\n        </BottomBar>\n\n      {/* Storyteller readiness hint */}\n      {isStoryteller && currentGame?.phase === Enums.GamePhase.LOBBY && (\n        <div className=\"text-sm text-gray-300 mt-2 text-center\">\n          {connected ? (\n            hasEnoughPlayers ? (\n              <span>\n                Ready to begin{scriptUsedName ? ` with ${scriptUsedName}` : ''}. Players: {playerCount}\n                {selectedScript?.meta?.playerCount ? ` (min ${minPlayersRequired})` : ''}. Storyteller: 1.\n              </span>\n            ) : (\n              <span>Need {minPlayersRequired - playerCount} more player{minPlayersRequired - playerCount === 1 ? '' : 's'} to begin setup{selectedScript?.meta?.playerCount ? ` for ${selectedScript?.name}` : ''}. Current: {playerCount} players, 1 storyteller.</span>\n            )\n          ) : (\n            <span>Connecting…</span>\n          )}\n        </div>\n      )}\n\n      {/* Visual Legend */}\n      <div className=\"mt-6 card p-4\">\n        <div className=\"text-sm font-semibold text-gray-200 mb-3 text-center\">Visual Guide</div>\n        \n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n          {/* Character Team Colors (loop over constants) */}\n          <div>\n            <div className=\"text-xs font-medium text-gray-300 mb-2 uppercase tracking-wide\">Character Teams</div>\n            <div className=\"grid grid-cols-2 gap-2 text-xs\">\n              {Object.entries(teamRing).map(([team, ringClass]) => (\n                <div key={team} className=\"flex items-center gap-2 capitalize\">\n                  <div className={`w-5 h-5 rounded-full bg-black/40 border border-gray-700 ring-2 ${ringClass}`}></div>\n                  <span className=\"text-gray-200\">{team}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          {/* Script Modifier Rings */}\n          <div>\n            <div className=\"text-xs font-medium text-gray-300 mb-2 uppercase tracking-wide\">Script Modifier Rings</div>\n            <div className=\"space-y-2 text-xs\">\n              {Object.entries(MODIFIER_RING_DECORATION).map(([type, cls]) => {\n                const description: Record<string,string> = {\n                  requires: 'Requires - needs another character',\n                  adjustCounts: 'Adjust Counts - changes team numbers',\n                  mutuallyExclusive: \"Exclusive - can't appear together\",\n                  atLeastOneOf: 'Min One - at least one required',\n                  specialRule: 'Fabled / Special storyteller rule',\n                };\n                return (\n                  <div key={type} className=\"flex items-center gap-2\">\n                    <div className=\"relative w-5 h-5\">\n                      <div className={`w-5 h-5 rounded-full bg-black/40 border border-gray-700 ring-1 ring-gray-600 ${cls}`}></div>\n                    </div>\n                    <span className=\"text-gray-200 capitalize\">{description[type] || type}</span>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LobbyPage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/RoleRevealPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 5,
        "column": 21,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect, useMemo, useState } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { useGameStore } from '../store/gameStore';\n\nconst RoleRevealPage: React.FC = () => {\n  const { gameId } = useParams();\n  const navigate = useNavigate();\n  const { currentGame, seatId, isStoryteller, connect, setCurrentGame } = useGameStore() as any;\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    let cancelled = false;\n    (async () => {\n      if (!gameId) return;\n      try {\n        // Ensure WS subscription for live updates\n  connect(gameId as any, seatId || (typeof localStorage !== 'undefined' ? localStorage.getItem('botc-seat-id') : undefined) || undefined);\n        // Fetch latest snapshot to avoid race conditions right after start\n        const res = await fetch(`/api/games/${gameId}`);\n        if (!res.ok) throw new Error('Failed to load game');\n        const data = await res.json();\n        if (!cancelled) setCurrentGame(data);\n      } catch (e: any) {\n        if (!cancelled) setError(e.message || 'Failed to load role');\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    })();\n    return () => { cancelled = true; };\n  }, [gameId]);\n\n  const mySeat = useMemo(() => {\n    if (!currentGame || !seatId) return undefined;\n    return currentGame.seats.find((s: any) => s.id === seatId);\n  }, [currentGame, seatId]);\n\n  const getRoleDisplayName = (role: string | undefined) => {\n    if (!role) return 'Unknown';\n    return role\n      .split('-')\n      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n  };\n\n  const getAlignmentColor = (alignment: string | undefined) => {\n    switch (alignment) {\n      case 'good':\n        return 'text-blue-400';\n      case 'evil':\n        return 'text-red-400';\n      default:\n        return 'text-gray-400';\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className=\"max-w-3xl mx-auto\">\n        <div className=\"card p-8 text-center\">Preparing your role...</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"max-w-3xl mx-auto\">\n        <div className=\"card p-8 text-center text-red-400\">{error}</div>\n      </div>\n    );\n  }\n\n  // Storyteller sees a grimoire link instead of a specific role\n  if (isStoryteller) {\n    return (\n      <div className=\"max-w-3xl mx-auto text-center\">\n        <h1 className=\"text-4xl font-medieval font-bold mb-6\">Storyteller Ready</h1>\n        <div className=\"card p-8\">\n          <p className=\"text-gray-300 mb-6\">\n            The game has started. Proceed to the table to view the grimoire and manage phases.\n          </p>\n          <button className=\"btn-primary px-6 py-3\" onClick={() => navigate(`/game/${gameId}`)}>\n            Enter Game Table\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  const canReveal = !!mySeat?.role;\n\n  return (\n    <div className=\"max-w-3xl mx-auto text-center\">\n      <h1 className=\"text-4xl font-medieval font-bold mb-6\">Your Role</h1>\n      <div className=\"card p-10\">\n        {!canReveal ? (\n          <div className=\"text-gray-300\">Waiting for the Storyteller to assign roles...</div>\n        ) : (\n          <div className=\"space-y-4\">\n            <div className={`text-sm uppercase ${getAlignmentColor(mySeat?.alignment)}`}>Alignment</div>\n            <div className={`text-2xl font-semibold ${getAlignmentColor(mySeat?.alignment)}`}>\n              {mySeat?.alignment?.toUpperCase()}\n            </div>\n            <div className=\"text-sm uppercase text-gray-400 mt-6\">Role</div>\n            <div className=\"text-3xl font-bold\">{getRoleDisplayName(mySeat?.role)}</div>\n            <div className=\"text-gray-400 text-sm\">Keep your role secret unless you choose to reveal it.</div>\n            <div className=\"pt-6\">\n              <button className=\"btn-primary px-6 py-3\" onClick={() => navigate(`/game/${gameId}`)}>\n                Enter Game Table\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default RoleRevealPage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/pages/SetupPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 15,
        "column": 16,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// New Setup Page (GameSetupPage) reusing Lobby components & new panels\nimport React, { useEffect, useMemo, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { useGameStore } from '../store/gameStore';\nimport * as Enums from '@botc/shared';\nimport CharacterGrid from '../components/lobby/CharacterGrid';\nimport { PreviewPanel } from '../components/lobby/PreviewPanel';\nimport { ModifiersPanel } from '../components/lobby/ModifiersPanel';\nimport { GameSetupInfoPanel } from '../components/setup/GameSetupInfoPanel';\nimport { DetailedNightOrderPanel } from '../components/setup/DetailedNightOrderPanel';\nimport { GameStatisticsPanel } from '../components/setup/GameStatisticsPanel';\nimport { TEAM_RING_CLASSES, MODIFIER_RING_DECORATION } from '../constants/visual';\nimport ScriptCarousel from '../components/lobby/ScriptCarousel';\n\nconst SetupPage: React.FC = () => {\n  const { gameId } = useParams();\n  const navigate = useNavigate();\n  const { currentGame, isStoryteller, enterSetup, availableScripts, loadScripts, setCurrentScript, currentScript } = useGameStore();\n  const [selectedScript, setSelectedScript] = useState<any | null>(null);\n  const [hoverCharacter, setHoverCharacter] = useState<any | null>(null);\n  const [selectedCharacterIds, setSelectedCharacterIds] = useState<string[]>([]); // storyteller selection\n\n  // TEMP: derive script from currentGame if already loaded (future hook reuse could replace this)\n  useEffect(() => {\n    // Ensure scripts loaded for selection if storyteller\n    if (isStoryteller && (!availableScripts || availableScripts.length === 0)) {\n      loadScripts();\n    }\n  }, [isStoryteller, availableScripts, loadScripts]);\n\n  useEffect(() => {\n    // Derive current script if already chosen earlier\n    const scriptObj = currentScript || (currentGame as any)?.scriptObject || (currentGame as any)?.script;\n    if (scriptObj) setSelectedScript(scriptObj);\n  }, [currentGame, currentScript]);\n\n  // Redirect logic & automatic entry into setup\n  const isPlayer = !isStoryteller;\n  const hasEnteredRef = React.useRef(false);\n  useEffect(() => {\n    if (!gameId || !currentGame) return;\n    if (isStoryteller) {\n      if (currentGame.phase === Enums.GamePhase.LOBBY && !hasEnteredRef.current) {\n        // Attempt to enter setup; phase will change async\n        hasEnteredRef.current = true;\n        enterSetup();\n      } else if (currentGame.phase === Enums.GamePhase.SETUP) {\n        // Stay on page\n      } else if (hasEnteredRef.current) {\n        // After attempting entry: handle transitions away from SETUP\n        if (currentGame.phase === Enums.GamePhase.LOBBY) {\n          navigate(`/lobby/${gameId}`);\n        } else if (currentGame.phase === Enums.GamePhase.NIGHT || currentGame.phase === Enums.GamePhase.DAY) {\n          navigate(`/game/${gameId}`);\n        }\n      }\n    }\n  }, [currentGame?.phase, isStoryteller, gameId, enterSetup, navigate, currentGame]);\n\n  const playerCount = useMemo(() => {\n    return currentGame?.seats?.filter((s: any) => s.id !== (currentGame as any).storytellerSeatId).length || 0;\n  }, [currentGame]);\n\n  const rosterCharacters = useMemo(() => selectedScript?.characters || [], [selectedScript]);\n\n  const teamRing = TEAM_RING_CLASSES;\n  const modifierTypesByCharacterId = useMemo(() => {\n    const mapping: Record<string, string[]> = {};\n    (selectedScript?.modifiers || []).forEach((m: any) => {\n      switch (m.type) {\n        case 'requires':\n          if (m.whenCharacter) (mapping[m.whenCharacter] ||= []).push('requires');\n          (m.requireCharacters || []).forEach((cid: string) => (mapping[cid] ||= []).push('requires'));\n          break;\n        case 'adjustCounts':\n          if (m.whenCharacter) (mapping[m.whenCharacter] ||= []).push('adjustCounts');\n          break;\n        case 'mutuallyExclusive':\n          (m.characters || []).forEach((cid: string) => (mapping[cid] ||= []).push('mutuallyExclusive'));\n          break;\n        case 'atLeastOneOf':\n          (m.characters || []).forEach((cid: string) => (mapping[cid] ||= []).push('atLeastOneOf'));\n          break;\n        case 'specialRule':\n          if (m.fabled) (mapping[m.fabled] ||= []).push('specialRule');\n          break;\n      }\n    });\n    return mapping;\n  }, [selectedScript?.modifiers]);\n\n  const artworkSrc = useMemo(() => {\n    const id = selectedScript?.id;\n    if (!id) return '/script-art/placeholder.svg';\n    return `/script-art/${id}.png`;\n  }, [selectedScript?.id]);\n\n  const toggleCharacter = (c: any) => {\n    if (!isStoryteller) return;\n    setSelectedCharacterIds(prev => prev.includes(c.id) ? prev.filter(id => id !== c.id) : [...prev, c.id]);\n  };\n\n  const handleSelectScript = (scriptId: string) => {\n    const script = availableScripts.find((s: any) => s.id === scriptId);\n    if (script) {\n      setSelectedScript(script);\n      setCurrentScript(script);\n      // reset selections when changing scripts\n      setSelectedCharacterIds([]);\n    }\n  };\n\n  // Player waiting view\n  if (isPlayer) {\n    return (\n      <div className=\"max-w-5xl mx-auto\">\n        <h1 className=\"text-3xl font-medieval font-bold text-center my-6\">Game Setup In Progress</h1>\n        <div className=\"grid grid-cols-12 gap-4\">\n          <div className=\"col-span-6\">\n            <PreviewPanel artworkSrc={artworkSrc} selectedScript={selectedScript} />\n            <DetailedNightOrderPanel selectedScript={selectedScript} />\n          </div>\n          <div className=\"col-span-6 flex flex-col\">\n            <GameSetupInfoPanel playerCount={playerCount} selectedScript={selectedScript} selectedCharacterIds={selectedCharacterIds} />\n            <ModifiersPanel modifiers={selectedScript?.modifiers || []} />\n            <GameStatisticsPanel selectedScript={selectedScript} playerCount={playerCount} selectedCharacterIds={selectedCharacterIds} />\n          </div>\n        </div>\n        <div className=\"mt-6 card p-4 text-center text-sm text-gray-300\">\n          Waiting for the storyteller to complete setup. You will see your role soon.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-[1500px] mx-auto\">\n      <h1 className=\"text-4xl font-medieval font-bold text-center mb-4\">Game Setup</h1>\n\n      {/* Script selection (Storyteller only) */}\n      {isStoryteller && (\n        <div className=\"mb-4\">\n          <ScriptCarousel\n            scripts={availableScripts || []}\n            selectedScriptId={selectedScript?.id}\n            title=\"Select Script\"\n            subtitle={availableScripts?.length ? 'Choose a script to begin selecting characters' : 'Loading scripts...'}\n            onScriptSelect={handleSelectScript}\n            keyboardNavigation\n            testId=\"setup-scripts-carousel\"\n          />\n        </div>\n      )}\n\n      <div className=\"grid grid-cols-12 gap-4\">\n        {/* Left: Characters */}\n        <div className=\"col-span-5 flex flex-col min-h-[600px]\">\n          <CharacterGrid\n            characters={rosterCharacters}\n            onCharacterHover={setHoverCharacter}\n            onCharacterSelect={toggleCharacter}\n            selectedCharacterId={hoverCharacter?.id}\n            teamRing={teamRing}\n            modifierTypesByCharacterId={modifierTypesByCharacterId}\n          />\n          <div className=\"text-xs text-gray-400 mt-2\">\n            {selectedScript ? 'Click characters to include them. Distribution auto-updates above.' : 'Select a script first to load characters.'}\n          </div>\n        </div>\n        {/* Center: Preview & Setup Info stacked */}\n        <div className=\"col-span-4 flex flex-col\">\n          <GameSetupInfoPanel playerCount={playerCount} selectedScript={selectedScript} selectedCharacterIds={selectedCharacterIds} />\n          <PreviewPanel\n            artworkSrc={artworkSrc}\n            hoverCharacter={hoverCharacter}\n            selectedCharacter={rosterCharacters.find((c: any) => c.id === selectedCharacterIds[selectedCharacterIds.length-1])}\n            selectedScript={selectedScript}\n          />\n          <ModifiersPanel modifiers={selectedScript?.modifiers || []} />\n        </div>\n        {/* Right: Detailed Info */}\n        <div className=\"col-span-3 flex flex-col\">\n          <GameStatisticsPanel selectedScript={selectedScript} playerCount={playerCount} selectedCharacterIds={selectedCharacterIds} />\n          <DetailedNightOrderPanel selectedScript={selectedScript} />\n        </div>\n      </div>\n      <div className=\"mt-6 flex justify-center\">\n        <button\n          onClick={() => gameId && navigate(`/lobby/${gameId}`)}\n          className=\"btn-secondary px-6 py-3 mr-4\"\n        >Return to Lobby</button>\n        <button\n          onClick={() => gameId && navigate(`/game/${gameId}`)}\n          className=\"btn-primary px-8 py-3 text-lg font-semibold\"\n          disabled={selectedCharacterIds.length !== playerCount}\n          title={selectedCharacterIds.length !== playerCount ? `Need ${playerCount - selectedCharacterIds.length} more` : undefined}\n        >Complete Setup</button>\n      </div>\n      <div className=\"mt-8 card p-4\">\n        <div className=\"text-sm font-semibold text-gray-200 mb-2\">Legend</div>\n        <div className=\"grid grid-cols-2 gap-4 text-xs\">\n          <div>\n            <div className=\"uppercase tracking-wide text-[10px] text-gray-400 mb-1\">Teams</div>\n            {Object.entries(teamRing).map(([team, cls]) => (\n              <div key={team} className=\"flex items-center gap-2 mb-1\">\n                <div className={`w-4 h-4 rounded-full ring-2 ${cls} bg-black/40 border border-gray-700`}></div>\n                <span className=\"text-gray-300 capitalize\">{team}</span>\n              </div>\n            ))}\n          </div>\n          <div>\n            <div className=\"uppercase tracking-wide text-[10px] text-gray-400 mb-1\">Modifiers</div>\n            {Object.entries(MODIFIER_RING_DECORATION).map(([type, cls]) => (\n              <div key={type} className=\"flex items-center gap-2 mb-1\">\n                <div className={`w-4 h-4 rounded-full ring-2 ${cls} bg-black/40 border border-gray-700`}></div>\n                <span className=\"text-gray-300 capitalize\">{type}</span>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SetupPage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/store/gameStore.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 6,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { create } from 'zustand';\nimport { GameState, GameId, WSMessage, LoadedScript } from '@botc/shared';\nimport * as Enums from '@botc/shared';\nimport { SetupApi } from '../api/setupApi';\n\ninterface GameStore {\n  // Connection state\n  connected: boolean;\n  connecting: boolean;\n  ws: WebSocket | null;\n  \n  // Game state\n  currentGame: GameState | null;\n  gameId: GameId | null;\n  seatId: string | null;\n  isStoryteller: boolean;\n  \n  // Setup state\n  setupState: any | null;\n  grimoireState: any | null;\n  currentSetupStep: 'characters' | 'validation' | 'complete';\n  setupLoading: boolean;\n  setupError: string | null;\n  \n  // Script state\n  availableScripts: LoadedScript[];\n  currentScript: LoadedScript | null;\n  scriptsLoading: boolean;\n  \n  // Actions\n  connect: (gameId: GameId, viewerSeatId?: string | null) => void;\n  disconnect: () => void;\n  sendMessage: (message: WSMessage) => void;\n  setCurrentGame: (game: GameState) => void;\n  setSeat: (seatId: string, isStoryteller?: boolean) => void;\n  leaveGame: () => Promise<boolean>;\n  \n  // Setup actions\n  enterSetup: () => Promise<boolean>;\n  selectCharacters: (characterIds: string[]) => Promise<boolean>;\n  validateSetup: () => Promise<boolean>;\n  // Silent background validation used by the UI to keep the start button state up to date\n  autoValidate: () => Promise<void>;\n  completeSetup: () => Promise<boolean>;\n  loadSetupState: () => Promise<void>;\n  setSetupError: (error: string | null) => void;\n  setSetupStep: (step: 'characters' | 'validation' | 'complete') => void;\n  \n  // Script actions\n  loadScripts: () => Promise<void>;\n  loadScript: (scriptId: string) => Promise<LoadedScript | null>;\n  setCurrentScript: (script: LoadedScript) => void;\n}\n\nexport const useGameStore = create<GameStore>((set, get) => ({\n  // Initial state\n  connected: false,\n  connecting: false,\n  ws: null,\n  currentGame: null,\n  gameId: null,\n  seatId: (() => {\n    try { return localStorage.getItem('botc-seat-id'); } catch { return null; }\n  })(),\n  isStoryteller: (() => {\n    try { const v = localStorage.getItem('botc-is-storyteller'); return v ? JSON.parse(v) : false; } catch { return false; }\n  })(),\n  \n  // Setup state\n  setupState: null,\n  grimoireState: null,\n  currentSetupStep: 'characters',\n  setupLoading: false,\n  setupError: null,\n\n  // Script state\n  availableScripts: [],\n  currentScript: null,\n  scriptsLoading: false,\n\n  // Actions\n  connect: (gameId: GameId, viewerSeatId?: string | null) => {\n    const { ws } = get();\n    \n    if (ws && ws.readyState === WebSocket.OPEN) {\n      ws.close();\n    }\n\n    set({ connecting: true, gameId });\n\n  const wsUrl = `${(location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host  }/ws`;\n  const websocket = new WebSocket(wsUrl);\n    \n  websocket.onopen = () => {\n      set({ connected: true, connecting: false, ws: websocket });\n      \n      // Subscribe to game updates\n      const viewer = viewerSeatId || get().seatId || undefined;\n      websocket.send(JSON.stringify({\n        type: 'subscribe',\n    gameId,\n    viewerSeatId: viewer || undefined\n      }));\n    };\n\n    websocket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data) as WSMessage;\n        \n        if (message.type === 'event') {\n          // If server sent a full game state snapshot, prefer it\n          const snapshot = (message.event.payload as any)?.gameState as GameState | undefined;\n          if (snapshot) {\n            const seatId = get().seatId;\n            set({ currentGame: snapshot, isStoryteller: !!seatId && snapshot.storytellerSeatId === seatId });\n            return;\n          }\n\n          // Otherwise, apply minimal event-specific updates if needed\n          switch (message.event.type) {\n            case 'player_joined':\n            case 'phase_changed':\n            case 'game_created':\n              // These are expected to come with snapshots; ignore otherwise for now\n              break;\n            case 'storyteller_changed': {\n              const payload = message.event.payload as { storytellerSeatId?: string };\n              set((state) => {\n                if (!state.currentGame) return state;\n                const updated = { ...state.currentGame, storytellerSeatId: payload.storytellerSeatId } as GameState;\n                const seatId = state.seatId;\n                return {\n                  currentGame: updated,\n                  isStoryteller: !!seatId && payload.storytellerSeatId === seatId\n                };\n              });\n              break;\n            }\n            default:\n              break;\n          }\n        }\n      } catch (error) {\n        console.error('Failed to parse WebSocket message:', error);\n      }\n    };\n\n    websocket.onclose = () => {\n      set({ connected: false, connecting: false, ws: null });\n    };\n\n    websocket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      set({ connected: false, connecting: false, ws: null });\n    };\n  },\n\n  disconnect: () => {\n    const { ws } = get();\n    if (ws) {\n      ws.close();\n    }\n    set({ \n      connected: false, \n      connecting: false, \n      ws: null, \n      currentGame: null, \n  gameId: null,\n  setupState: null,\n      grimoireState: null,\n      setupError: null\n    });\n  },\n\n  sendMessage: (message: WSMessage) => {\n    const { ws, connected } = get();\n    if (ws && connected) {\n      ws.send(JSON.stringify(message));\n    }\n  },\n\n  setCurrentGame: (game: GameState) => {\n    const seatId = get().seatId;\n    set({ currentGame: game, isStoryteller: !!seatId && game.storytellerSeatId === seatId });\n  },\n  \n  setSeat: (seatId: string, isStoryteller?: boolean) => {\n    try {\n      if (seatId) localStorage.setItem('botc-seat-id', seatId);\n      if (typeof isStoryteller === 'boolean') localStorage.setItem('botc-is-storyteller', JSON.stringify(!!isStoryteller));\n    } catch {}\n    set({ seatId, isStoryteller: !!isStoryteller });\n  },\n\n  // Leave the current game (lobby only). Clears local identity.\n  leaveGame: async (): Promise<boolean> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return false;\n    try {\n      const res = await fetch(`/api/games/${state.gameId}/leave`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ seatId: state.seatId })\n      });\n      if (!res.ok) return false;\n      try {\n        localStorage.removeItem('botc-seat-id');\n        localStorage.removeItem('botc-is-storyteller');\n      } catch {}\n      // Disconnect and clear game state\n      const { ws } = get();\n      if (ws) ws.close();\n      set({ connected: false, connecting: false, ws: null, currentGame: null, gameId: null, seatId: null, isStoryteller: false, setupState: null, grimoireState: null, setupError: null });\n      return true;\n    } catch {\n      return false;\n    }\n  },\n  \n  // Setup actions\n  enterSetup: async (): Promise<boolean> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return false;\n    // If we're already in SETUP, just load state and return success\n  if (state.currentGame?.phase === Enums.GamePhase.SETUP) {\n      try {\n        await get().loadSetupState();\n        set({ currentSetupStep: 'characters', setupError: null, setupLoading: false });\n        return true;\n      } catch {\n        // fallthrough to normal path\n      }\n    }\n    \n    set({ setupLoading: true, setupError: null });\n    \n    try {\n      const response = await SetupApi.enterSetup(state.gameId, state.seatId);\n      \n      if (response.success) {\n        await get().loadSetupState();\n        set({ currentSetupStep: 'characters' });\n  // Run validation silently in the background\n  get().autoValidate();\n      } else {\n        set({ setupError: response.error || 'Failed to enter setup phase' });\n      }\n      \n  set({ setupLoading: false });\n      return response.success;\n    } catch (error) {\n      set({ \n        setupLoading: false, \n        setupError: error instanceof Error ? error.message : 'Unknown error' \n      });\n      return false;\n    }\n  },\n  \n  selectCharacters: async (characterIds: string[]): Promise<boolean> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return false;\n    \n    set({ setupLoading: true, setupError: null });\n    \n    try {\n      const response = await SetupApi.selectCharacters(state.gameId, state.seatId, characterIds);\n      \n      if (response.success) {\n        await get().loadSetupState();\n  // Run validation silently in the background\n  get().autoValidate();\n      } else {\n        set({ setupError: response.error || 'Failed to select characters' });\n      }\n      \n      set({ setupLoading: false });\n      return response.success;\n    } catch (error) {\n      set({ \n        setupLoading: false, \n        setupError: error instanceof Error ? error.message : 'Unknown error' \n      });\n      return false;\n    }\n  },\n  \n  // Perform validation without changing UI steps or showing loading spinners\n  autoValidate: async (): Promise<void> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return;\n    try {\n      const response = await SetupApi.validateSetup(state.gameId, state.seatId);\n      // Update a lightweight snapshot only; do not mutate steps/loading\n      if (response.success) {\n        const valid = response.valid === true;\n        const details = response.details || [];\n        set({ setupState: { ...(get().setupState || {}), validation: { isValid: valid, issues: details } } });\n      } else {\n        // If server provides details on failure, store them for tooltip use\n        set({ setupState: { ...(get().setupState || {}), validation: { isValid: false, issues: response.details || [] } } });\n      }\n    } catch {\n      // Swallow errors silently for background validation\n    }\n  },\n  \n  validateSetup: async (): Promise<boolean> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return false;\n    \n    set({ setupLoading: true, setupError: null });\n    \n    try {\n      const response = await SetupApi.validateSetup(state.gameId, state.seatId);\n      \n      if (response.success) {\n        await get().loadSetupState();\n        // Preserve a simple validation snapshot to surface in UI (no step change)\n        set({ setupState: { ...(get().setupState || {}), validation: { isValid: response.valid === true, issues: response.details || [] } } });\n      } else {\n        set({ setupError: response.error || 'Setup validation failed' });\n        if (response.details) {\n          set({ setupError: `${response.error}: ${response.details.join(', ')}` });\n        }\n      }\n      \n      set({ setupLoading: false });\n      return response.success;\n    } catch (error) {\n      set({ \n        setupLoading: false, \n        setupError: error instanceof Error ? error.message : 'Unknown error' \n      });\n      return false;\n    }\n  },\n  \n  completeSetup: async (): Promise<boolean> => {\n    const state = get();\n    if (!state.gameId || !state.seatId) return false;\n    \n    set({ setupLoading: true, setupError: null });\n    \n    try {\n      const response = await SetupApi.completeSetup(state.gameId, state.seatId);\n      \n      if (response.success) {\n        set({ \n          currentSetupStep: 'complete',\n          setupState: null,\n          grimoireState: null\n        });\n      } else {\n        set({ setupError: response.error || 'Failed to complete setup' });\n      }\n      \n      set({ setupLoading: false });\n      return response.success;\n    } catch (error) {\n      set({ \n        setupLoading: false, \n        setupError: error instanceof Error ? error.message : 'Unknown error' \n      });\n      return false;\n    }\n  },\n  \n  loadSetupState: async (): Promise<void> => {\n    const state = get();\n    if (!state.gameId) return;\n    \n    try {\n      const response = await SetupApi.getSetupState(state.gameId);\n      \n      if (response) {\n        set((s) => ({ \n          setupState: response.setupState,\n          grimoireState: response.grimoireState,\n          currentGame: s.currentGame ? { ...s.currentGame, phase: response.phase as any } : s.currentGame\n        }));\n      } else {\n        set({ setupError: 'Failed to load setup state' });\n      }\n    } catch (error) {\n      set({ setupError: error instanceof Error ? error.message : 'Failed to load setup state' });\n    }\n  },\n  \n  setSetupError: (error: string | null) => {\n    set({ setupError: error });\n  },\n  \n  setSetupStep: (step: 'characters' | 'validation' | 'complete') => {\n    set({ currentSetupStep: step });\n  },\n\n  // Script actions - Fast cached loading\n  loadScripts: async () => {\n    const state = get();\n    if (state.scriptsLoading || state.availableScripts.length > 0) return;\n    \n    set({ scriptsLoading: true });\n    const startTime = Date.now();\n    \n    try {\n      // Load just the script list first (very fast from cache)\n      const response = await fetch('/api/scripts/cached/list');\n      if (!response.ok) throw new Error('Failed to load scripts list');\n      \n      const { scripts: scriptsList } = await response.json();\n      \n      // Load full script data for each script (also from cache, so very fast)\n      const scriptsPromises = scriptsList.map(async (script: { id: string; name: string }) => {\n        const res = await fetch(`/api/scripts/cached/${script.id}`);\n        if (!res.ok) throw new Error(`Failed to load script ${script.id}`);\n        return res.json();\n      });\n      \n      const scripts = await Promise.all(scriptsPromises);\n      const endTime = Date.now();\n      \n      set({ availableScripts: scripts, scriptsLoading: false });\n      \n      console.log(`⚡ Loaded ${scripts.length} scripts in ${endTime - startTime}ms (cache-optimized)`);\n    } catch (error) {\n      console.error('Failed to load scripts:', error);\n      set({ scriptsLoading: false });\n    }\n  },\n\n  loadScript: async (scriptId: string): Promise<LoadedScript | null> => {\n    try {\n      const response = await fetch(`/api/scripts/cached/${scriptId}`);\n      if (!response.ok) {\n        throw new Error(`Failed to load script ${scriptId}: ${response.statusText}`);\n      }\n      const script = await response.json();\n      return script;\n    } catch (error) {\n      console.error(`Failed to load script ${scriptId}:`, error);\n      return null;\n    }\n  },\n\n  setCurrentScript: (script: LoadedScript) => {\n    set({ currentScript: script });\n  }\n}));\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/test/setup.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 13,
        "column": 16,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, afterEach } from 'vitest';\nimport { cleanup } from '@testing-library/react';\nimport '@testing-library/jest-dom';\n\n// Cleanup after each test case\nafterEach(() => {\n  cleanup();\n});\n\n// Mock window.matchMedia\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: (query: string) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: () => {},\n    removeListener: () => {},\n    addEventListener: () => {},\n    removeEventListener: () => {},\n    dispatchEvent: () => {},\n  }),\n});\n\n// Mock WebSocket\nglobal.WebSocket = class WebSocket {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSING = 2;\n  static CLOSED = 3;\n\n  public readyState: number = WebSocket.CONNECTING;\n  public onopen: ((event: Event) => void) | null = null;\n  public onclose: ((event: CloseEvent) => void) | null = null;\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n  public onerror: ((event: Event) => void) | null = null;\n\n  constructor(public url: string) {\n    setTimeout(() => {\n      this.readyState = WebSocket.OPEN;\n      this.onopen?.(new Event('open'));\n    }, 0);\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n    // Mock implementation\n  }\n\n  close(): void {\n    this.readyState = WebSocket.CLOSED;\n    this.onclose?.(new CloseEvent('close'));\n  }\n} as any;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/utils/logger.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token LogLevel",
        "line": 1,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "type LogLevel = 'error' | 'warn' | 'info' | 'debug';\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: number;\n  context?: Record<string, any>;\n  stack?: string;\n  userId?: string;\n  sessionId?: string;\n  gameId?: string;\n}\n\nclass Logger {\n  private sessionId: string;\n  private userId?: string;\n  private gameId?: string;\n  private buffer: LogEntry[] = [];\n  private maxBufferSize = 100;\n  private flushInterval = 30000; // 30 seconds\n\n  constructor() {\n    this.sessionId = this.generateSessionId();\n    this.setupPeriodicFlush();\n    this.setupUnloadHandler();\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  setUser(userId: string) {\n    this.userId = userId;\n  }\n\n  setGame(gameId: string) {\n    this.gameId = gameId;\n  }\n\n  private createLogEntry(level: LogLevel, message: string, context?: Record<string, any>, error?: Error): LogEntry {\n    return {\n      level,\n      message,\n      timestamp: Date.now(),\n      context,\n      stack: error?.stack,\n      userId: this.userId,\n      sessionId: this.sessionId,\n      gameId: this.gameId,\n    };\n  }\n\n  error(message: string, context?: Record<string, any>, error?: Error) {\n    const entry = this.createLogEntry('error', message, context, error);\n    this.addToBuffer(entry);\n    \n    // Also log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`[${new Date().toISOString()}] ERROR: ${message}`, context, error);\n    }\n  }\n\n  warn(message: string, context?: Record<string, any>) {\n    const entry = this.createLogEntry('warn', message, context);\n    this.addToBuffer(entry);\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[${new Date().toISOString()}] WARN: ${message}`, context);\n    }\n  }\n\n  info(message: string, context?: Record<string, any>) {\n    const entry = this.createLogEntry('info', message, context);\n    this.addToBuffer(entry);\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.info(`[${new Date().toISOString()}] INFO: ${message}`, context);\n    }\n  }\n\n  debug(message: string, context?: Record<string, any>) {\n    if (process.env.NODE_ENV === 'development') {\n      const entry = this.createLogEntry('debug', message, context);\n      this.addToBuffer(entry);\n      console.debug(`[${new Date().toISOString()}] DEBUG: ${message}`, context);\n    }\n  }\n\n  // Game-specific logging methods\n  gameAction(action: string, context?: Record<string, any>) {\n    this.info(`Game Action: ${action}`, { ...context, type: 'game_action' });\n  }\n\n  performance(metric: string, value: number, context?: Record<string, any>) {\n    this.info(`Performance: ${metric}`, { ...context, type: 'performance', value });\n  }\n\n  userInteraction(interaction: string, context?: Record<string, any>) {\n    this.info(`User Interaction: ${interaction}`, { ...context, type: 'user_interaction' });\n  }\n\n  private addToBuffer(entry: LogEntry) {\n    this.buffer.push(entry);\n    \n    // Flush immediately for errors\n    if (entry.level === 'error') {\n      this.flush();\n    }\n    \n    // Keep buffer size manageable\n    if (this.buffer.length > this.maxBufferSize) {\n      this.buffer.shift(); // Remove oldest entry\n    }\n  }\n\n  private async flush() {\n    if (this.buffer.length === 0) return;\n\n    const logsToSend = [...this.buffer];\n    this.buffer = [];\n\n    try {\n      const response = await fetch('/api/logs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ logs: logsToSend }),\n        keepalive: true,\n      });\n\n      if (!response.ok) {\n        // Put failed logs back in buffer\n        this.buffer.unshift(...logsToSend);\n      }\n    } catch (error) {\n      // Put failed logs back in buffer\n      this.buffer.unshift(...logsToSend);\n      \n      // Only log to console to avoid infinite loop\n      console.error('Failed to send logs to server:', error);\n    }\n  }\n\n  private setupPeriodicFlush() {\n    setInterval(() => {\n      this.flush();\n    }, this.flushInterval);\n  }\n\n  private setupUnloadHandler() {\n    const handleUnload = () => {\n      // Use sendBeacon for more reliable delivery on page unload\n      if (this.buffer.length > 0 && 'sendBeacon' in navigator) {\n        const payload = JSON.stringify({ logs: this.buffer });\n        navigator.sendBeacon('/api/logs', payload);\n      }\n    };\n\n    window.addEventListener('beforeunload', handleUnload);\n    window.addEventListener('unload', handleUnload);\n    \n    // Also flush when page becomes hidden (mobile optimization)\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        this.flush();\n      }\n    });\n  }\n}\n\n// Create singleton instance\nexport const logger = new Logger();\n\n// Export types for TypeScript users\nexport type { LogLevel, LogEntry };",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/utils/performance.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\ninterface PerformanceMetrics {\n  cls: number | null;\n  fid: number | null;\n  fcp: number | null;\n  lcp: number | null;\n  ttfb: number | null;\n  sessionId: string;\n  timestamp: number;\n  url: string;\n  userAgent: string;\n}\n\nclass PerformanceMonitor {\n  private metrics: Partial<PerformanceMetrics> = {};\n  private sessionId: string;\n  private endpoint: string;\n\n  constructor(endpoint = '/api/analytics/vitals') {\n    this.sessionId = this.generateSessionId();\n    this.endpoint = endpoint;\n    this.initializeMetrics();\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private initializeMetrics(): void {\n    // Web Vitals\n    getCLS(this.recordMetric.bind(this, 'cls'));\n    getFID(this.recordMetric.bind(this, 'fid'));\n    getFCP(this.recordMetric.bind(this, 'fcp'));\n    getLCP(this.recordMetric.bind(this, 'lcp'));\n    getTTFB(this.recordMetric.bind(this, 'ttfb'));\n\n    // Custom game-specific metrics\n    this.trackGameMetrics();\n    \n    // Navigation metrics\n    this.trackNavigationTiming();\n    \n    // Resource metrics\n    this.trackResourceTiming();\n  }\n\n  private recordMetric(name: keyof PerformanceMetrics, metric: any): void {\n    this.metrics[name] = metric.value;\n    \n    // Send immediately for critical metrics\n    if (name === 'cls' || name === 'lcp') {\n      this.sendMetrics();\n    }\n  }\n\n  private trackGameMetrics(): void {\n    // Game-specific performance tracking\n    this.trackWebSocketLatency();\n    this.trackGameStateUpdates();\n    this.trackCharacterLoadTimes();\n  }\n\n  private trackWebSocketLatency(): void {\n    if (typeof window !== 'undefined' && 'WebSocket' in window) {\n      const originalWebSocket = window.WebSocket;\n      const self = this;\n      \n      window.WebSocket = class extends originalWebSocket {\n        constructor(url: string, protocols?: string | string[]) {\n          super(url, protocols);\n          \n          const startTime = performance.now();\n          \n          this.addEventListener('open', () => {\n            const latency = performance.now() - startTime;\n            self.recordCustomMetric('wsConnectionTime', latency);\n          });\n          \n          this.addEventListener('message', (event) => {\n            const messageTime = performance.now();\n            try {\n              const data = JSON.parse(event.data);\n              if (data.timestamp) {\n                const latency = messageTime - data.timestamp;\n                self.recordCustomMetric('wsMessageLatency', latency);\n              }\n            } catch (e) {\n              // Not JSON or no timestamp\n            }\n          });\n        }\n      };\n    }\n  }\n\n  private trackGameStateUpdates(): void {\n    // Track how long game state updates take to render\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.target instanceof HTMLElement && \n            mutation.target.dataset?.testid?.includes('game-')) {\n          const updateTime = performance.now();\n          this.recordCustomMetric('gameStateUpdate', updateTime);\n        }\n      });\n    });\n\n    if (document.body) {\n      observer.observe(document.body, { childList: true, subtree: true });\n    }\n  }\n\n  private trackCharacterLoadTimes(): void {\n    // Track character image loading performance\n    const imageObserver = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting && entry.target instanceof HTMLImageElement) {\n          const startTime = performance.now();\n          entry.target.addEventListener('load', () => {\n            const loadTime = performance.now() - startTime;\n            this.recordCustomMetric('characterImageLoad', loadTime);\n          });\n        }\n      });\n    });\n\n    // Observe character images\n    document.querySelectorAll('img[data-character]').forEach((img) => {\n      imageObserver.observe(img);\n    });\n  }\n\n  private trackNavigationTiming(): void {\n    window.addEventListener('load', () => {\n      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n      \n      this.recordCustomMetric('domContentLoaded', navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart);\n      this.recordCustomMetric('loadComplete', navigation.loadEventEnd - navigation.loadEventStart);\n      this.recordCustomMetric('dnsLookup', navigation.domainLookupEnd - navigation.domainLookupStart);\n    });\n  }\n\n  private trackResourceTiming(): void {\n    const resourceObserver = new PerformanceObserver((list) => {\n      list.getEntries().forEach((entry) => {\n        if (entry.name.includes('/api/')) {\n          this.recordCustomMetric('apiResponseTime', entry.duration);\n        }\n        if (entry.name.includes('.js') || entry.name.includes('.css')) {\n          this.recordCustomMetric('assetLoadTime', entry.duration);\n        }\n      });\n    });\n\n    resourceObserver.observe({ entryTypes: ['resource'] });\n  }\n\n  private recordCustomMetric(name: string, value: number): void {\n    // Store custom metrics\n    this.metrics = { ...this.metrics, [`custom_${name}`]: value };\n  }\n\n  private sendMetrics(): void {\n    const payload: PerformanceMetrics = {\n      ...this.metrics,\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      cls: this.metrics.cls || null,\n      fid: this.metrics.fid || null,\n      fcp: this.metrics.fcp || null,\n      lcp: this.metrics.lcp || null,\n      ttfb: this.metrics.ttfb || null,\n    };\n\n    // Send via beacon API (doesn't block page unload)\n    if ('sendBeacon' in navigator) {\n      navigator.sendBeacon(this.endpoint, JSON.stringify(payload));\n    } else {\n      // Fallback for older browsers\n      fetch(this.endpoint, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n      }).catch(() => {\n        // Ignore errors to avoid affecting user experience\n      });\n    }\n  }\n\n  // Public API for custom tracking\n  public trackCustomEvent(name: string, value: number): void {\n    this.recordCustomMetric(name, value);\n  }\n\n  public trackUserAction(action: string): void {\n    this.recordCustomMetric(`userAction_${action}`, performance.now());\n  }\n\n  // Initialize on page visibility change\n  public initialize(): void {\n    // Send metrics when page becomes hidden\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        this.sendMetrics();\n      }\n    });\n\n    // Send metrics on page unload\n    window.addEventListener('beforeunload', () => {\n      this.sendMetrics();\n    });\n\n    // Send metrics periodically\n    setInterval(() => {\n      this.sendMetrics();\n    }, 30000); // Every 30 seconds\n  }\n}\n\nexport default PerformanceMonitor;",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/utils/scriptManager.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token loader",
        "line": 5,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ScriptLoader, LoadedScript } from '@botc/shared';\nimport { FetchScriptDataSource } from '../data/fetchScriptDataSource';\n\nclass ClientScriptManager {\n  private loader: ScriptLoader;\n  private static instance: ClientScriptManager;\n\n  private constructor() {\n    this.loader = new ScriptLoader(new FetchScriptDataSource());\n  }\n\n  static getInstance(): ClientScriptManager {\n    if (!ClientScriptManager.instance) {\n      ClientScriptManager.instance = new ClientScriptManager();\n    }\n    return ClientScriptManager.instance;\n  }\n\n  async loadScript(scriptId: string): Promise<LoadedScript> {\n    return this.loader.loadScript(scriptId);\n  }\n\n  async getAllScripts(): Promise<LoadedScript[]> {\n    return this.loader.getAllScripts();\n  }\n\n  clearCache(): void {\n    this.loader.clearCache();\n  }\n}\n\nexport const clientScriptManager = ClientScriptManager.getInstance();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/utils/setupUtils.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token interface",
        "line": 5,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Utility functions for Game Setup page: role distribution, modifier application, night order extraction, script validation.\n\n// (No direct shared enums required yet; keep file dependency-light)\n\nexport interface RoleDistribution { townsfolk: number; outsiders: number; minions: number; demons: number; }\n\nexport interface ScriptLike {\n  id?: string;\n  name?: string;\n  characters?: any[]; // full character objects (lobby selection variant)\n  roles?: any[]; // script.roles variant (server format)\n  modifiers?: any[];\n  composition?: Record<string, Partial<RoleDistribution>>;\n  nightOrder?: any[];\n  firstNight?: any;\n  meta?: any;\n  complexity?: string; // allow direct access fallback\n}\n\n// Base distribution (Trouble Brewing style) used when no composition entry applies\nexport function computeBaseDistribution(playerCount: number): RoleDistribution {\n  if (playerCount >= 5 && playerCount <= 6) return { townsfolk: 3, outsiders: 1, minions: 1, demons: 1 };\n  if (playerCount >= 7 && playerCount <= 9) return { townsfolk: playerCount - 3, outsiders: 0, minions: 2, demons: 1 };\n  if (playerCount >= 10 && playerCount <= 12) return { townsfolk: playerCount - 4, outsiders: 1, minions: 2, demons: 1 };\n  if (playerCount >= 13 && playerCount <= 15) return { townsfolk: playerCount - 5, outsiders: 2, minions: 2, demons: 1 };\n  return {\n    townsfolk: Math.max(2, playerCount - 3),\n    outsiders: Math.max(0, Math.min(2, playerCount - 6)),\n    minions: Math.min(2, Math.max(1, Math.floor(playerCount / 4))),\n    demons: 1,\n  };\n}\n\n// Apply modifiers of type adjustCounts to a distribution copy\nexport function applyAdjustCountModifiers(dist: RoleDistribution, modifiers: any[] | undefined, selectedCharacterIds: string[] = []): RoleDistribution {\n  if (!modifiers) return dist;\n  const out: RoleDistribution = { ...dist };\n  for (const m of modifiers) {\n    if (m.type === 'adjustCounts') {\n      // Activate only if whenCharacter is selected (if provided)\n      if (m.whenCharacter && !selectedCharacterIds.includes(m.whenCharacter)) continue;\n      if (m.delta) {\n        for (const key of ['townsfolk','outsiders','minions','demons'] as (keyof RoleDistribution)[]) {\n          if (typeof m.delta[key] === 'number') {\n            out[key] = Math.max(0, out[key] + m.delta[key]);\n          }\n        }\n      }\n    }\n  }\n  return out;\n}\n\n// Resolve expected distribution: composition overrides > base, then modifiers\nexport function computeExpectedDistribution(playerCount: number, script: ScriptLike | undefined, selectedCharacterIds: string[] = []): RoleDistribution {\n  if (!script) return computeBaseDistribution(playerCount);\n  // Check composition table keys (exact or range like '7-9')\n  let base = computeBaseDistribution(playerCount);\n  if (script.composition) {\n    for (const [key, comp] of Object.entries(script.composition)) {\n      const m = key.match(/^(\\d+)(?:-(\\d+))?$/);\n      if (m) {\n        const a = parseInt(m[1], 10);\n        const b = m[2] ? parseInt(m[2], 10) : a;\n        if (playerCount >= a && playerCount <= b) {\n          base = {\n            townsfolk: evaluateExpression(comp.townsfolk, playerCount, base.townsfolk),\n            outsiders: evaluateExpression(comp.outsiders, playerCount, base.outsiders),\n            minions: evaluateExpression(comp.minions, playerCount, base.minions),\n            demons: evaluateExpression(comp.demons, playerCount, base.demons),\n          };\n          break;\n        }\n      }\n    }\n  }\n  return applyAdjustCountModifiers(base, script.modifiers, selectedCharacterIds);\n}\n\nfunction evaluateExpression(value: any, playerCount: number, fallback: number): number {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') {\n    // Support expressions like 'p-3'\n    const expr = value.replace(/p/g, String(playerCount));\n    try {\n      // eslint-disable-next-line no-new-func\n      const result = Function(`return (${expr})`)();\n      const num = Number(result);\n      if (!isNaN(num)) return num;\n    } catch {\n      return fallback;\n    }\n  }\n  return fallback;\n}\n\nexport interface ValidationIssue { type: string; message: string; related?: string[]; }\n\nexport interface ValidationResult { issues: ValidationIssue[]; isValid: boolean; }\n\nexport function validateSetup(script: ScriptLike | undefined, selectedCharacterIds: string[], expected: RoleDistribution): ValidationResult {\n  if (!script) return { issues: [{ type: 'no-script', message: 'No script selected' }], isValid: false };\n  const issues: ValidationIssue[] = [];\n  // Tally selected teams\n  const teamCounts: RoleDistribution = { townsfolk:0, outsiders:0, minions:0, demons:0 };\n  const characterMap = new Map<string, any>();\n  const roster = script.characters || script.roles || [];\n  for (const c of roster) {\n    const id = c.id || c.roleId || c;\n    characterMap.set(id, c);\n  }\n  for (const id of selectedCharacterIds) {\n    const c = characterMap.get(id);\n    if (!c) continue;\n    const team = (c.team || c.type || '').toString().toLowerCase();\n    const key = team.startsWith('town') ? 'townsfolk' : team.startsWith('out') ? 'outsiders' : team.startsWith('min') ? 'minions' : 'demons';\n    (teamCounts as any)[key] += 1;\n  }\n  for (const key of ['townsfolk','outsiders','minions','demons'] as (keyof RoleDistribution)[]) {\n    if (teamCounts[key] !== expected[key]) {\n      issues.push({ type: 'distribution', message: `${key} count ${teamCounts[key]} / ${expected[key]}`, related: [key] });\n    }\n  }\n  // Modifiers: requires\n  for (const m of script.modifiers || []) {\n    if (m.type === 'requires') {\n      const active = selectedCharacterIds.includes(m.whenCharacter);\n      if (active) {\n        for (const req of m.requireCharacters || []) {\n          if (!selectedCharacterIds.includes(req)) {\n            issues.push({ type: 'requires', message: `${m.whenCharacter} requires ${req}`, related: [m.whenCharacter, req] });\n          }\n        }\n      }\n    } else if (m.type === 'mutuallyExclusive') {\n      const present = (m.characters || []).filter((cid: string) => selectedCharacterIds.includes(cid));\n      if (present.length > 1) {\n        issues.push({ type: 'mutuallyExclusive', message: `Exclusive characters together: ${present.join(', ')}`, related: present });\n      }\n    } else if (m.type === 'atLeastOneOf') {\n      const present = (m.characters || []).some((cid: string) => selectedCharacterIds.includes(cid));\n      if (!present) {\n        issues.push({ type: 'atLeastOneOf', message: `Need at least one of: ${(m.characters || []).join(', ')}`, related: m.characters });\n      }\n    }\n  }\n  return { issues, isValid: issues.length === 0 };\n}\n\nexport interface NightOrderEntry { id: string; type: string; description?: string; order?: number; raw?: any; }\n\nexport function extractNightOrder(script: ScriptLike | undefined): NightOrderEntry[] {\n  if (!script) return [];\n  const entries: NightOrderEntry[] = [];\n  const source = Array.isArray(script.nightOrder) ? script.nightOrder : [];\n  for (const item of source) {\n    if (typeof item === 'string') {\n      entries.push({ id: item, type: 'character', raw: item });\n    } else if (item && typeof item === 'object') {\n      entries.push({ id: item.id || item.action, type: item.type || 'meta', description: item.description, order: item.order, raw: item });\n    }\n  }\n  // If empty, fallback: derive from characters sorted by (firstNight? otherNight?) metadata if available\n  if (!entries.length && Array.isArray(script.characters)) {\n    for (const c of script.characters) {\n      const id = c.id || c.name;\n      entries.push({ id, type: 'character', description: c.ability, raw: c });\n    }\n  }\n  // Sort by explicit order if present\n  entries.sort((a,b) => (a.order ?? 9999) - (b.order ?? 9999));\n  return entries;\n}\n\nexport function summarizeDifficulty(script: ScriptLike | undefined): string | undefined {\n  return (script?.meta?.complexity as string | undefined) || script?.complexity;\n}\n\nexport function detectScriptIssues(script: ScriptLike | undefined): string[] {\n  if (!script) return ['No script loaded'];\n  const issues: string[] = [];\n  // Basic heuristic checks\n  if (!Array.isArray(script.characters) || script.characters.length === 0) issues.push('Script has no characters');\n  if (Array.isArray(script.characters) && script.characters.length < 10) issues.push('Very small character list – may be unbalanced');\n  // Duplicate ids\n  if (Array.isArray(script.characters)) {\n    const seen = new Set<string>();\n    for (const c of script.characters) {\n      const id = (c.id || '').toLowerCase();\n      if (seen.has(id)) issues.push(`Duplicate character id: ${id}`); else if (id) seen.add(id);\n    }\n  }\n  return issues;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/utils/usePTT.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token ]",
        "line": 26,
        "column": 38,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback, useRef } from 'react';\nimport { PTTState, PTTMode, PTTSession } from '@botc/shared';\nimport { useGameStore } from '../store/gameStore';\n\nconst PTT_COOLDOWN_MS = 500;\nconst AUDIO_CONSTRAINTS = {\n  echoCancellation: true,\n  noiseSuppression: true,\n  sampleRate: 16000,\n  channelCount: 1\n};\n\nexport const usePTT = () => {\n  const { sendMessage, seatId } = useGameStore();\n  const [pttState, setPttState] = useState<PTTState>({\n    isMuted: true,\n    isSpeaking: false,\n    mode: 'hold',\n    cooldownEndTime: undefined,\n    currentSession: undefined,\n    lastSession: undefined\n  });\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n  const cooldownTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Initialize microphone access\n  useEffect(() => {\n    const initMic = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: AUDIO_CONSTRAINTS\n        });\n        streamRef.current = stream;\n\n        // Create MediaRecorder for low-bitrate mono audio\n        const mediaRecorder = new MediaRecorder(stream, {\n          mimeType: 'audio/webm;codecs=opus'\n        });\n\n        mediaRecorder.ondataavailable = (event) => {\n          if (event.data.size > 0) {\n            audioChunksRef.current.push(event.data);\n          }\n        };\n\n        mediaRecorderRef.current = mediaRecorder;\n      } catch (error) {\n        console.error('Failed to initialize microphone:', error);\n      }\n    };\n\n    initMic();\n\n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n      if (cooldownTimeoutRef.current) {\n        clearTimeout(cooldownTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Handle PTT start\n  const startPTT = useCallback(() => {\n    if (!mediaRecorderRef.current || pttState.isSpeaking || pttState.cooldownEndTime) {\n      return;\n    }\n\n    const sessionId = crypto.randomUUID();\n    const session: PTTSession = {\n      id: sessionId,\n      seatId: seatId!,\n      startTime: new Date()\n    };\n\n    setPttState(prev => ({\n      ...prev,\n      isMuted: false,\n      isSpeaking: true,\n      currentSession: session\n    }));\n\n    // Start recording\n    audioChunksRef.current = [];\n    mediaRecorderRef.current.start(100); // Collect data every 100ms\n\n    // Send PTT start event\n    sendMessage({\n      type: 'cmd',\n      cmd: {\n        kind: 'ptt_start',\n        payload: { sessionId, seatId }\n      }\n    });\n  }, [pttState.isSpeaking, pttState.cooldownEndTime, seatId, sendMessage]);\n\n  // Handle PTT end\n  const endPTT = useCallback(async () => {\n    if (!mediaRecorderRef.current || !pttState.isSpeaking || !pttState.currentSession) {\n      return;\n    }\n\n    // Stop recording\n    mediaRecorderRef.current.stop();\n\n    const endTime = new Date();\n    const session = {\n      ...pttState.currentSession,\n      endTime\n    };\n\n    // Create audio blob and get URI\n    const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\n    const audioUri = URL.createObjectURL(audioBlob);\n\n    const completedSession: PTTSession = {\n      ...session,\n      audioUri\n    };\n\n    setPttState(prev => ({\n      ...prev,\n      isMuted: true,\n      isSpeaking: false,\n      lastSession: completedSession,\n      currentSession: undefined,\n      cooldownEndTime: new Date(Date.now() + PTT_COOLDOWN_MS)\n    }));\n\n    // Send PTT end event\n    sendMessage({\n      type: 'cmd',\n      cmd: {\n        kind: 'ptt_end',\n        payload: {\n          sessionId: session.id,\n          seatId,\n          audioUri,\n          duration: endTime.getTime() - session.startTime.getTime()\n        }\n      }\n    });\n\n    // Start cooldown\n    cooldownTimeoutRef.current = setTimeout(() => {\n      setPttState(prev => ({\n        ...prev,\n        cooldownEndTime: undefined\n      }));\n    }, PTT_COOLDOWN_MS);\n  }, [pttState.isSpeaking, pttState.currentSession, seatId, sendMessage]);\n\n  // Handle PTT toggle\n  const togglePTT = useCallback(() => {\n    if (pttState.isSpeaking) {\n      endPTT();\n    } else {\n      startPTT();\n    }\n  }, [pttState.isSpeaking, startPTT, endPTT]);\n\n  // Handle mode change\n  const setMode = useCallback((mode: PTTMode) => {\n    setPttState(prev => ({ ...prev, mode }));\n  }, []);\n\n  // Keyboard event handlers\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.code === 'Space' && pttState.mode === 'hold') {\n        event.preventDefault();\n        startPTT();\n      } else if (event.code === 'KeyT' && pttState.mode === 'toggle') {\n        event.preventDefault();\n        togglePTT();\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (event.code === 'Space' && pttState.mode === 'hold') {\n        event.preventDefault();\n        endPTT();\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [pttState.mode, startPTT, endPTT, togglePTT]);\n\n  return {\n    pttState,\n    startPTT,\n    endPTT,\n    togglePTT,\n    setMode\n  };\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/client/src/vite-env.d.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 3,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_KEYCLOAK_URL: string\n  readonly VITE_API_URL: string\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/controllers/asrController.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 8,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FastifyRequest, FastifyReply } from 'fastify';\nimport { ASRService } from '../services/asrService';\nimport { PTTSession, GameEvent } from '@botc/shared';\nimport { logger } from '../utils/logger';\n\nconst asrService = new ASRService();\n\ninterface StreamAudioBody {\n  audioData: string; // base64 encoded audio\n  sessionId: string;\n  seatId: string;\n}\n\ninterface SummarizePhaseBody {\n  turns: PTTSession[];\n  events: GameEvent[];\n  viewerRole: string;\n  phase: string;\n}\n\nexport class ASRController {\n  /**\n   * Stream audio for ASR processing\n   */\n  static async streamAudio(request: FastifyRequest<{ Body: StreamAudioBody }>, reply: FastifyReply) {\n    try {\n      const { audioData, sessionId, seatId } = request.body;\n\n      if (!audioData || !sessionId || !seatId) {\n        reply.code(400);\n        return { error: 'audioData, sessionId, and seatId are required' };\n      }\n\n      // Process the audio stream\n      const result = await asrService.processAudioStream(audioData, sessionId, seatId);\n\n      // Extract game events from transcript\n      if (result.transcript) {\n        const events = asrService.extractGameEvents(result.transcript, seatId);\n        if (events.length > 0) {\n          // TODO: Get gameId from session or request\n          const gameId = 'mock-game-id'; // Placeholder\n          asrService.storeEvents(gameId, events);\n        }\n      }\n\n      reply.code(200);\n      return {\n        transcript: result.transcript,\n        wordLevelTranscript: result.wordLevelTranscript,\n        confidence: result.confidence,\n        eventsExtracted: result.transcript ? asrService.extractGameEvents(result.transcript, seatId).length : 0\n      };\n    } catch (error) {\n      logger.error('Error in streamAudio:', error);\n      reply.code(500);\n      return { error: 'Internal server error' };\n    }\n  }\n\n  /**\n   * Generate summary for phase transition\n   */\n  static async summarizePhase(request: FastifyRequest<{ Body: SummarizePhaseBody }>, reply: FastifyReply) {\n    try {\n      const { turns, events, viewerRole, phase } = request.body;\n\n      if (!turns || !events || !viewerRole || !phase) {\n        reply.code(400);\n        return { error: 'turns, events, viewerRole, and phase are required' };\n      }\n\n      // Generate summary\n      const summaryRequest = { turns, events, viewerRole, phase };\n      const summary = await asrService.generateSummary(summaryRequest);\n\n      // Redact for non-storyteller players\n      const redactedSummary = asrService.redactForPlayer(summary, viewerRole);\n\n      reply.code(200);\n      return redactedSummary;\n    } catch (error) {\n      logger.error('Error in summarizePhase:', error);\n      reply.code(500);\n      return { error: 'Internal server error' };\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/controllers/journalController.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 9,
        "column": 30,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Request, Response } from 'express';\nimport { JournalService } from '../services/journalService';\nimport { GameState } from '@botc/shared';\n\nexport class JournalController {\n  /**\n   * Add a note to a player's journal\n   */\n  static addNote = async (req: Request, res: Response) => {\n    try {\n      const { gameId, seatId } = req.params;\n      const { text } = req.body;\n\n      if (!text || typeof text !== 'string') {\n        return res.status(400).json({ error: 'Note text is required' });\n      }\n\n      // TODO: Fetch game state from storage/database\n      // For now, this is a placeholder\n      const gameState: GameState = req.gameState; // Assume middleware adds this\n\n      JournalService.addJournalNote(gameState, seatId, text);\n\n      // TODO: Save updated game state\n      \n      res.json({ success: true, message: 'Note added to journal' });\n    } catch (error) {\n      console.error('Error adding journal note:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  };\n\n  /**\n   * Get available moves for a player\n   */\n  static getAvailableMoves = async (req: Request, res: Response) => {\n    try {\n      const { gameId, seatId } = req.params;\n\n      // TODO: Fetch game state and character from storage/database\n      const gameState: GameState = req.gameState; // Assume middleware adds this\n      const seat = gameState.seats.find(s => s.id === seatId);\n      \n      if (!seat) {\n        return res.status(404).json({ error: 'Seat not found' });\n      }\n\n      // TODO: Get character from game/seat data\n      const character = undefined; // Placeholder - would fetch actual character\n\n      const moves = JournalService.getAvailableMovesForPlayer(gameState, seat, character);\n      \n      res.json({ moves });\n    } catch (error) {\n      console.error('Error getting available moves:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  };\n\n  /**\n   * Update player journal with current available moves\n   */\n  static updateJournal = async (req: Request, res: Response) => {\n    try {\n      const { gameId, seatId } = req.params;\n\n      // TODO: Fetch game state and character from storage/database\n      const gameState: GameState = req.gameState;\n      const character = undefined; // Placeholder\n\n      JournalService.updatePlayerJournal(gameState, seatId, character);\n\n      // TODO: Save updated game state\n\n      res.json({ success: true, message: 'Journal updated' });\n    } catch (error) {\n      console.error('Error updating journal:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  };\n\n  /**\n   * Get player journal (for the player themselves)\n   */\n  static getJournal = async (req: Request, res: Response) => {\n    try {\n      const { gameId, seatId } = req.params;\n\n      const gameState: GameState = req.gameState;\n      const seat = gameState.seats.find(s => s.id === seatId);\n      \n      if (!seat) {\n        return res.status(404).json({ error: 'Seat not found' });\n      }\n\n      res.json({ journal: seat.journal || { notes: [], moves: [] } });\n    } catch (error) {\n      console.error('Error getting journal:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  };\n\n  /**\n   * Get all player journals (for storyteller auditing)\n   */\n  static getAllJournals = async (req: Request, res: Response) => {\n    try {\n      const { gameId } = req.params;\n\n      // TODO: Verify user is storyteller\n      \n      const gameState: GameState = req.gameState;\n      const journals = JournalService.getPlayerJournalsForStoryteller(gameState);\n\n      res.json({ journals });\n    } catch (error) {\n      console.error('Error getting all journals:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  };\n}\n\n// Extend Express Request to include gameState (this would be added by middleware)\ndeclare global {\n  namespace Express {\n    interface Request {\n      gameState: GameState;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/data/dataManager.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token interface",
        "line": 12,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { promises as fs } from 'fs';\nimport path from 'path';\nimport {\n  ScrapedTown,\n  ScrapedCharacter,\n  WikiDataTransformer,\n  ScrapedCharactersFileSchema,\n  ScrapedTownsFileSchema\n} from '@botc/shared';\nimport { logger } from '../utils/logger';\n\nexport interface TownMetadata {\n  id: string;\n  name: string;\n  description: string;\n  region: string;\n  population: number;\n  notableLocations: string[];\n  resources: string[];\n  governance: string;\n  coordinates: { x: number; y: number };\n  connections: string[];\n  imageUrl: string;\n  wikiUrl: string;\n  characterCount: number;\n  lastUpdated: Date;\n}\n\nexport interface CharacterMetadata {\n  id: string;\n  name: string;\n  category: 'Townsfolk' | 'Outsider' | 'Minion' | 'Demon' | 'Traveller' | 'Fabled';\n  edition: string[];\n  abilitySummary: string;\n  firstNightAction?: string | null;\n  otherNightsAction?: string | null;\n  dayAction?: string | null;\n  tags: string[];\n  tokensUsed: string[];\n  imageUrl?: string;\n  wikiUrl?: string;\n  lastUpdated: Date;\n}\n\nexport class DataManager {\n  private townsData: Map<string, ScrapedTown> = new Map();\n  private charactersData: Map<string, ScrapedCharacter> = new Map();\n  private scriptsData: Map<string, any> = new Map(); // Store script metadata and character lists\n  private townMetadata: Map<string, TownMetadata> = new Map();\n  private characterMetadata: Map<string, CharacterMetadata> = new Map();\n  private dataDirectory: string;\n\n  constructor(dataDirectory: string = path.join(process.cwd(), '..', '..', 'data')) {\n    this.dataDirectory = dataDirectory;\n  }\n\n  async initialize(): Promise<void> {\n    await this.ensureDataDirectory();\n    await this.loadExistingData();\n  }\n\n  private async ensureDataDirectory(): Promise<void> {\n    await fs.mkdir(this.dataDirectory, { recursive: true });\n    await fs.mkdir(path.join(this.dataDirectory, 'towns'), { recursive: true });\n    await fs.mkdir(path.join(this.dataDirectory, 'characters'), { recursive: true });\n    await fs.mkdir(path.join(this.dataDirectory, 'scripts'), { recursive: true });\n  }\n\n  private async loadExistingData(): Promise<void> {\n    try {\n      // Load characters from individual files\n      await this.loadCharactersFromDirectory();\n      \n      // Load scripts from scripts directory\n      await this.loadScriptsFromDirectory();\n    } catch (error) {\n      logger.warn('Error loading data:', error);\n    }\n  }\n\n  private async loadCharactersFromDirectory(): Promise<void> {\n    const charactersDir = path.join(this.dataDirectory, 'characters');\n    \n    try {\n      const files = await fs.readdir(charactersDir);\n      let loadedCount = 0;\n      \n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const filePath = path.join(charactersDir, file);\n          const characterData = await fs.readFile(filePath, 'utf8');\n          const character = JSON.parse(characterData);\n          \n          // Convert to ScrapedCharacter format if needed\n          const scrapedChar: ScrapedCharacter = {\n            id: character.id,\n            name: character.name,\n            category: character.team || character.category,\n            edition: character.editions || character.edition || [],\n            abilitySummary: character.ability || character.ability_summary || '',\n            firstNightAction: character.firstNight || null,\n            otherNightsAction: character.otherNights || null,\n            dayAction: character.dayAction || null,\n            tags: character.tags || [],\n            tokensUsed: character.tokensUsed || character.tokens_used || [],\n            imageUrl: character.imageUrl || character.image_url,\n            wikiUrl: character.wikiUrl || character.wiki_url\n          };\n          \n          this.charactersData.set(character.id, scrapedChar);\n          this.characterMetadata.set(character.id, this.createCharacterMetadata(scrapedChar));\n          loadedCount++;\n        }\n      }\n      \n      logger.info(`Loaded ${loadedCount} characters from directory`);\n    } catch (error) {\n      logger.warn('Error loading characters from directory:', error);\n    }\n  }\n\n  private async loadScriptsFromDirectory(): Promise<void> {\n    const scriptsDir = path.join(this.dataDirectory, 'scripts');\n    \n    try {\n      const files = await fs.readdir(scriptsDir);\n      let loadedCount = 0;\n      \n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const filePath = path.join(scriptsDir, file);\n          const scriptData = await fs.readFile(filePath, 'utf8');\n          const script = JSON.parse(scriptData);\n          \n          // Store script data\n          this.scriptsData.set(script.id, script);\n          \n          // Also create a town entry for backward compatibility\n          const scrapedTown: ScrapedTown = {\n            id: script.id,\n            name: script.name,\n            description: script.description,\n            region: script.id, // Use script id as region\n            population: 0,\n            notableLocations: [],\n            resources: [],\n            governance: '',\n            coordinates: { x: 0, y: 0 },\n            connections: [],\n            imageUrl: '',\n            wikiUrl: ''\n          };\n          \n          this.townsData.set(script.id, scrapedTown);\n          this.townMetadata.set(script.id, this.createTownMetadata(scrapedTown));\n          loadedCount++;\n        }\n      }\n      \n      logger.info(`Loaded ${loadedCount} scripts from directory`);\n    } catch (error) {\n      logger.warn('Error loading scripts from directory:', error);\n    }\n  }\n\n  private async fileExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private createTownMetadata(town: ScrapedTown): TownMetadata {\n    return {\n      id: town.id,\n      name: town.name,\n      description: town.description || '',\n      region: town.region || '',\n      population: town.population || 0,\n      notableLocations: town.notableLocations || [],\n      resources: town.resources || [],\n      governance: town.governance || '',\n      coordinates: {\n        x: town.coordinates?.x || 0,\n        y: town.coordinates?.y || 0\n      },\n      connections: town.connections || [],\n      imageUrl: town.imageUrl || '',\n      wikiUrl: town.wikiUrl || '',\n      characterCount: Array.from(this.charactersData.values()).filter(c => c.edition.includes(town.id)).length,\n      lastUpdated: new Date()\n    };\n  }\n\n  private createCharacterMetadata(character: ScrapedCharacter): CharacterMetadata {\n    return {\n      id: character.id,\n      name: character.name,\n      category: character.category,\n      edition: character.edition,\n      abilitySummary: character.abilitySummary,\n      firstNightAction: character.firstNightAction,\n      otherNightsAction: character.otherNightsAction,\n      dayAction: character.dayAction,\n      tags: character.tags || [],\n      tokensUsed: character.tokensUsed || [],\n      imageUrl: character.imageUrl,\n      wikiUrl: character.wikiUrl,\n      lastUpdated: new Date()\n    };\n  }\n\n  // Import methods\n  async importTownsFromFile(filePath: string): Promise<void> {\n    const townsData = await fs.readFile(filePath, 'utf8');\n    const rawTowns = JSON.parse(townsData);\n    \n    let imported = 0;\n    const towns: ScrapedTown[] = [];\n\n    for (const rawTown of rawTowns.towns || rawTowns) {\n      try {\n        const validatedTown = WikiDataTransformer.validateTownData(rawTown);\n        this.townsData.set(validatedTown.id, validatedTown);\n        this.townMetadata.set(validatedTown.id, this.createTownMetadata(validatedTown));\n        towns.push(validatedTown);\n        imported++;\n      } catch (error) {\n        logger.warn(`Failed to import town ${rawTown.name}:`, error);\n      }\n    }\n\n    await this.saveTowns();\n    logger.info(`Imported ${imported} towns from ${filePath}`);\n  }\n\n  async importCharactersFromFile(filePath: string): Promise<void> {\n    const charactersData = await fs.readFile(filePath, 'utf8');\n    const rawCharacters = JSON.parse(charactersData);\n    \n    let imported = 0;\n    const characters: ScrapedCharacter[] = [];\n\n    for (const rawCharacter of rawCharacters.characters || rawCharacters) {\n      try {\n        const validatedCharacter = WikiDataTransformer.validateCharacterData(rawCharacter);\n        this.charactersData.set(validatedCharacter.id, validatedCharacter);\n        this.characterMetadata.set(validatedCharacter.id, this.createCharacterMetadata(validatedCharacter));\n        characters.push(validatedCharacter);\n        imported++;\n      } catch (error) {\n        logger.warn(`Failed to import character ${rawCharacter.name}:`, error);\n      }\n    }\n\n    await this.saveCharacters();\n    logger.info(`Imported ${imported} characters from ${filePath}`);\n  }\n\n  // Query methods\n  async getAllTowns(): Promise<TownMetadata[]> {\n    return Array.from(this.townMetadata.values());\n  }\n\n  async getAllCharacters(): Promise<CharacterMetadata[]> {\n    return Array.from(this.characterMetadata.values());\n  }\n\n  async getTownById(id: string): Promise<ScrapedTown | undefined> {\n    return this.townsData.get(id);\n  }\n\n  async getCharacterById(id: string): Promise<ScrapedCharacter | undefined> {\n    return this.charactersData.get(id);\n  }\n\n  async getCharactersByTown(townId: string): Promise<CharacterMetadata[]> {\n    return Array.from(this.characterMetadata.values()).filter(c => c.edition.includes(townId));\n  }\n\n  async getTownsByRegion(region: string): Promise<TownMetadata[]> {\n    return Array.from(this.townMetadata.values()).filter(t => \n      t.region.toLowerCase().includes(region.toLowerCase())\n    );\n  }\n\n  async searchCharacters(query: string): Promise<CharacterMetadata[]> {\n    const lowerQuery = query.toLowerCase();\n    return Array.from(this.characterMetadata.values()).filter(c =>\n      c.name.toLowerCase().includes(lowerQuery) ||\n      c.abilitySummary.toLowerCase().includes(lowerQuery) ||\n      c.category.toLowerCase().includes(lowerQuery) ||\n      c.tags.some(tag => tag.toLowerCase().includes(lowerQuery)) ||\n      c.tokensUsed.some(token => token.toLowerCase().includes(lowerQuery))\n    );\n  }\n\n  async searchTowns(query: string): Promise<TownMetadata[]> {\n    const lowerQuery = query.toLowerCase();\n    return Array.from(this.townMetadata.values()).filter(t =>\n      t.name.toLowerCase().includes(lowerQuery) ||\n      t.description.toLowerCase().includes(lowerQuery) ||\n      t.region.toLowerCase().includes(lowerQuery) ||\n      t.governance.toLowerCase().includes(lowerQuery)\n    );\n  }\n\n  // Statistics\n  async getStatistics(): Promise<{\n    totalTowns: number;\n    totalCharacters: number;\n    charactersByCategory: Record<string, number>;\n    charactersByEdition: Record<string, number>;\n    townsByRegion: Record<string, number>;\n  }> {\n    const characters = Array.from(this.characterMetadata.values());\n    const towns = Array.from(this.townMetadata.values());\n\n    const charactersByCategory: Record<string, number> = {};\n    const charactersByEdition: Record<string, number> = {};\n    const townsByRegion: Record<string, number> = {};\n\n    characters.forEach(char => {\n      charactersByCategory[char.category] = (charactersByCategory[char.category] || 0) + 1;\n      char.edition.forEach(edition => {\n        charactersByEdition[edition] = (charactersByEdition[edition] || 0) + 1;\n      });\n    });\n\n    towns.forEach(town => {\n      const region = town.region || 'Unknown';\n      townsByRegion[region] = (townsByRegion[region] || 0) + 1;\n    });\n\n    return {\n      totalTowns: towns.length,\n      totalCharacters: characters.length,\n      charactersByCategory,\n      charactersByEdition,\n      townsByRegion\n    };\n  }\n\n  // Persistence methods\n  private async saveTowns(): Promise<void> {\n    const towns = Array.from(this.townsData.values());\n    const townsFile = { towns };\n    const filePath = path.join(this.dataDirectory, 'towns.json');\n    await fs.writeFile(filePath, JSON.stringify(townsFile, null, 2), 'utf8');\n  }\n\n  private async saveCharacters(): Promise<void> {\n    const characters = Array.from(this.charactersData.values());\n    const charactersFile = { characters };\n    const filePath = path.join(this.dataDirectory, 'characters.json');\n    await fs.writeFile(filePath, JSON.stringify(charactersFile, null, 2), 'utf8');\n  }\n\n  async exportData(outputDir: string): Promise<void> {\n    await fs.mkdir(outputDir, { recursive: true });\n    \n    // Export towns\n    const townsPath = path.join(outputDir, 'towns.json');\n    await this.saveTowns();\n    await fs.copyFile(path.join(this.dataDirectory, 'towns.json'), townsPath);\n    \n    // Export characters\n    const charactersPath = path.join(outputDir, 'characters.json');\n    await this.saveCharacters();\n    await fs.copyFile(path.join(this.dataDirectory, 'characters.json'), charactersPath);\n    \n    // Export metadata\n    const metadataPath = path.join(outputDir, 'metadata.json');\n    const metadata = {\n      towns: Array.from(this.townMetadata.values()),\n      characters: Array.from(this.characterMetadata.values()),\n      statistics: await this.getStatistics(),\n      exportedAt: new Date()\n    };\n    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf8');\n    \n    logger.info(`Exported data to ${outputDir}`);\n  }\n}\n\n// Singleton instance\nexport const dataManager = new DataManager();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/data/nodeScriptDataSource.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token implements",
        "line": 5,
        "column": 35,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { promises as fs } from 'fs';\nimport path from 'path';\nimport { ScriptDataSource } from '@botc/shared';\n\nexport class NodeScriptDataSource implements ScriptDataSource {\n  // Point to the repo-level data directory which contains per-script folders\n  constructor(private dataDirectory: string = path.join(process.cwd(), '..', '..', 'data')) {}\n\n  async loadCharacters(scriptPath: string): Promise<any> {\n    // Load the script metadata to get both character list and full script data\n    const scriptData = await this.loadMetadata(scriptPath);\n    const characterIds = scriptData.characters || [];\n    \n    // Load individual character files to get detailed character data\n    const characters = [];\n    for (const charId of characterIds) {\n      const charFile = path.join(this.dataDirectory, 'characters', `${charId}.json`);\n      try {\n        const charData = await fs.readFile(charFile, 'utf8');\n        characters.push(JSON.parse(charData));\n      } catch (error) {\n        console.error(`Failed to load character ${charId}:`, error instanceof Error ? error.message : String(error));\n        throw new Error(`Missing character file: ${charId}.json`);\n      }\n    }\n    \n    return characters;\n  }\n\n  async loadMetadata(scriptPath: string): Promise<any> {\n    let scriptFile = path.join(this.dataDirectory, 'scripts', `${scriptPath}.json`);\n    \n    // Check if the file exists, if not try custom-scripts\n    try {\n      await fs.access(scriptFile);\n    } catch {\n      scriptFile = path.join(this.dataDirectory, 'scripts', 'custom-scripts', `${scriptPath}.json`);\n    }\n    \n    const data = await fs.readFile(scriptFile, 'utf8');\n    const scriptData = JSON.parse(data);\n    \n    // Include the structured night order data in metadata\n    return {\n      ...scriptData,\n      meta: {\n        id: scriptData.id,\n        name: scriptData.name,\n        author: scriptData.author,\n        description: scriptData.description,\n        version: scriptData.version,\n        playerCount: scriptData.playerCount,\n        complexity: scriptData.complexity,\n        tags: scriptData.tags,\n        estimatedTime: scriptData.estimatedTime\n      },\n      // Preserve the structured night order\n      firstNight: scriptData.firstNight,\n      nightOrder: scriptData.nightOrder\n    };\n  }\n\n  private formatCharacterName(id: string): string {\n    return id.split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  async listAvailableScripts(): Promise<string[]> {\n    const scripts: string[] = [];\n    const scriptsDir = path.join(this.dataDirectory, 'scripts');\n\n    try {\n      const items = await fs.readdir(scriptsDir, { withFileTypes: true });\n      for (const item of items) {\n        if (item.isFile() && item.name.endsWith('.json')) {\n          const scriptId = item.name.replace('.json', '');\n          scripts.push(scriptId);\n        } else if (item.isDirectory()) {\n          // Check for scripts in subdirectories\n          const subDir = path.join(scriptsDir, item.name);\n          try {\n            const subItems = await fs.readdir(subDir, { withFileTypes: true });\n            for (const subItem of subItems) {\n              if (subItem.isFile() && subItem.name.endsWith('.json')) {\n                const scriptId = `${item.name}/${subItem.name.replace('.json', '')}`;\n                scripts.push(scriptId);\n              }\n            }\n          } catch (error) {\n            // Skip subdirectory if can't read\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Error listing scripts:', error);\n    }\n\n    return scripts;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/action-system.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token initializeActionHandlers",
        "line": 47,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { \n  GameState, \n  Seat, \n  SeatId, \n  CharacterAction, \n  MetaAction, \n  ActionContext, \n  ActionResult, \n  InformationSpec,\n  Character,\n  RoleType,\n} from '@botc/shared';\n\n// Import from the new action system modules\nimport { \n  CharacterActionType,\n  MetaActionType,\n  isCharacterAction,\n  isMetaAction,\n} from '@botc/shared';\nimport { \n  globalActionRegistry,\n  ActionValidator,\n} from '@botc/shared';\nimport { \n  CHARACTER_ACTION_HANDLERS,\n  META_ACTION_HANDLERS,\n} from '@botc/shared';\n\nimport { randomUUID } from 'crypto';\nimport { logger } from '../utils/logger';\n\n/**\n * Action execution system for handling both character actions and meta actions\n * This system processes the structured action metadata from characters and scripts\n */\nexport class ActionSystem {\n  \n  constructor() {\n    // Register all standard action handlers\n    this.initializeActionHandlers();\n  }\n\n  /**\n   * Initialize the action registry with standard handlers\n   */\n  private initializeActionHandlers(): void {\n    // Register character action handlers\n    for (const [actionType, handler] of Object.entries(CHARACTER_ACTION_HANDLERS)) {\n      globalActionRegistry.registerCharacterAction(actionType as CharacterActionType, handler);\n    }\n\n    // Register meta action handlers  \n    for (const [actionType, handler] of Object.entries(META_ACTION_HANDLERS)) {\n      globalActionRegistry.registerMetaAction(actionType as MetaActionType, handler);\n    }\n\n    logger.info(`Registered ${globalActionRegistry.getRegisteredCharacterActions().length} character actions`);\n    logger.info(`Registered ${globalActionRegistry.getRegisteredMetaActions().length} meta actions`);\n  }\n  \n  /**\n   * Execute a character action based on the action metadata\n   */\n  async executeCharacterAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    character: Character,\n    actingSeat: Seat\n  ): Promise<ActionResult> {\n    logger.info(`Executing character action ${action.id} for ${character.name} in game ${game.id}`);\n    \n    try {\n      // Validate action before execution\n      const validation = ActionValidator.canPerformAction(action, context, game, actingSeat);\n      if (!validation.valid) {\n        return {\n          actionId: action.id,\n          success: false,\n          errors: [validation.reason || 'Action validation failed']\n        };\n      }\n\n      // Check if we have a registered handler for this action type\n      const actionType = action.action as CharacterActionType;\n      if (!isCharacterAction(actionType)) {\n        return {\n          actionId: action.id,\n          success: false,\n          errors: [`Invalid character action type: ${action.action}`]\n        };\n      }\n\n      const handler = globalActionRegistry.getCharacterActionHandler(actionType);\n      if (!handler) {\n        logger.warn(`No handler registered for character action: ${action.action}`);\n        return {\n          actionId: action.id,\n          success: false,\n          errors: [`No handler registered for action type: ${action.action}`]\n        };\n      }\n\n      // Execute the action using the registered handler\n      const typedAction = { ...action, action: actionType };\n      return await handler(typedAction, context, game, actingSeat);\n      \n    } catch (error) {\n      logger.error(`Error executing character action ${action.id}:`, error);\n      return {\n        actionId: action.id,\n        success: false,\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  /**\n   * Execute a meta action (script-level action like minion-info, demon-info)\n   */\n  async executeMetaAction(\n    action: MetaAction,\n    context: ActionContext,\n    game: GameState\n  ): Promise<ActionResult> {\n    logger.info(`Executing meta action ${action.id} in game ${game.id}`);\n    \n    try {\n      // Check if we have a registered handler for this action type\n      if (!action.action || !isMetaAction(action.action)) {\n        return {\n          actionId: action.id,\n          success: false,\n          errors: [`Invalid meta action type: ${action.action}`]\n        };\n      }\n\n      const handler = globalActionRegistry.getMetaActionHandler(action.action);\n      if (!handler) {\n        logger.warn(`No handler registered for meta action: ${action.action}`);\n        return {\n          actionId: action.id,\n          success: false,\n          errors: [`No handler registered for action type: ${action.action}`]\n        };\n      }\n\n      // Execute the action using the registered handler\n      return await handler(action, context, game);\n      \n    } catch (error) {\n      logger.error(`Error executing meta action ${action.id}:`, error);\n      return {\n        actionId: action.id,\n        success: false,\n        errors: [error instanceof Error ? error.message : 'Unknown error']\n      };\n    }\n  }\n\n  /**\n   * Chef: Count pairs of neighboring evil players\n   */\n  private executeChefAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    const playerSeats = this.getPlayerSeats(game);\n    let pairCount = 0;\n    \n    for (let i = 0; i < playerSeats.length; i++) {\n      const current = playerSeats[i];\n      const next = playerSeats[(i + 1) % playerSeats.length];\n      \n      if (this.isEvil(current) && this.isEvil(next)) {\n        pairCount++;\n      }\n    }\n\n    const information = action.information?.customMessage \n      ? action.information.customMessage.replace('[COUNT]', pairCount.toString())\n      : `You see ${pairCount} pairs of neighboring evil players`;\n\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: information,\n        count: pairCount\n      }\n    };\n  }\n\n  /**\n   * Empath: Count evil neighbors\n   */\n  private executeEmpathAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    const playerSeats = this.getPlayerSeats(game);\n    const actingIndex = playerSeats.findIndex(s => s.id === actingSeat.id);\n    \n    if (actingIndex === -1) {\n      return {\n        actionId: action.id,\n        success: false,\n        errors: ['Acting seat not found among players']\n      };\n    }\n\n    const leftNeighbor = playerSeats[(actingIndex - 1 + playerSeats.length) % playerSeats.length];\n    const rightNeighbor = playerSeats[(actingIndex + 1) % playerSeats.length];\n    \n    const evilCount = (this.isEvil(leftNeighbor) ? 1 : 0) + (this.isEvil(rightNeighbor) ? 1 : 0);\n\n    const information = action.information?.customMessage \n      ? action.information.customMessage.replace('[COUNT]', evilCount.toString())\n      : `You see ${evilCount} evil neighbors`;\n\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: information,\n        count: evilCount\n      }\n    };\n  }\n\n  /**\n   * Investigative actions like Washerwoman, Librarian, Investigator\n   */\n  private executeInvestigativeAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    // This would need specific implementation based on the character\n    // For now, return a placeholder\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: 'Investigative information delivered',\n        // Would include specific player/role information\n      }\n    };\n  }\n\n  /**\n   * Show team information to minions\n   */\n  private executeShowTeamToMinions(\n    action: MetaAction,\n    context: ActionContext,\n    game: GameState\n  ): ActionResult {\n    const minions = this.getSeatsByTeam(game, 'minion');\n    const demons = this.getSeatsByTeam(game, 'demon');\n    const information: Record<string, any> = {};\n\n    for (const minion of minions) {\n      const teammates = [...minions.filter(m => m.id !== minion.id), ...demons];\n      information[minion.id] = {\n        message: 'You learn who your fellow evil players are',\n        teammates: teammates.map(t => ({ seatId: t.id, role: action.information?.showRoles ? t.role : undefined }))\n      };\n    }\n\n    return {\n      actionId: action.id,\n      success: true,\n      information\n    };\n  }\n\n  /**\n   * Show team and bluffs to demon\n   */\n  private executeShowTeamAndBluffsToDemon(\n    action: MetaAction,\n    context: ActionContext,\n    game: GameState\n  ): ActionResult {\n    const demons = this.getSeatsByTeam(game, 'demon');\n    const minions = this.getSeatsByTeam(game, 'minion');\n    const information: Record<string, any> = {};\n\n    if (demons.length === 0) {\n      return {\n        actionId: action.id,\n        success: false,\n        errors: ['No demon found in game']\n      };\n    }\n\n    const demon = demons[0]; // Assume single demon for now\n    const bluffs = this.generateBluffs(game, action.information?.giveBluffs || 3);\n\n    information[demon.id] = {\n      message: 'You learn who your minions are and receive bluff characters',\n      minions: minions.map(m => ({ seatId: m.id, role: action.information?.showRoles ? m.role : undefined })),\n      bluffs\n    };\n\n    return {\n      actionId: action.id,\n      success: true,\n      information\n    };\n  }\n\n  /**\n   * Generic kill action\n   */\n  private executeKillAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    // Implementation would depend on targeting rules and game state\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: 'Kill action executed'\n      }\n    };\n  }\n\n  /**\n   * Generic protection action\n   */\n  private executeProtectionAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: 'Protection applied'\n      }\n    };\n  }\n\n  /**\n   * Generic poison action\n   */\n  private executePoisonAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: 'Poison applied'\n      }\n    };\n  }\n\n  /**\n   * Vote manipulation actions\n   */\n  private executeVoteManipulationAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): ActionResult {\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        recipient: actingSeat.id,\n        message: 'Vote manipulation applied'\n      }\n    };\n  }\n\n  /**\n   * Setup madness action for special scripts\n   */\n  private executeSetupMadness(\n    action: MetaAction,\n    context: ActionContext,\n    game: GameState\n  ): ActionResult {\n    return {\n      actionId: action.id,\n      success: true,\n      information: {\n        message: 'Madness setup completed'\n      }\n    };\n  }\n\n  // Helper methods\n\n  private getPlayerSeats(game: GameState): Seat[] {\n    return game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId);\n  }\n\n  private getSeatsByTeam(game: GameState, team: string): Seat[] {\n  const roleTypeMap: Record<string, typeof RoleType[keyof typeof RoleType]> = {\n      'townsfolk': RoleType.TOWNSFOLK,\n      'outsider': RoleType.OUTSIDER,\n      'minion': RoleType.MINION,\n      'demon': RoleType.DEMON\n    };\n\n    const targetRoleType = roleTypeMap[team];\n    if (!targetRoleType) return [];\n\n    return this.getPlayerSeats(game).filter(seat => {\n      // This would need to be improved with proper role type mapping from character data\n      return seat.role && this.getRoleType(seat.role) === targetRoleType;\n    });\n  }\n\n  private isEvil(seat: Seat): boolean {\n    return seat.alignment === 'evil';\n  }\n\n  private getRoleType(roleId: string): typeof RoleType[keyof typeof RoleType] {\n    // This is a simplified mapping - in real implementation, \n    // this would look up the role in the script data\n    const evilRoles = ['imp', 'poisoner', 'spy', 'scarlet-woman', 'baron'];\n    const outsiderRoles = ['drunk', 'recluse', 'saint', 'butler'];\n    \n    if (evilRoles.includes(roleId)) {\n      return roleId === 'imp' ? RoleType.DEMON : RoleType.MINION;\n    }\n    if (outsiderRoles.includes(roleId)) {\n      return RoleType.OUTSIDER;\n    }\n    return RoleType.TOWNSFOLK;\n  }\n\n  private generateBluffs(game: GameState, count: number): string[] {\n    // Generate bluff characters not in play\n    const inPlayRoles = new Set(this.getPlayerSeats(game).map(s => s.role).filter(Boolean));\n    const allRoles = ['washerwoman', 'librarian', 'investigator', 'chef', 'empath', 'fortune-teller', 'undertaker', 'monk', 'ravenkeeper', 'virgin', 'slayer', 'soldier', 'mayor'];\n    const availableBluffs = allRoles.filter(role => !inPlayRoles.has(role));\n    \n    // Shuffle and take the requested count\n    const shuffled = [...availableBluffs].sort(() => Math.random() - 0.5);\n    return shuffled.slice(0, count);\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/engine.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token games",
        "line": 12,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, GamePhase, Event, SeatId, GameId } from '@botc/shared';\nimport { randomUUID } from 'crypto';\nimport { logger } from '../utils/logger';\nimport { RulesEngine } from './rules';\nimport { ScriptLoader } from './script-loader';\nimport { SetupManager } from './setup-manager';\nimport { NightOrderProcessor } from './night-order-processor';\nimport { ActionSystem } from './action-system';\nimport { ValidationSystem } from './validation-system';\n\nexport class GameEngine {\n  private games: Map<GameId, GameState> = new Map();\n  private events: Map<GameId, Event[]> = new Map();\n  private rulesEngine: RulesEngine;\n  private scriptLoader: ScriptLoader;\n  private setupManager: SetupManager;\n  private nightOrderProcessor: NightOrderProcessor;\n  private actionSystem: ActionSystem;\n  private validationSystem: ValidationSystem;\n  // Ephemeral per-game context not persisted in GameState schema\n  private context: Map<GameId, Record<string, any>> = new Map();\n\n  constructor() {\n    this.rulesEngine = new RulesEngine();\n    this.scriptLoader = new ScriptLoader();\n    this.setupManager = new SetupManager();\n    this.nightOrderProcessor = new NightOrderProcessor(this.scriptLoader);\n    this.actionSystem = new ActionSystem();\n    this.validationSystem = new ValidationSystem();\n  }\n\n  async createGame(scriptId: string = 'trouble-brewing', options?: { isPublic?: boolean }): Promise<GameId> {\n    const gameId = randomUUID() as GameId;\n    const seed = this.generateSeed();\n    \n  const gameState: GameState = {\n      id: gameId,\n      phase: GamePhase.LOBBY,\n      day: 0,\n      seed,\n      scriptId,\n      isPublic: options?.isPublic ?? true,\n      seats: [],\n      abilities: [],\n  storytellerSeatId: undefined as any,\n  availableScriptIds: [],\n  scriptProposals: [],\n  selectedRoles: undefined as any,\n  roleClaims: {} as any,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    // initialize day fields not yet in published type (during dev)\n    (gameState as any).currentNomination = undefined;\n    (gameState as any).currentVote = undefined;\n\n    this.games.set(gameId, gameState);\n    this.events.set(gameId, []);\n  this.context.set(gameId, { hasExecutedToday: false });\n\n    logger.info(`Created game ${gameId} with script ${scriptId}`);\n    \n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'game_created',\n      timestamp: new Date(),\n      payload: { scriptId, seed }\n    });\n\n    return gameId;\n  }\n\n  /** Set a human-friendly game name (host only in lobby) */\n  setGameName(gameId: GameId, storytellerSeatId: SeatId, name: string): { ok: true } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (game.phase !== GamePhase.LOBBY) return { ok: false, error: 'Cannot rename after lobby' };\n    if (!game.storytellerSeatId || game.storytellerSeatId !== storytellerSeatId) return { ok: false, error: 'Only storyteller can set name' };\n    const trimmed = (name || '').trim();\n    if (!trimmed) return { ok: false, error: 'Name required' };\n    if (trimmed.length > 60) return { ok: false, error: 'Name too long' };\n    (game as any).gameName = trimmed;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'chat_message' as any,\n      timestamp: new Date(),\n      payload: { system: true, text: `Game named: ${trimmed}` }\n    });\n    return { ok: true };\n  }\n\n  getGame(gameId: GameId): GameState | undefined {\n    return this.games.get(gameId);\n  }\n\n  getGameEvents(gameId: GameId): Event[] {\n    return this.events.get(gameId) || [];\n  }\n\n  async addPlayer(gameId: GameId, playerId: string, isNPC: boolean = false): Promise<SeatId | null> {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) {\n      return null;\n    }\n\n    // If a non-NPC with the same playerId already exists in the lobby, reuse that seat\n    if (!isNPC) {\n      const existing = game.seats.find(s => !s.isNPC && s.playerId === playerId);\n      if (existing) {\n        logger.info(`Player ${playerId} already in game ${gameId} as seat ${existing.id}, reusing seat`);\n        return existing.id as SeatId;\n      }\n    }\n\n  const seatId = randomUUID() as SeatId;\n    const position = game.seats.length;\n\n    const seat = {\n      id: seatId,\n      playerId: isNPC ? undefined : playerId,\n      isNPC,\n      position,\n      statuses: [],\n      isAlive: true,\n      votingPower: 1\n    } as any;\n\n  // First human player becomes storyteller by default\n    if (!isNPC && !(game as any).storytellerSeatId) {\n      seat.isStoryteller = true;\n      (game as any).storytellerSeatId = seatId;\n    }\n\n    game.seats.push(seat);\n\n    game.updatedAt = new Date();\n\n  this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'player_joined',\n      timestamp: new Date(),\n      actorId: seatId,\n      payload: { playerId, isNPC, position }\n    });\n\n    logger.info(`Player ${playerId} joined game ${gameId} as seat ${seatId}`);\n  return seatId;\n  }\n\n  /** Remove a player from a lobby. Only allowed in LOBBY phase. */\n  removePlayer(gameId: GameId, seatId: SeatId): { ok: true } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (game.phase !== GamePhase.LOBBY) return { ok: false, error: 'Can only leave during lobby' };\n    const index = game.seats.findIndex(s => s.id === seatId);\n    if (index === -1) return { ok: false, error: 'Seat not found' };\n\n    const wasStoryteller = game.storytellerSeatId === seatId;\n    // Remove seat\n    game.seats.splice(index, 1);\n    // Re-number positions\n    game.seats.forEach((s, i) => { (s as any).position = i; });\n    // Reassign storyteller if needed\n    if (wasStoryteller) {\n      const nextHuman = game.seats.find(s => !s.isNPC && !!s.playerId);\n      (game as any).storytellerSeatId = nextHuman ? nextHuman.id : undefined;\n      for (const s of game.seats) (s as any).isStoryteller = nextHuman ? s.id === nextHuman.id : false;\n    }\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'player_left' as any,\n      timestamp: new Date(),\n      actorId: seatId,\n      payload: { seatId }\n    });\n    logger.info(`Seat ${seatId} left game ${gameId}`);\n    return { ok: true };\n  }\n\n  proposeScript(gameId: GameId, proposer: SeatId, scriptId: string, active: boolean = true): string | null {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return null;\n    const proposals = ((game as any).scriptProposals ??= [] as any[]);\n    let proposal = proposals.find((p: any) => p.scriptId === scriptId);\n\n    if (active) {\n      if (!proposal) {\n        proposal = {\n          id: randomUUID(),\n          scriptId,\n          proposers: [proposer],\n          votes: {},\n          difficultyVotes: {},\n          createdAt: new Date()\n        };\n        proposals.push(proposal);\n      } else {\n        proposal.proposers = Array.isArray(proposal.proposers) ? proposal.proposers : [proposal.proposedBy].filter(Boolean);\n        if (!proposal.proposers.includes(proposer)) {\n          proposal.proposers.push(proposer);\n        }\n      }\n      (proposal.votes as Record<string, boolean>)[proposer] = true;\n    } else {\n      if (!proposal) {\n        return null;\n      }\n      proposal.proposers = Array.isArray(proposal.proposers) ? proposal.proposers : [proposal.proposedBy].filter(Boolean);\n      proposal.proposers = proposal.proposers.filter((seat: SeatId) => seat !== proposer);\n      if (proposal.votes) delete proposal.votes[proposer as any];\n      if (proposal.difficultyVotes) delete proposal.difficultyVotes[proposer as any];\n    }\n\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'script_proposed' as any,\n      timestamp: new Date(),\n      actorId: proposer,\n      payload: { scriptId, proposalId: proposal?.id, active }\n    });\n\n    if (proposal) {\n      this.evaluateScriptSelection(game, proposal);\n      this.pruneProposalIfEmpty(game, proposal);\n      return proposal.id;\n    }\n    return null;\n  }\n\n  voteOnScript(gameId: GameId, voterSeat: SeatId, proposalId: string, vote: boolean | null | undefined): boolean {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return false;\n    const proposals = (game as any).scriptProposals ?? [];\n    const proposal = proposals.find((p: any) => p.id === proposalId);\n    if (!proposal) return false;\n\n    proposal.votes = proposal.votes || {};\n    if (vote === null || vote === undefined) {\n      delete proposal.votes[voterSeat as any];\n    } else {\n      (proposal.votes as Record<string, boolean>)[voterSeat as any] = !!vote;\n    }\n\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'script_vote' as any,\n      timestamp: new Date(),\n      actorId: voterSeat,\n      payload: { proposalId, vote }\n    });\n\n    this.evaluateScriptSelection(game, proposal);\n    this.pruneProposalIfEmpty(game, proposal);\n\n    return true;\n  }\n\n  private evaluateScriptSelection(game: GameState, proposal: any) {\n    if (!proposal || !proposal.votes) return;\n    const yes = Object.values(proposal.votes).filter(Boolean).length;\n    const total = game.seats.length;\n    if (yes > total / 2) {\n      if (game.scriptId !== proposal.scriptId) {\n        game.scriptId = proposal.scriptId;\n        this.addEvent(game.id, {\n          id: randomUUID(),\n          gameId: game.id,\n          type: 'script_selected' as any,\n          timestamp: new Date(),\n          payload: { scriptId: proposal.scriptId }\n        });\n      }\n    }\n  }\n\n  private pruneProposalIfEmpty(game: GameState, proposal: any) {\n    const votesCount = proposal?.votes ? Object.keys(proposal.votes).length : 0;\n    const difficultyCount = proposal?.difficultyVotes ? Object.keys(proposal.difficultyVotes).length : 0;\n    const proposerCount = Array.isArray(proposal?.proposers) ? proposal.proposers.length : (proposal?.proposedBy ? 1 : 0);\n    if (proposerCount === 0 && votesCount === 0 && difficultyCount === 0) {\n      const proposals = (game as any).scriptProposals as any[];\n      const idx = proposals.findIndex((p: any) => p.id === proposal.id);\n      if (idx >= 0) {\n        proposals.splice(idx, 1);\n      }\n    }\n  }\n\n  // Difficulty vote (storyteller-only visibility) does not auto-select; it aggregates preferences\n  voteScriptDifficulty(gameId: GameId, voterSeat: SeatId, proposalId: string, difficulty: 'beginner'|'intermediate'|'advanced'): boolean {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return false;\n    const proposal = (game as any).scriptProposals.find((p: any) => p.id === proposalId);\n    if (!proposal) return false;\n    (proposal.difficultyVotes as any)[voterSeat] = difficulty;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'script_vote' as any,\n      timestamp: new Date(),\n      actorId: voterSeat,\n      payload: { proposalId, difficulty }\n    });\n    return true;\n  }\n\n  // Storyteller reassignment\n  setStoryteller(gameId: GameId, setterSeat: SeatId, targetSeat: SeatId): { ok: true } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return { ok: false, error: 'Can only set storyteller in lobby' };\n    if (game.storytellerSeatId !== setterSeat) return { ok: false, error: 'Only current storyteller can assign storyteller' };\n    if (!game.seats.some(s => s.id === targetSeat)) return { ok: false, error: 'Invalid target seat' };\n    (game as any).storytellerSeatId = targetSeat;\n    // Clear old flag, set new if we store isStoryteller on seats\n    for (const s of game.seats) (s as any).isStoryteller = s.id === targetSeat;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'storyteller_changed' as any,\n      timestamp: new Date(),\n      actorId: setterSeat,\n      payload: { storytellerSeatId: targetSeat }\n    });\n    return { ok: true };\n  }\n\n  selectRoles(gameId: GameId, storytellerSeatId: SeatId, roleIds: string[]): boolean {\n    const game = this.games.get(gameId);\n  if (!game || game.phase !== GamePhase.LOBBY) return false;\n  if ((game as any).storytellerSeatId !== storytellerSeatId) return false;\n  (game as any).selectedRoles = roleIds;\n  game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'roles_selected' as any,\n      timestamp: new Date(),\n      actorId: storytellerSeatId,\n      payload: { roleIds }\n    });\n    return true;\n  }\n\n  // Update which scripts the storyteller has made available to players\n  setAvailableScripts(gameId: GameId, storytellerSeatId: SeatId, scriptIds: string[]): boolean {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return false;\n    if ((game as any).storytellerSeatId !== storytellerSeatId) return false;\n    (game as any).availableScriptIds = scriptIds;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'available_scripts_updated' as any,\n      timestamp: new Date(),\n      actorId: storytellerSeatId,\n      payload: { scriptIds }\n    });\n    return true;\n  }\n\n  claimRole(gameId: GameId, seatId: SeatId, roleId: string): boolean {\n  const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return false;\n    // Ensure seat exists\n    if (!game.seats.some(s => s.id === seatId)) return false;\n    // Ensure role available\n  const pool = (game as any).selectedRoles && (game as any).selectedRoles.length > 0 ? (game as any).selectedRoles as string[] : undefined;\n    if (pool && !pool.includes(roleId)) return false;\n    // Ensure not already claimed\n  (game as any).roleClaims = (game as any).roleClaims || {} as any;\n  if (Object.values((game as any).roleClaims as Record<string, string>).includes(roleId)) return false;\n  ((game as any).roleClaims as any)[seatId] = roleId;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'chat_message',\n      timestamp: new Date(),\n      actorId: seatId,\n      payload: { system: true, text: `Seat claimed role ${roleId}` }\n    });\n    return true;\n  }\n\n  listScripts(): Array<{ id: string; name: string; version: string }> {\n    return (this.scriptLoader as any).listScripts();\n  }\n\n  async getScript(scriptId: string) {\n    return this.scriptLoader.loadScript(scriptId);\n  }\n\n  async claimRandomRole(gameId: GameId, seatId: SeatId): Promise<string | null> {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) return null;\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) return null;\n    const pool = ((game as any).selectedRoles && (game as any).selectedRoles.length > 0)\n      ? new Set((game as any).selectedRoles as string[])\n      : new Set(script.roles.map((r: any) => r.id as string));\n    // Remove already claimed\n    if ((game as any).roleClaims) {\n      for (const rid of Object.values((game as any).roleClaims as Record<string, string>)) pool.delete(rid as any);\n    }\n    const remaining = Array.from(pool);\n    if (remaining.length === 0) return null;\n  const pick: string = remaining[Math.floor(Math.random() * remaining.length)] as string;\n  return this.claimRole(gameId, seatId, pick) ? pick : null;\n  }\n\n  async startGame(gameId: GameId): Promise<boolean> {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) {\n      return false;\n    }\n\n    // Transition to setup phase first\n    await this.changePhase(gameId, GamePhase.SETUP);\n    \n    // Initialize setup if not already done\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) {\n      logger.error(`Failed to load script ${game.scriptId}`);\n      return false;\n    }\n\n  await this.setupManager.initializeSetup(game, script);\n\n    const playerCount = game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId).length;\n    logger.info(`Started setup for game ${gameId} with ${playerCount} players`);\n    return true;\n  }\n\n  /**\n   * Storyteller enters setup phase from lobby\n   */\n  async enterSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<{ ok: true } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can enter setup' };\n    if (game.phase !== GamePhase.LOBBY) return { ok: false, error: 'Can only enter setup from lobby' };\n\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) return { ok: false, error: 'Failed to load script' };\n\n    await this.changePhase(gameId, GamePhase.SETUP);\n  await this.setupManager.initializeSetup(game, script);\n\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'phase_changed',\n      timestamp: new Date(),\n      actorId: storytellerSeatId,\n      payload: { oldPhase: GamePhase.LOBBY, newPhase: GamePhase.SETUP }\n    });\n\n    return { ok: true };\n  }\n\n  /**\n   * Storyteller selects characters during setup\n   */\n  async selectSetupCharacters(\n    gameId: GameId, \n    storytellerSeatId: SeatId, \n    characterIds: string[]\n  ): Promise<{ ok: true } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can select characters' };\n    if (game.phase !== GamePhase.SETUP) return { ok: false, error: 'Can only select characters during setup' };\n\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) return { ok: false, error: 'Failed to load script' };\n\n    const result = this.setupManager.selectCharacters(game, script, characterIds, storytellerSeatId);\n    if (!result.success) {\n      return { ok: false, error: result.error! };\n    }\n\n    game.updatedAt = new Date();\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'setup_characters_selected',\n      timestamp: new Date(),\n      actorId: storytellerSeatId,\n      payload: { characterIds }\n    });\n\n    return { ok: true };\n  }\n\n  /**\n   * Validate current setup\n   */\n  async validateSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<{ ok: true } | { ok: false; error: string; details?: string[] }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can validate setup' };\n    if (game.phase !== GamePhase.SETUP) return { ok: false, error: 'Can only validate during setup' };\n\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) return { ok: false, error: 'Failed to load script' };\n\n    const validation = this.setupManager.validateSetup(game, script);\n    \n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'setup_validated',\n      timestamp: new Date(),\n      actorId: storytellerSeatId,\n      payload: { isValid: validation.isValid, errors: validation.errors }\n    });\n\n    if (!validation.isValid) {\n      return { ok: false, error: 'Setup validation failed', details: validation.errors };\n    }\n\n    return { ok: true };\n  }\n\n  /**\n   * Complete setup and start the game (move to Night phase)\n   */\n  async completeSetup(gameId: GameId, storytellerSeatId: SeatId): Promise<{ ok: true } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can complete setup' };\n    if (game.phase !== GamePhase.SETUP) return { ok: false, error: 'Can only complete setup from setup phase' };\n\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) return { ok: false, error: 'Failed to load script' };\n\n    // Complete setup process\n    const setupResult = this.setupManager.completeSetup(game, script);\n    if (!setupResult.success) {\n      return { ok: false, error: setupResult.error! };\n    }\n\n    // Assign roles using the character pool from setup\n    const success = await this.rulesEngine.assignRolesFromSetup(game, script);\n    if (!success) {\n      logger.error(`Failed to assign roles for game ${gameId}`);\n      return { ok: false, error: 'Failed to assign roles' };\n    }\n\n    // Transition to night phase\n    await this.changePhase(gameId, GamePhase.NIGHT);\n    game.day = 1;\n    this.getContext(gameId).hasExecutedToday = false;\n\n    logger.info(`Completed setup and started game ${gameId} with ${game.seats.length} players`);\n    return { ok: true };\n  }\n\n  async startGameOriginal(gameId: GameId): Promise<boolean> {\n    const game = this.games.get(gameId);\n    if (!game || game.phase !== GamePhase.LOBBY) {\n      return false;\n    }\n\n    // Load script and assign roles\n    const script = await this.scriptLoader.loadScript(game.scriptId);\n    if (!script) {\n      logger.error(`Failed to load script ${game.scriptId}`);\n      return false;\n    }\n\n    // Assign roles using rules engine\n    const success = await this.rulesEngine.assignRoles(game, script);\n    if (!success) {\n      logger.error(`Failed to assign roles for game ${gameId}`);\n      return false;\n    }\n\n    // Transition to night phase\n    await this.changePhase(gameId, GamePhase.NIGHT);\n    game.day = 1;\n    this.getContext(gameId).hasExecutedToday = false;\n\n    logger.info(`Started game ${gameId} with ${game.seats.length} players`);\n    return true;\n  }\n\n  /**\n   * Storyteller manual advance to next phase in the standard cycle.\n   */\n  async advancePhase(gameId: GameId, storytellerSeatId: SeatId): Promise<{ ok: true } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can advance phase' };\n    if (game.phase === GamePhase.END) return { ok: false, error: 'Game already ended' };\n\n  const next = this.getNextPhase(game.phase);\n    if (!next) return { ok: false, error: 'No next phase from current phase' };\n\n    // Side-effects around boundaries\n    // After EXECUTION, move to NIGHT and increment day\n    if (game.phase === GamePhase.EXECUTION && next === GamePhase.NIGHT) {\n      game.day += 1;\n      this.getContext(gameId).hasExecutedToday = false;\n    }\n\n  // Validate preconditions before allowing transition\n  const preCheck = this.validatePreconditions(game, next);\n  if (!preCheck.ok) return { ok: false, error: preCheck.error };\n\n  await this.changePhase(gameId, next);\n\n    // Validate after phase change\n    const issues = this.validateGameState(game);\n    if (issues.length > 0) {\n      logger.warn(`Validation issues after phase change: ${issues.join('; ')}`);\n      this.addEvent(gameId, {\n        id: randomUUID(),\n        gameId,\n        type: 'phase_changed',\n        timestamp: new Date(),\n        payload: { oldPhase: game.phase, newPhase: next, validationIssues: issues }\n      });\n    }\n\n    return { ok: true };\n  }\n\n  /**\n   * Storyteller manual set to a specific next phase or END.\n   * Only allows moving to the immediate next phase or to END.\n   */\n  async setPhase(gameId: GameId, storytellerSeatId: SeatId, target: GamePhase): Promise<{ ok: true } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can set phase' };\n    if (game.phase === target) return { ok: true };\n    if (target === GamePhase.LOBBY) return { ok: false, error: 'Cannot return to lobby' };\n\n    const next = this.getNextPhase(game.phase);\n    if (target !== next && target !== GamePhase.END) {\n      return { ok: false, error: `Invalid phase transition ${game.phase} -> ${target}` };\n    }\n\n  if (game.phase === GamePhase.EXECUTION && target === GamePhase.NIGHT) {\n      game.day += 1;\n      this.getContext(gameId).hasExecutedToday = false;\n    }\n\n  // Validate preconditions before allowing transition\n  const preCheck = this.validatePreconditions(game, target);\n  if (!preCheck.ok) return { ok: false, error: preCheck.error };\n\n  await this.changePhase(gameId, target);\n    const issues = this.validateGameState(game);\n    if (issues.length > 0) {\n      logger.warn(`Validation issues after set phase: ${issues.join('; ')}`);\n      this.addEvent(gameId, {\n        id: randomUUID(),\n        gameId,\n        type: 'phase_changed',\n        timestamp: new Date(),\n        payload: { oldPhase: game.phase, newPhase: target, validationIssues: issues }\n      });\n    }\n\n    return { ok: true };\n  }\n\n  /**\n   * End the game immediately (Storyteller only).\n   */\n  async endGame(gameId: GameId, storytellerSeatId: SeatId): Promise<{ ok: true } | { ok: false; error: string }> {\n    return this.setPhase(gameId, storytellerSeatId, GamePhase.END);\n  }\n\n  private async changePhase(gameId: GameId, newPhase: GamePhase): Promise<void> {\n    const game = this.games.get(gameId);\n    if (!game) return;\n\n    const oldPhase = game.phase;\n    game.phase = newPhase;\n    game.updatedAt = new Date();\n\n    this.addEvent(gameId, {\n      id: randomUUID(),\n      gameId,\n      type: 'phase_changed',\n      timestamp: new Date(),\n      payload: { oldPhase, newPhase, day: game.day }\n    });\n  }\n\n  private addEvent(gameId: GameId, event: Event): void {\n    const events = this.events.get(gameId);\n    if (events) {\n      events.push(event);\n    }\n  }\n\n  private generateSeed(): string {\n    return Math.random().toString(36).substring(2, 15);\n  }\n\n  // Get all active games\n  getActiveGames(): GameState[] {\n    return Array.from(this.games.values());\n  }\n\n  // Get only public games that can be joined\n  getPublicGames(): GameState[] {\n    return Array.from(this.games.values()).filter(game => \n      game.isPublic && game.phase === GamePhase.LOBBY\n    );\n  }\n\n  // Cleanup finished games\n  cleanupGame(gameId: GameId): void {\n    this.games.delete(gameId);\n    this.events.delete(gameId);\n    logger.info(`Cleaned up game ${gameId}`);\n  }\n\n  // -------- Helpers: validation & context --------\n\n  private getNextPhase(current: GamePhase): GamePhase | null {\n    switch (current) {\n      case GamePhase.LOBBY:\n        return GamePhase.SETUP;\n      case GamePhase.SETUP:\n        return GamePhase.NIGHT;\n      case GamePhase.NIGHT:\n        return GamePhase.DAY;\n      case GamePhase.DAY:\n        return GamePhase.NOMINATION;\n      case GamePhase.NOMINATION:\n        return GamePhase.VOTE;\n      case GamePhase.VOTE:\n        return GamePhase.EXECUTION;\n      case GamePhase.EXECUTION:\n        return GamePhase.NIGHT;\n      case GamePhase.END:\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  private isStoryteller(game: GameState, seatId?: SeatId): boolean {\n    return !!seatId && game.storytellerSeatId === seatId;\n  }\n\n  private getContext(gameId: GameId): Record<string, any> {\n    if (!this.context.has(gameId)) this.context.set(gameId, {});\n    return this.context.get(gameId)!;\n  }\n\n  /**\n   * Validate critical invariants of the game state.\n   */\n  validateGameState(game: GameState): string[] {\n    const issues: string[] = [];\n    // Unique seat IDs\n    const ids = new Set<string>();\n    for (const s of game.seats) {\n      if (ids.has(s.id)) issues.push(`Duplicate seat id ${s.id}`);\n      ids.add(s.id);\n    }\n    // Storyteller seat (if set) must exist\n    if (game.storytellerSeatId && !game.seats.some(s => s.id === game.storytellerSeatId)) {\n      issues.push('storytellerSeatId does not match any seat');\n    }\n    // Day number non-negative\n    if (game.day < 0) issues.push('day must be >= 0');\n    // Roles assigned after lobby\n    if (game.phase !== GamePhase.LOBBY) {\n      const unassigned = game.seats.filter(s => !s.role || !s.alignment);\n      if (unassigned.length > 0) issues.push(`unassigned roles for ${unassigned.length} seat(s)`);\n    }\n    return issues;\n  }\n\n  /**\n   * Phase preconditions validation for transitions.\n   */\n  private validatePreconditions(game: GameState, target: GamePhase): { ok: true } | { ok: false; error: string } {\n    // From Lobby -> Setup: ensure storyteller is assigned\n    if (target === GamePhase.SETUP) {\n      if (game.phase !== GamePhase.LOBBY) return { ok: false, error: 'Can only enter setup from lobby' };\n      if (!game.storytellerSeatId) return { ok: false, error: 'Storyteller must be assigned before setup' };\n    }\n    \n    // From Setup -> Night: ensure setup is completed and validated\n    if (target === GamePhase.NIGHT) {\n      if (game.phase === GamePhase.SETUP) {\n        if (!game.setupState || !game.setupState.isValidated) {\n          return { ok: false, error: 'Setup must be validated before starting game' };\n        }\n        if (!game.setupState.characterPool || game.setupState.characterPool.length === 0) {\n          return { ok: false, error: 'Character pool must be created before starting game' };\n        }\n      }\n    }\n\n    // From Day -> Nomination: ensure no ongoing vote; clear last nomination if closed\n    if (target === GamePhase.NOMINATION) {\n      if (game.phase !== GamePhase.DAY) return { ok: false, error: 'Can only nominate during Day' };\n      if ((game as any).currentVote && !(game as any).currentVote.finished) return { ok: false, error: 'Cannot move to nomination while a vote is active' };\n    }\n    // From Nomination -> Vote: must have a current nomination\n    if (target === GamePhase.VOTE) {\n      if (!(game as any).currentNomination || (game as any).currentNomination.closed) return { ok: false, error: 'No open nomination to vote on' };\n    }\n    // From Vote -> Execution: must have a finished vote\n    if (target === GamePhase.EXECUTION) {\n      if (!(game as any).currentVote || !(game as any).currentVote.finished) return { ok: false, error: 'No finished vote to execute' };\n    }\n    // From Execution -> Night: ok; cleanup day artifacts\n    if (target === GamePhase.NIGHT && game.phase === GamePhase.EXECUTION) {\n      (game as any).currentNomination = undefined;\n      (game as any).currentVote = undefined;\n    }\n    return { ok: true };\n  }\n\n  // ------- Day mechanics: nomination & voting -------\n\n  nominate(gameId: GameId, nominator: SeatId, nominee: SeatId): { ok: true; nominationId: string } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (game.phase !== GamePhase.NOMINATION && game.phase !== GamePhase.DAY) return { ok: false, error: 'Not in nomination phase' };\n    if (!game.seats.some(s => s.id === nominator) || !game.seats.some(s => s.id === nominee)) return { ok: false, error: 'Invalid seats' };\n    if (!game.seats.find(s => s.id === nominator)?.isAlive) return { ok: false, error: 'Nominator is dead' };\n    if (!game.seats.find(s => s.id === nominee)?.isAlive) return { ok: false, error: 'Nominee is dead' };\n    // Only one open nomination at a time\n  if ((game as any).currentNomination && !(game as any).currentNomination.closed) return { ok: false, error: 'Nomination already open' };\n\n    const nominationId = randomUUID();\n  (game as any).currentNomination = { id: nominationId, nominator, nominee, createdAt: new Date(), closed: false } as any;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, { id: randomUUID(), gameId, type: 'nomination_made' as any, timestamp: new Date(), actorId: nominator, payload: { nominee } });\n    return { ok: true, nominationId };\n  }\n\n  startVote(gameId: GameId, storytellerSeatId: SeatId): { ok: true } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can start vote' };\n    if (game.phase !== GamePhase.VOTE) return { ok: false, error: 'Not in vote phase' };\n  if (!(game as any).currentNomination || (game as any).currentNomination.closed) return { ok: false, error: 'No open nomination' };\n  if ((game as any).currentVote && !(game as any).currentVote.finished) return { ok: false, error: 'Vote already in progress' };\n\n  (game as any).currentNomination.closed = true as any;\n  (game as any).currentVote = { nominationId: (game as any).currentNomination.id, startedAt: new Date(), votes: [], tally: { yes: 0, no: 0 }, finished: false } as any;\n    game.updatedAt = new Date();\n    this.addEvent(gameId, { id: randomUUID(), gameId, type: 'vote_cast', timestamp: new Date(), payload: { started: true } });\n    return { ok: true };\n  }\n\n  castVote(gameId: GameId, voter: SeatId, vote: boolean): { ok: true } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (game.phase !== GamePhase.VOTE) return { ok: false, error: 'Not in vote phase' };\n  if (!(game as any).currentVote || (game as any).currentVote.finished) return { ok: false, error: 'No active vote' };\n    const seat = game.seats.find(s => s.id === voter);\n    if (!seat || !seat.isAlive) return { ok: false, error: 'Invalid voter' };\n\n    // Prevent duplicate votes\n  if ((game as any).currentVote.votes.some((v: any) => v.voter === voter)) return { ok: false, error: 'Already voted' };\n  (game as any).currentVote.votes.push({ voter, vote, timestamp: new Date() } as any);\n  if (vote) (game as any).currentVote.tally.yes += seat.votingPower; else (game as any).currentVote.tally.no += seat.votingPower;\n    this.addEvent(gameId, { id: randomUUID(), gameId, type: 'vote_cast', timestamp: new Date(), actorId: voter, payload: { vote } });\n    game.updatedAt = new Date();\n    return { ok: true };\n  }\n\n  finishVote(gameId: GameId, storytellerSeatId: SeatId): { ok: true; executed: boolean; nominee?: SeatId } | { ok: false; error: string } {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' } as any;\n    if (!this.isStoryteller(game, storytellerSeatId)) return { ok: false, error: 'Only storyteller can finish vote' } as any;\n    if (game.phase !== GamePhase.VOTE) return { ok: false, error: 'Not in vote phase' } as any;\n    if (!(game as any).currentVote || !(game as any).currentNomination || (game as any).currentVote.finished) return { ok: false, error: 'No active vote' } as any;\n\n    (game as any).currentVote.finished = true as any;\n    const executed = (game as any).currentVote.tally.yes > (game as any).currentVote.tally.no;\n    if (executed) {\n      const nomineeSeat = game.seats.find(s => s.id === (game as any).currentNomination!.nominee);\n      if (nomineeSeat) nomineeSeat.isAlive = false;\n      this.addEvent(gameId, { id: randomUUID(), gameId, type: 'execution_occurred', timestamp: new Date(), payload: { seatId: nomineeSeat?.id, tally: (game as any).currentVote.tally } });\n      this.getContext(gameId).hasExecutedToday = true;\n    }\n    game.updatedAt = new Date();\n    return { ok: true, executed, nominee: (game as any).currentNomination.nominee } as any;\n  }\n\n  // === New Action System Methods ===\n\n  /**\n   * Execute the night order for a game\n   */\n  async executeNightOrder(gameId: GameId, isFirstNight: boolean = false): Promise<{ ok: true; results: any[] } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n    if (game.phase !== GamePhase.NIGHT) return { ok: false, error: 'Not in night phase' };\n\n    try {\n      const { results, events } = await this.nightOrderProcessor.executeNightOrder(game, isFirstNight);\n      \n      // Add events to game\n      events.forEach(event => this.addEvent(gameId, event));\n      \n      game.updatedAt = new Date();\n      return { ok: true, results };\n    } catch (error) {\n      logger.error(`Failed to execute night order for game ${gameId}:`, error);\n      return { ok: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n\n  /**\n   * Get the night order preview for a game\n   */\n  async getNightOrderPreview(gameId: GameId, isFirstNight: boolean = false): Promise<any[] | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      return await this.nightOrderProcessor.previewNightOrder(game, isFirstNight);\n    } catch (error) {\n      logger.error(`Failed to get night order preview for game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get active characters for the current night phase\n   */\n  async getActiveCharacters(gameId: GameId, isFirstNight: boolean = false): Promise<any[] | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      return await this.nightOrderProcessor.getActiveCharacters(game, isFirstNight);\n    } catch (error) {\n      logger.error(`Failed to get active characters for game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate the script used by a game\n   */\n  async validateGameScript(gameId: GameId): Promise<any | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      return await this.scriptLoader.validateScript(game.scriptId);\n    } catch (error) {\n      logger.error(`Failed to validate script for game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get character actions for a specific character in the game\n   */\n  async getCharacterActions(gameId: GameId, characterId: string, phase: 'firstNight' | 'otherNights' | 'day'): Promise<any[] | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      return await this.scriptLoader.getCharacterActions(game.scriptId, characterId, phase);\n    } catch (error) {\n      logger.error(`Failed to get character actions for ${characterId} in game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get meta actions for the script\n   */\n  async getMetaActions(gameId: GameId): Promise<any[] | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      return await this.scriptLoader.getMetaActions(game.scriptId);\n    } catch (error) {\n      logger.error(`Failed to get meta actions for game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Generate a validation report for the game's script\n   */\n  async generateValidationReport(gameId: GameId): Promise<string | null> {\n    const game = this.games.get(gameId);\n    if (!game) return null;\n\n    try {\n      const validationResult = await this.scriptLoader.validateScript(game.scriptId);\n      return this.validationSystem.generateReport(validationResult);\n    } catch (error) {\n      logger.error(`Failed to generate validation report for game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Test action execution for development/debugging\n   */\n  async testActionExecution(gameId: GameId): Promise<{ ok: true; tests: any[] } | { ok: false; error: string }> {\n    const game = this.games.get(gameId);\n    if (!game) return { ok: false, error: 'Game not found' };\n\n    try {\n      const tests = [];\n      \n      // Test meta actions\n      const metaActions = await this.scriptLoader.getMetaActions(game.scriptId);\n      for (const metaAction of metaActions) {\n        try {\n          const context = {\n            gameId: game.id,\n            phase: game.phase,\n            day: game.day\n          };\n          const result = await this.actionSystem.executeMetaAction(metaAction, context, game);\n          tests.push({\n            type: 'meta',\n            actionId: metaAction.id,\n            success: result.success,\n            errors: result.errors\n          });\n        } catch (error) {\n          tests.push({\n            type: 'meta',\n            actionId: metaAction.id,\n            success: false,\n            errors: [error instanceof Error ? error.message : 'Unknown error']\n          });\n        }\n      }\n\n      // Test character actions for characters in play\n      for (const seat of game.seats) {\n        if (seat.role && seat.isAlive) {\n          const loadedScript = await this.scriptLoader.getLoadedScript(game.scriptId);\n          const character = loadedScript?.characters.find(c => c.id === seat.role);\n          \n          if (character?.actions?.firstNight) {\n            for (const action of character.actions.firstNight) {\n              try {\n                const context = {\n                  gameId: game.id,\n                  phase: game.phase,\n                  day: game.day,\n                  acting: seat.id\n                };\n                const result = await this.actionSystem.executeCharacterAction(action, context, game, character, seat);\n                tests.push({\n                  type: 'character',\n                  characterId: character.id,\n                  actionId: action.id,\n                  success: result.success,\n                  errors: result.errors\n                });\n              } catch (error) {\n                tests.push({\n                  type: 'character',\n                  characterId: character.id,\n                  actionId: action.id,\n                  success: false,\n                  errors: [error instanceof Error ? error.message : 'Unknown error']\n                });\n              }\n            }\n          }\n        }\n      }\n\n      return { ok: true, tests };\n    } catch (error) {\n      logger.error(`Failed to test action execution for game ${gameId}:`, error);\n      return { ok: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/importer.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 18,
        "column": 35,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { promises as fs } from 'fs';\nimport path from 'path';\nimport {\n  Script,\n  RoleDefinition,\n  Alignment,\n  RoleType,\n  ScrapedCharactersFileSchema,\n  ScrapedTownsFileSchema,\n  toAlignment,\n  toRoleType\n} from '@botc/shared';\nimport { logger } from '../utils/logger';\n\n// Minimal effect mapping: we don't encode full DSL from ability text yet.\n// We derive timing and precedence where available; fallback to passive/no-op effect.\n\nfunction buildRoleDefinition(input: {\n  id: string;\n  name: string;\n  category: 'Townsfolk' | 'Outsider' | 'Minion' | 'Demon' | 'Traveller' | 'Fabled';\n  abilitySummary: string;\n  firstNightAction?: string | null;\n  otherNightsAction?: string | null;\n  dayAction?: string | null;\n}): RoleDefinition | null {\n  const roleType = toRoleType(input.category);\n  if (!roleType) return null; // skip unsupported types for now\n\n  const alignment = toAlignment(input.category);\n\n  // Infer timing from available actions\n  let timing: 'night' | 'day' | 'passive' = 'passive';\n  if (input.firstNightAction || input.otherNightsAction) {\n    timing = 'night';\n  } else if (input.dayAction) {\n    timing = 'day';\n  }\n\n  // precedence: default by role type (can be refined later)\n  const precedence = defaultPrecedence(roleType);\n\n  const rd: RoleDefinition = {\n    id: input.id,\n    name: input.name,\n    alignment,\n    type: roleType,\n    ability: {\n      id: `${input.id}-ability`,\n      when: timing,\n      target: 'any',\n      effect: [\n        {\n          type: 'rules_text',\n          text: input.abilitySummary\n        }\n      ]\n    },\n    visibility: {\n      reveals: {\n        public: 'none',\n        privateTo: []\n      }\n    },\n    precedence\n  };\n\n  return rd;\n}\n\nfunction defaultPrecedence(type: typeof RoleType[keyof typeof RoleType]): number {\n  switch (type) {\n    case RoleType.TOWNSFOLK:\n      return 100;\n    case RoleType.OUTSIDER:\n      return 200;\n    case RoleType.MINION:\n      return 300;\n    case RoleType.DEMON:\n      return 400;\n    case RoleType.TRAVELLER:\n      return 500;\n    case RoleType.FABLED:\n      return 600;\n    default:\n      return 999;\n  }\n}\n\nfunction inferTimingFromType(type: typeof RoleType[keyof typeof RoleType]): 'night' | 'day' | 'passive' {\n  // weak heuristic: many townsfolk act at night; outsiders mostly passive; minions/demons at night\n  switch (type) {\n    case RoleType.TOWNSFOLK:\n      return 'night';\n    case RoleType.OUTSIDER:\n      return 'passive';\n    case RoleType.MINION:\n      return 'night';\n    case RoleType.DEMON:\n      return 'night';\n    case RoleType.TRAVELLER:\n      return 'day';\n    case RoleType.FABLED:\n      return 'passive';\n    default:\n      return 'passive';\n  }\n}\n\nexport async function importWikiData(\n  charactersJsonPath: string,\n  townsJsonPath: string,\n  outDir: string\n): Promise<void> {\n  const [charsRaw, townsRaw] = await Promise.all([\n    fs.readFile(charactersJsonPath, 'utf8'),\n    fs.readFile(townsJsonPath, 'utf8')\n  ]);\n\n  const charsParsed = JSON.parse(charsRaw);\n  const townsParsed = JSON.parse(townsRaw);\n\n  const characters = ScrapedCharactersFileSchema.parse(charsParsed).characters;\n  const towns = ScrapedTownsFileSchema.parse(townsParsed).towns;\n\n  // group characters by edition\n  const byEdition = new Map<string, ReturnType<typeof buildRoleDefinition>[]>();\n  for (const ch of characters) {\n    const rd = buildRoleDefinition(ch);\n    if (!rd) continue; // skip unsupported types\n    \n    // Character can appear in multiple editions\n    for (const editionId of ch.edition) {\n      if (!byEdition.has(editionId)) byEdition.set(editionId, []);\n      byEdition.get(editionId)!.push(rd);\n    }\n  }\n\n  await fs.mkdir(outDir, { recursive: true });\n\n  // For each town/edition, produce a Script JSON file\n  for (const town of towns) {\n    const roles: RoleDefinition[] = (byEdition.get(town.id) ?? []) as RoleDefinition[];\n\n    // Basic setup range; adjust if distribution provided\n    const setup = {\n      playerCount: { min: 5, max: 15 },\n      distribution: {\n        [RoleType.TOWNSFOLK]: 0,\n        [RoleType.OUTSIDER]: 0,\n        [RoleType.MINION]: 0,\n        [RoleType.DEMON]: 1\n  } as Record<typeof RoleType[keyof typeof RoleType], number>\n    };\n\n    const script: Script = {\n      id: town.id,\n      name: town.name,\n      version: 'from-wiki-1',\n      roles,\n      setup\n    };\n\n    const file = path.join(outDir, `${town.id}.script.json`);\n    await fs.writeFile(file, JSON.stringify(script, null, 2), 'utf8');\n  }\n\n  logger.info(`Imported ${byEdition.size} scripts to ${outDir}`);\n}\n\n// CLI\nif (require.main === module) {\n  const [charactersJsonPath, townsJsonPath, outDir] = process.argv.slice(2);\n  if (!charactersJsonPath || !townsJsonPath || !outDir) {\n    // eslint-disable-next-line no-console\n    console.error('Usage: ts-node src/game/importer.ts <characters.json> <towns.json> <outDir>');\n    process.exit(1);\n  }\n  importWikiData(charactersJsonPath, townsJsonPath, outDir).catch((e) => {\n    logger.error('Import failed', e);\n    process.exit(1);\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/lineup-resolver.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token Counts",
        "line": 3,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { LoadedScript, Character, RoleType } from '@botc/shared';\n\ntype Counts = { townsfolk: number; outsiders: number; minions: number; demons: number };\n\nconst TEAM_TO_COUNTKEY: Record<string, keyof Counts> = {\n  townsfolk: 'townsfolk',\n  outsider: 'outsiders',\n  minion: 'minions',\n  demon: 'demons'\n};\n\nconst COUNTKEY_TO_TEAM: Record<keyof Counts, string> = {\n  townsfolk: 'townsfolk',\n  outsiders: 'outsider',\n  minions: 'minion',\n  demons: 'demon'\n};\n\nfunction teamOf(id: string, characters: Character[]): string | undefined {\n  return characters.find(c => c.id === id)?.team;\n}\n\nfunction summarizeCounts(ids: string[], characters: Character[]): Counts {\n  const counts: Counts = { townsfolk: 0, outsiders: 0, minions: 0, demons: 0 };\n  for (const id of ids) {\n    const t = teamOf(id, characters);\n    const key = t ? TEAM_TO_COUNTKEY[t] : undefined;\n    if (key) counts[key]!++;\n  }\n  return counts;\n}\n\nfunction parseCompositionTarget(script: any, playerCount: number) {\n  const comp = script.composition || {};\n  const keys = Object.keys(comp);\n  if (keys.length === 0) return null;\n  if (comp[String(playerCount)]) return comp[String(playerCount)];\n  for (const k of keys) {\n    if (k.includes('-')) {\n      const [a, b] = k.split('-').map((x: string) => parseInt(x, 10));\n      if (Number.isFinite(a) && Number.isFinite(b) && playerCount >= a && playerCount <= b) return comp[k];\n    }\n  }\n  return null;\n}\n\nfunction evalCountExpr(expr: number | string, players: number): number {\n  if (typeof expr === 'number') return expr;\n  if (typeof expr === 'string') {\n    const m = expr.match(/^p\\s*([-+])\\s*(\\d+)$/i);\n    if (m) {\n      const n = parseInt(m[2], 10);\n      return m[1] === '-' ? players - n : players + n;\n    }\n    const asNum = Number(expr);\n    if (Number.isFinite(asNum)) return asNum as number;\n  }\n  return 0;\n}\n\nfunction seedToTarget(selection: string[], targetCounts: Counts, pool: string[], characters: Character[]) {\n  const notes: string[] = [];\n  const result = new Set(selection);\n  const counts = summarizeCounts([...result], characters);\n  (['townsfolk','outsiders','minions','demons'] as (keyof Counts)[]).forEach(teamKey => {\n    const singular = COUNTKEY_TO_TEAM[teamKey];\n    while ((counts[teamKey] || 0) < (targetCounts[teamKey] || 0)) {\n      const candidate = pool.find(id => teamOf(id, characters) === singular && !result.has(id));\n      if (!candidate) break;\n      result.add(candidate);\n      counts[teamKey]!++;\n      notes.push(`seed: added '${candidate}' to reach base ${teamKey}`);\n    }\n  });\n  return { selection: [...result], notes };\n}\n\nexport interface ResolveInput { script: LoadedScript; playerCount: number; selected?: string[] }\nexport interface ResolveOutput { selection: string[]; counts: Counts; notes: string[] }\n\nexport function resolveLineup({ script, playerCount, selected }: ResolveInput): ResolveOutput {\n  const pool: string[] = (script.meta?.characterList as any) || ((script as any).characters?.map((c: Character) => c.id) as string[]) || [];\n  const characters: Character[] = (script as any).characters || [];\n  let selection = (selected || []).filter(id => pool.includes(id));\n  const notes: string[] = [];\n\n  const comp = parseCompositionTarget((script as any), playerCount);\n  if (comp) {\n    const baseTarget: Counts = {\n      townsfolk: evalCountExpr(comp.townsfolk, playerCount),\n      outsiders: evalCountExpr(comp.outsiders, playerCount),\n      minions: evalCountExpr(comp.minions, playerCount),\n      demons: evalCountExpr(comp.demons, playerCount)\n    } as Counts;\n    const res = seedToTarget(selection, baseTarget, pool, characters);\n    selection = res.selection; notes.push(...res.notes);\n  }\n\n  // Note: server-side modifiers not yet ported; rely on validate in SetupManager for now\n  const counts = summarizeCounts(selection, characters);\n  return { selection, counts, notes };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/night-order-processor.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token scriptLoader",
        "line": 21,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { \n  GameState, \n  SeatId, \n  Character, \n  NightOrderEntry, \n  MetaAction, \n  CharacterAction,\n  ActionContext,\n  ActionResult\n} from '@botc/shared';\nimport { randomUUID } from 'crypto';\nimport { logger } from '../utils/logger';\nimport { ScriptLoader } from './script-loader';\nimport { ActionSystem } from './action-system';\n\n/**\n * Processes night order using structured action metadata\n * Handles both meta actions and character actions in proper sequence\n */\nexport class NightOrderProcessor {\n  private scriptLoader: ScriptLoader;\n  private actionSystem: ActionSystem;\n\n  constructor(scriptLoader: ScriptLoader) {\n    this.scriptLoader = scriptLoader;\n    this.actionSystem = new ActionSystem();\n  }\n\n  /**\n   * Execute the full night order for a game\n   */\n  async executeNightOrder(\n    game: GameState, \n    isFirstNight: boolean = false\n  ): Promise<{ results: ActionResult[], events: any[] }> {\n    logger.info(`Executing ${isFirstNight ? 'first' : 'other'} night order for game ${game.id}`);\n\n    const nightOrder = await this.scriptLoader.getNightOrder(game.scriptId, isFirstNight);\n    const results: ActionResult[] = [];\n    const events: any[] = [];\n\n    const context: ActionContext = {\n      gameId: game.id,\n      phase: game.phase,\n      day: game.day\n    };\n\n    for (let i = 0; i < nightOrder.length; i++) {\n      const entry = nightOrder[i];\n      logger.debug(`Processing night order entry ${i}: ${typeof entry === 'string' ? entry : entry.id}`);\n\n      try {\n        if (typeof entry === 'string') {\n          // Character action\n          const result = await this.executeCharacterNightAction(entry, game, context, isFirstNight);\n          if (result) {\n            results.push(result);\n            events.push(...this.createEventsFromResult(result, game.id));\n          }\n        } else {\n          // Meta action\n          const result = await this.executeMetaAction(entry, game, context);\n          results.push(result);\n          events.push(...this.createEventsFromResult(result, game.id));\n        }\n      } catch (error) {\n        logger.error(`Error processing night order entry ${i}:`, error);\n        results.push({\n          actionId: typeof entry === 'string' ? entry : entry.id,\n          success: false,\n          errors: [error instanceof Error ? error.message : 'Unknown error']\n        });\n      }\n    }\n\n    return { results, events };\n  }\n\n  /**\n   * Execute a specific character's night action\n   */\n  private async executeCharacterNightAction(\n    characterId: string,\n    game: GameState,\n    context: ActionContext,\n    isFirstNight: boolean\n  ): Promise<ActionResult | null> {\n    // Find the seat with this character\n    const seat = game.seats.find(s => s.role === characterId);\n    if (!seat) {\n      logger.debug(`Character ${characterId} not in play, skipping`);\n      return null;\n    }\n\n    if (!seat.isAlive) {\n      logger.debug(`Character ${characterId} is dead, skipping`);\n      return null;\n    }\n\n    // Get character data and actions\n    const loadedScript = await this.scriptLoader.getLoadedScript(game.scriptId);\n    if (!loadedScript) {\n      throw new Error(`Script ${game.scriptId} not found`);\n    }\n\n    const character = loadedScript.characters.find(c => c.id === characterId);\n    if (!character) {\n      throw new Error(`Character ${characterId} not found in script`);\n    }\n\n    // Get the appropriate actions for this phase\n    const phase = isFirstNight ? 'firstNight' : 'otherNights';\n  const phaseKey = phase === 'otherNights' ? 'night' : phase;\n  const actions = character.actions?.[phaseKey] || [];\n\n    if (actions.length === 0) {\n      logger.debug(`Character ${characterId} has no ${phase} actions`);\n      return null;\n    }\n\n    // For now, execute the first action. In a full implementation,\n    // you might need to handle multiple actions or let the storyteller choose\n    const action = actions[0];\n    \n    const actionContext: ActionContext = {\n      ...context,\n      acting: seat.id,\n      metadata: {\n        characterId,\n        phase,\n        isFirstNight\n      }\n    };\n\n    return this.actionSystem.executeCharacterAction(action, actionContext, game, character, seat);\n  }\n\n  /**\n   * Execute a meta action\n   */\n  private async executeMetaAction(\n    metaAction: MetaAction,\n    game: GameState,\n    context: ActionContext\n  ): Promise<ActionResult> {\n    const actionContext: ActionContext = {\n      ...context,\n      metadata: {\n        metaAction: true,\n        actionType: metaAction.action\n      }\n    };\n\n    return this.actionSystem.executeMetaAction(metaAction, actionContext, game);\n  }\n\n  /**\n   * Get the processed night order for display/debugging\n   */\n  async getProcessedNightOrder(\n    game: GameState,\n    isFirstNight: boolean = false\n  ): Promise<Array<{ type: 'character' | 'meta', id: string, description: string, inPlay: boolean }>> {\n    const nightOrder = await this.scriptLoader.getNightOrder(game.scriptId, isFirstNight);\n    const processed = [];\n\n    for (const entry of nightOrder) {\n      if (typeof entry === 'string') {\n        // Character entry\n        const seat = game.seats.find(s => s.role === entry);\n        const isInPlay = seat !== undefined;\n        \n        processed.push({\n          type: 'character' as const,\n          id: entry,\n          description: `${entry}${seat ? ` (${seat.playerId || 'NPC'})` : ' (not in play)'}`,\n          inPlay: isInPlay\n        });\n      } else {\n        // Meta action entry\n        processed.push({\n          type: 'meta' as const,\n          id: entry.id,\n          description: entry.description,\n          inPlay: true // Meta actions always apply\n        });\n      }\n    }\n\n    return processed;\n  }\n\n  /**\n   * Check which characters would act during a night phase\n   */\n  async getActiveCharacters(\n    game: GameState,\n    isFirstNight: boolean = false\n  ): Promise<Array<{ characterId: string, seatId: SeatId, playerId?: string, actions: CharacterAction[] }>> {\n    const nightOrder = await this.scriptLoader.getNightOrder(game.scriptId, isFirstNight);\n    const activeCharacters = [];\n    const phase = isFirstNight ? 'firstNight' : 'otherNights';\n\n    for (const entry of nightOrder) {\n      if (typeof entry === 'string') {\n        const characterId = entry;\n        const seat = game.seats.find(s => s.role === characterId && s.isAlive);\n        \n        if (seat) {\n          const actions = await this.scriptLoader.getCharacterActions(game.scriptId, characterId, phase);\n          if (actions.length > 0) {\n            activeCharacters.push({\n              characterId,\n              seatId: seat.id,\n              playerId: seat.playerId,\n              actions\n            });\n          }\n        }\n      }\n    }\n\n    return activeCharacters;\n  }\n\n  /**\n   * Preview what would happen during night execution\n   */\n  async previewNightOrder(\n    game: GameState,\n    isFirstNight: boolean = false\n  ): Promise<Array<{ step: number, type: 'character' | 'meta', id: string, description: string, willExecute: boolean, reason?: string }>> {\n    const nightOrder = await this.scriptLoader.getNightOrder(game.scriptId, isFirstNight);\n    const preview = [];\n\n    for (let i = 0; i < nightOrder.length; i++) {\n      const entry = nightOrder[i];\n      \n      if (typeof entry === 'string') {\n        const characterId = entry;\n        const seat = game.seats.find(s => s.role === characterId);\n        const willExecute = seat !== undefined && seat.isAlive;\n        \n        let reason;\n        if (!seat) {\n          reason = 'Character not in play';\n        } else if (!seat.isAlive) {\n          reason = 'Character is dead';\n        }\n\n        preview.push({\n          step: i + 1,\n          type: 'character' as const,\n          id: characterId,\n          description: `${characterId} wakes up`,\n          willExecute,\n          reason\n        });\n      } else {\n        preview.push({\n          step: i + 1,\n          type: 'meta' as const,\n          id: entry.id,\n          description: entry.description,\n          willExecute: true\n        });\n      }\n    }\n\n    return preview;\n  }\n\n  /**\n   * Create events from action results\n   */\n  private createEventsFromResult(result: ActionResult, gameId: string): any[] {\n    const events = [];\n\n    if (result.success) {\n      events.push({\n        id: randomUUID(),\n        gameId,\n        type: 'ability_used',\n        timestamp: new Date(),\n        payload: {\n          actionId: result.actionId,\n          information: result.information\n        }\n      });\n    } else {\n      events.push({\n        id: randomUUID(),\n        gameId,\n        type: 'action_failed',\n        timestamp: new Date(),\n        payload: {\n          actionId: result.actionId,\n          errors: result.errors\n        }\n      });\n    }\n\n    return events;\n  }\n\n  /**\n   * Execute a single action for testing/manual execution\n   */\n  async executeAction(\n    game: GameState,\n    actionId: string,\n    actingSeatId?: SeatId,\n    targets?: SeatId[]\n  ): Promise<ActionResult> {\n    const context: ActionContext = {\n      gameId: game.id,\n      phase: game.phase,\n      day: game.day,\n      acting: actingSeatId,\n      targets\n    };\n\n    // This would need to find the action by ID and execute it\n    // Implementation depends on how actions are indexed/stored\n    throw new Error('Single action execution not yet implemented');\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/rules.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 6,
        "column": 34,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, Script, Alignment, RoleType } from '@botc/shared';\nimport { logger } from '../utils/logger';\n\nexport class RulesEngine {\n  \n  async assignRolesFromSetup(game: GameState, script: Script): Promise<boolean> {\n    try {\n      if (!game.setupState || !game.setupState.characterPool) {\n        logger.error('No character pool available from setup');\n        return false;\n      }\n\n      // Count players excluding storyteller\n      const playerSeats = game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId);\n      const playerCount = playerSeats.length;\n      const characterPool = [...game.setupState.characterPool];\n      \n      if (characterPool.length !== playerCount) {\n        logger.error(`Character pool size ${characterPool.length} does not match player count ${playerCount}`);\n        return false;\n      }\n\n      // Shuffle the character pool for random assignment\n      this.shuffleArray(characterPool);\n\n      // Create role map for lookups\n      const roleMap = new Map(script.roles.map(r => [r.id, r] as const));\n\n      // Assign roles to player seats only (exclude storyteller)\n      for (let i = 0; i < playerSeats.length; i++) {\n        const seat = playerSeats[i];\n        const roleId = characterPool[i];\n        const role = roleMap.get(roleId);\n        \n        if (!role) {\n          logger.error(`Role ${roleId} not found in script`);\n          return false;\n        }\n\n        seat.role = roleId;\n        seat.alignment = role.alignment;\n      }\n\n      // Update grimoire positions\n      if (game.grimoireState) {\n        game.grimoireState.characterPositions = {};\n        for (const seat of game.seats) {\n          if (seat.role) {\n            game.grimoireState.characterPositions[seat.id] = seat.role;\n          }\n        }\n      }\n\n      logger.info(`Assigned roles from setup for game ${game.id}: ${characterPool.join(', ')}`);\n      return true;\n    } catch (error) {\n      logger.error(`Failed to assign roles from setup for game ${game.id}:`, error);\n      return false;\n    }\n  }\n\n  async assignRoles(game: GameState, script: Script): Promise<boolean> {\n    try {\n      // Count players excluding storyteller\n      const playerSeats = game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId);\n      const playerCount = playerSeats.length;\n      \n      // Validate player count\n      if (playerCount < script.setup.playerCount.min || playerCount > script.setup.playerCount.max) {\n        logger.error(`Invalid player count ${playerCount} for script ${script.id}`);\n        return false;\n      }\n\n      // Calculate role distribution based on player count\n      const distribution = this.calculateDistribution(playerCount, script);\n      \n      // Get available roles by type (respect storyteller selection if provided)\n  const rolesByType = this.groupRolesByType(script, (game as any).selectedRoles);\n      const roleMap = new Map(script.roles.map(r => [r.id, r] as const));\n      \n      // Pre-assign claimed roles if any (only for player seats)\n  const preAssignments: Array<{ roleId: string; alignment: typeof Alignment[keyof typeof Alignment] } | undefined> = new Array(game.seats.length).fill(undefined);\n      if ((game as any).roleClaims) {\n        for (const [seatId, roleId] of Object.entries((game as any).roleClaims as Record<string, string>)) {\n          const seatIndex = game.seats.findIndex(s => s.id === (seatId as any));\n          const role = roleMap.get(roleId as string);\n          if (seatIndex >= 0 && role && seatId !== (game as any).storytellerSeatId) {\n            // Remove from pools and adjust distribution\n            const type = role.type;\n            const list = rolesByType[type];\n            const i = list.indexOf(roleId as string);\n            if (i >= 0) list.splice(i, 1);\n            if (distribution[type] > 0) distribution[type] -= 1;\n            preAssignments[seatIndex] = { roleId: roleId as string, alignment: role.alignment };\n          }\n        }\n      }\n      \n      // Assign remaining roles to player seats only\n      const assignments = this.assignRolesRandomly(playerSeats, rolesByType, distribution, preAssignments.filter((_, idx) => {\n        const seat = game.seats[idx];\n        return seat && seat.id !== (game as any).storytellerSeatId;\n      }), roleMap);\n      \n      // Apply assignments to game state (only to player seats)\n      let assignmentIndex = 0;\n      for (let i = 0; i < game.seats.length; i++) {\n        const seat = game.seats[i];\n        if (seat.id === (game as any).storytellerSeatId) continue; // Skip storyteller\n        \n        const assignment = assignments[assignmentIndex];\n        seat.role = assignment.roleId;\n        seat.alignment = assignment.alignment;\n        assignmentIndex++;\n      }\n\n      logger.info(`Assigned roles for game ${game.id}: ${JSON.stringify(assignments)}`);\n      return true;\n    } catch (error) {\n      logger.error(`Failed to assign roles for game ${game.id}:`, error);\n      return false;\n    }\n  }\n\n  private calculateDistribution(playerCount: number, script: Script): Record<typeof RoleType[keyof typeof RoleType], number> {\n    // Standard Trouble Brewing distribution based on official rules\n  const distribution: Record<typeof RoleType[keyof typeof RoleType], number> = {\n      [RoleType.TOWNSFOLK]: 0,\n      [RoleType.OUTSIDER]: 0,\n      [RoleType.MINION]: 0,\n      [RoleType.DEMON]: 1,\n      [RoleType.TRAVELLER]: 0,\n      [RoleType.FABLED]: 0\n    };\n\n    // Calculate based on player count (official BotC distribution)\n    if (playerCount >= 5 && playerCount <= 6) {\n      distribution[RoleType.TOWNSFOLK] = 3;\n      distribution[RoleType.OUTSIDER] = 1;\n      distribution[RoleType.MINION] = 1;\n    } else if (playerCount >= 7 && playerCount <= 9) {\n      distribution[RoleType.TOWNSFOLK] = playerCount - 3;\n      distribution[RoleType.OUTSIDER] = 0;\n      distribution[RoleType.MINION] = 2;\n    } else if (playerCount >= 10 && playerCount <= 12) {\n      distribution[RoleType.TOWNSFOLK] = playerCount - 4;\n      distribution[RoleType.OUTSIDER] = 1;\n      distribution[RoleType.MINION] = 2;\n    } else if (playerCount >= 13 && playerCount <= 15) {\n      distribution[RoleType.TOWNSFOLK] = playerCount - 5;\n      distribution[RoleType.OUTSIDER] = 2;\n      distribution[RoleType.MINION] = 2;\n    } else {\n      // Fallback for edge cases\n      distribution[RoleType.TOWNSFOLK] = Math.max(2, playerCount - 3);\n      distribution[RoleType.OUTSIDER] = Math.max(0, Math.min(2, playerCount - 6));\n      distribution[RoleType.MINION] = Math.min(2, Math.max(1, Math.floor(playerCount / 4)));\n    }\n\n    return distribution;\n  }\n\n  private groupRolesByType(script: Script, selectedRoles?: string[]): Record<typeof RoleType[keyof typeof RoleType], string[]> {\n  const groups: Record<typeof RoleType[keyof typeof RoleType], string[]> = {\n      [RoleType.TOWNSFOLK]: [],\n      [RoleType.OUTSIDER]: [],\n      [RoleType.MINION]: [],\n      [RoleType.DEMON]: [],\n      [RoleType.TRAVELLER]: [],\n      [RoleType.FABLED]: []\n    };\n\n    for (const role of script.roles) {\n      if (selectedRoles && selectedRoles.length > 0 && !selectedRoles.includes(role.id)) continue;\n      groups[role.type].push(role.id);\n    }\n\n    return groups;\n  }\n\n  private assignRolesRandomly(\n    playerSeats: any[], \n  rolesByType: Record<typeof RoleType[keyof typeof RoleType], string[]>,\n  distribution: Record<typeof RoleType[keyof typeof RoleType], number>,\n  preAssignments: Array<{ roleId: string; alignment: typeof Alignment[keyof typeof Alignment] } | undefined>,\n  roleMap: Map<string, { alignment: typeof Alignment[keyof typeof Alignment]; type: typeof RoleType[keyof typeof RoleType] }>\n  ): Array<{ roleId: string; alignment: typeof Alignment[keyof typeof Alignment] }> {\n  const assignments: Array<{ roleId: string; alignment: typeof Alignment[keyof typeof Alignment] }> = [];\n    const availableSeats = [...Array(playerSeats.length).keys()];\n    \n    // Shuffle seats for random assignment\n    this.shuffleArray(availableSeats);\n\n    let seatIndex = 0;\n\n    // Place pre-assignments into assignment array and remove those seat positions from available order\n    for (const idx of [...availableSeats]) {\n      const pre = preAssignments[idx];\n      if (pre) {\n        assignments[idx] = pre;\n        const pos = availableSeats.indexOf(idx);\n        if (pos >= 0) availableSeats.splice(pos, 1);\n      }\n    }\n\n    // Assign demons first\n    for (let i = 0; i < distribution[RoleType.DEMON]; i++) {\n      const roleId = this.getRandomRole(rolesByType[RoleType.DEMON]);\n      assignments[availableSeats[seatIndex]] = {\n        roleId,\n        alignment: Alignment.EVIL\n      };\n      seatIndex++;\n    }\n\n    // Assign minions\n    for (let i = 0; i < distribution[RoleType.MINION]; i++) {\n      const roleId = this.getRandomRole(rolesByType[RoleType.MINION]);\n      assignments[availableSeats[seatIndex]] = {\n        roleId,\n        alignment: Alignment.EVIL\n      };\n      seatIndex++;\n    }\n\n    // Assign outsiders\n    for (let i = 0; i < distribution[RoleType.OUTSIDER]; i++) {\n      const roleId = this.getRandomRole(rolesByType[RoleType.OUTSIDER]);\n      assignments[availableSeats[seatIndex]] = {\n        roleId,\n        alignment: Alignment.GOOD\n      };\n      seatIndex++;\n    }\n\n    // Assign townsfolk\n    for (let i = 0; i < distribution[RoleType.TOWNSFOLK]; i++) {\n      const roleId = this.getRandomRole(rolesByType[RoleType.TOWNSFOLK]);\n      assignments[availableSeats[seatIndex]] = {\n        roleId,\n        alignment: Alignment.GOOD\n      };\n      seatIndex++;\n    }\n\n    return assignments;\n  }\n\n  private getRandomRole(roles: string[]): string {\n    return roles[Math.floor(Math.random() * roles.length)];\n  }\n\n  private shuffleArray<T>(array: T[]): void {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/script-loader.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token scripts",
        "line": 8,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Script, RoleDefinition, RoleType, Alignment, LoadedScript, Character, NightOrderEntry, MetaAction, CharacterAction } from '@botc/shared';\nimport { ScriptLoader as SharedScriptLoader } from '@botc/shared';\nimport { NodeScriptDataSource } from '../data/nodeScriptDataSource';\nimport { logger } from '../utils/logger';\nimport { ValidationSystem } from './validation-system';\n\nexport class ScriptLoader {\n  private scripts: Map<string, Script> = new Map();\n  private sharedLoader: SharedScriptLoader;\n  private validationSystem: ValidationSystem;\n  private loadedScripts: Map<string, LoadedScript> = new Map();\n\n  constructor() {\n    this.sharedLoader = new SharedScriptLoader(new NodeScriptDataSource());\n    this.validationSystem = new ValidationSystem();\n    this.loadDefaultScripts();\n  }\n\n  async loadScript(scriptId: string): Promise<Script | null> {\n    // Check cache first\n    if (this.scripts.has(scriptId)) {\n      return this.scripts.get(scriptId)!;\n    }\n\n    try {\n      // Load from JSON files with new metadata\n      const loadedScript = await this.sharedLoader.loadScript(scriptId);\n      this.loadedScripts.set(scriptId, loadedScript);\n      \n      // Validate the loaded script\n      const validationResult = this.validationSystem.validateScript(loadedScript);\n      \n      if (!validationResult.isValid) {\n        logger.warn(`Script ${scriptId} has validation errors:`);\n        logger.warn(this.validationSystem.generateReport(validationResult));\n      } else {\n        logger.info(`Script ${scriptId} validated successfully`);\n      }\n\n      // Convert to engine script format\n      const script = this.convertLoadedScriptToScript(loadedScript);\n      this.scripts.set(scriptId, script);\n      return script;\n    } catch (error) {\n      logger.warn(`Failed to load script from JSON: ${scriptId}, falling back to hardcoded`, error);\n      \n      // Fallback to hardcoded scripts\n      return this.scripts.get(scriptId) || null;\n    }\n  }\n\n  /**\n   * Get the loaded script with full metadata\n   */\n  async getLoadedScript(scriptId: string): Promise<LoadedScript | null> {\n    if (this.loadedScripts.has(scriptId)) {\n      return this.loadedScripts.get(scriptId)!;\n    }\n\n    try {\n      const loadedScript = await this.sharedLoader.loadScript(scriptId);\n      this.loadedScripts.set(scriptId, loadedScript);\n      return loadedScript;\n    } catch (error) {\n      logger.error(`Failed to load script metadata for ${scriptId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate a script and return detailed results\n   */\n  async validateScript(scriptId: string): Promise<any> {\n    const loadedScript = await this.getLoadedScript(scriptId);\n    if (!loadedScript) {\n      return { isValid: false, errors: ['Script not found'] };\n    }\n\n    return this.validationSystem.validateScript(loadedScript);\n  }\n\n  /**\n   * Get character action metadata for a specific character\n   */\n  async getCharacterActions(scriptId: string, characterId: string, phase: 'firstNight' | 'otherNights' | 'day'): Promise<CharacterAction[]> {\n    const loadedScript = await this.getLoadedScript(scriptId);\n    if (!loadedScript) return [];\n\n    const character = loadedScript.characters.find(c => c.id === characterId);\n    if (!character?.actions) return [];\n\n  const phaseKey = phase === 'otherNights' ? 'night' : phase;\n  return character.actions[phaseKey] || [];\n  }\n\n  /**\n   * Get night order with resolved actions\n   */\n  async getNightOrder(scriptId: string, isFirstNight: boolean = false): Promise<NightOrderEntry[]> {\n    const loadedScript = await this.getLoadedScript(scriptId);\n    if (!loadedScript) return [];\n\n    const orderField = isFirstNight ? 'firstNight' : 'nightOrder';\n    return loadedScript[orderField] || [];\n  }\n\n  /**\n   * Get all meta actions for a script\n   */\n  async getMetaActions(scriptId: string): Promise<MetaAction[]> {\n    const loadedScript = await this.getLoadedScript(scriptId);\n    if (!loadedScript) return [];\n\n    const metaActions: MetaAction[] = [];\n    \n    // Extract meta actions from first night\n    if (loadedScript.firstNight) {\n      for (const entry of loadedScript.firstNight) {\n        if (typeof entry === 'object' && entry.type === 'meta') {\n          metaActions.push(entry);\n        }\n      }\n    }\n\n    // Extract meta actions from night order\n    if (loadedScript.nightOrder) {\n      for (const entry of loadedScript.nightOrder) {\n        if (typeof entry === 'object' && entry.type === 'meta') {\n          metaActions.push(entry);\n        }\n      }\n    }\n\n    return metaActions;\n  }\n\n  listScripts(): Array<{ id: string; name: string; version: string }> {\n    return Array.from(this.scripts.values()).map(s => ({ id: s.id, name: s.name, version: s.version }));\n  }\n\n  private convertLoadedScriptToScript(loadedScript: LoadedScript): Script {\n    const roles: RoleDefinition[] = loadedScript.characters.map(char => this.convertCharacterToRole(char));\n\n    return {\n      id: loadedScript.id,\n      name: loadedScript.name,\n      version: loadedScript.meta?.version || '1.0.0',\n      roles,\n      setup: {\n        playerCount: {\n          min: loadedScript.meta?.playerCount?.min || 5,\n          max: loadedScript.meta?.playerCount?.max || 15\n        },\n        distribution: this.calculateDistribution(roles)\n      },\n      firstNight: loadedScript.firstNight,\n      nightOrder: loadedScript.nightOrder,\n      meta: loadedScript.meta\n    };\n  }\n\n  private convertCharacterToRole(char: Character): RoleDefinition {\n    return {\n      id: char.id,\n      name: char.name,\n      alignment: this.mapTeamToAlignment(char.team),\n      type: this.mapTeamToRoleType(char.team),\n      ability: char.ability ? {\n        id: `${char.id}-ability`,\n        when: 'passive' as const,\n        target: 'self',\n        effect: [{ type: 'custom', description: char.ability }]\n      } : undefined,\n      visibility: {\n        reveals: {\n          public: 'none' as const,\n          privateTo: char.team === 'minion' || char.team === 'demon' ? ['evil'] : []\n        }\n      },\n      precedence: char.firstNight || char.otherNights || 999,\n      reminderTokens: char.reminders\n    };\n  }\n\n  private mapTeamToAlignment(team: string): typeof Alignment[keyof typeof Alignment] {\n    return team === 'minion' || team === 'demon' ? Alignment.EVIL : Alignment.GOOD;\n  }\n\n  private mapTeamToRoleType(team: string): typeof RoleType[keyof typeof RoleType] {\n    switch (team) {\n      case 'townsfolk': return RoleType.TOWNSFOLK;\n      case 'outsider': return RoleType.OUTSIDER;\n      case 'minion': return RoleType.MINION;\n      case 'demon': return RoleType.DEMON;\n      case 'traveller': return RoleType.TRAVELLER;\n      case 'fabled': return RoleType.FABLED;\n      default: return RoleType.TOWNSFOLK;\n    }\n  }\n\n  private calculateDistribution(roles: RoleDefinition[]): Record<string, number> {\n    const distribution: Record<string, number> = {};\n    roles.forEach(role => {\n      const key = role.type.toString();\n      distribution[key] = (distribution[key] || 0) + 1;\n    });\n    return distribution;\n  }\n\n  private loadDefaultScripts(): void {\n    // Load Trouble Brewing script\n    const troubleBrewing = this.createTroubleBrewing();\n    this.scripts.set('trouble-brewing', troubleBrewing);\n    \n    logger.info('Loaded default scripts');\n  }\n\n  private createTroubleBrewing(): Script {\n    const roles: RoleDefinition[] = [\n      // Townsfolk\n      {\n        id: 'washerwoman',\n        name: 'Washerwoman',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'washerwoman-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'show_role_between_players' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 10\n      },\n      {\n        id: 'librarian',\n        name: 'Librarian',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'librarian-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'show_outsider_between_players' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 11\n      },\n      {\n        id: 'investigator',\n        name: 'Investigator',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'investigator-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'show_minion_between_players' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 12\n      },\n      {\n        id: 'chef',\n        name: 'Chef',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'chef-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'count_evil_neighbors' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 13\n      },\n      {\n        id: 'empath',\n        name: 'Empath',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'empath-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'count_evil_neighbors' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 20\n      },\n      {\n        id: 'fortune-teller',\n        name: 'Fortune Teller',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'fortune-teller-info',\n          when: 'night',\n          target: 'two_players',\n          effect: [{ type: 'check_if_demon' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 21\n      },\n      {\n        id: 'undertaker',\n        name: 'Undertaker',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'undertaker-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'show_executed_role' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 22\n      },\n      {\n        id: 'monk',\n        name: 'Monk',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'monk-protect',\n          when: 'night',\n          target: 'seat!=self & alive',\n          effect: [{ type: 'add_status', status: 'protected', nights: 1 }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 23\n      },\n      {\n        id: 'ravenkeeper',\n        name: 'Ravenkeeper',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'ravenkeeper-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'show_role_if_dead' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 24\n      },\n      {\n        id: 'virgin',\n        name: 'Virgin',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'virgin-execution',\n          when: 'day',\n          target: 'any',\n          effect: [{ type: 'execute_nominator_if_townsfolk' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 25\n      },\n      {\n        id: 'slayer',\n        name: 'Slayer',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'slayer-kill',\n          when: 'day',\n          target: 'seat!=self & alive',\n          effect: [{ type: 'kill_if_demon' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 26\n      },\n      {\n        id: 'soldier',\n        name: 'Soldier',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'soldier-protect',\n          when: 'passive',\n          target: 'self',\n          effect: [{ type: 'demon_kill_immunity' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 27\n      },\n      {\n        id: 'mayor',\n        name: 'Mayor',\n        alignment: Alignment.GOOD,\n        type: RoleType.TOWNSFOLK,\n        ability: {\n          id: 'mayor-bounce',\n          when: 'passive',\n          target: 'self',\n          effect: [{ type: 'execution_bounce_if_no_other_deaths' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 28\n      },\n      // Outsiders\n  // Recluse (single definition)\n      {\n        id: 'drunk',\n        name: 'Drunk',\n        alignment: Alignment.GOOD,\n        type: RoleType.OUTSIDER,\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 101\n      },\n      {\n        id: 'saint',\n        name: 'Saint',\n        alignment: Alignment.GOOD,\n        type: RoleType.OUTSIDER,\n        ability: {\n          id: 'saint-execution',\n          when: 'day',\n          target: 'self',\n          effect: [{ type: 'good_team_loses_if_executed' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 102\n      },\n      {\n        id: 'recluse',\n        name: 'Recluse',\n        alignment: Alignment.GOOD,\n        type: RoleType.OUTSIDER,\n        ability: {\n          id: 'recluse-registeration',\n          when: 'passive',\n          target: 'self',\n          effect: [{ type: 'may_register_as_evil' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 103\n      },\n      // Minions\n      {\n        id: 'poisoner',\n        name: 'Poisoner',\n        alignment: Alignment.EVIL,\n        type: RoleType.MINION,\n        ability: {\n          id: 'poison',\n          when: 'night',\n          target: 'seat!=self & alive',\n          effect: [{ type: 'add_status', status: 'poisoned', nights: 1 }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: ['evil']\n          }\n        },\n        precedence: 40\n      },\n      {\n        id: 'spy',\n        name: 'Spy',\n        alignment: Alignment.EVIL,\n        type: RoleType.MINION,\n        ability: {\n          id: 'spy-info',\n          when: 'night',\n          target: 'any',\n          effect: [{ type: 'see_grimoire' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: ['evil']\n          }\n        },\n        precedence: 41\n      },\n      {\n        id: 'scarlet-woman',\n        name: 'Scarlet Woman',\n        alignment: Alignment.EVIL,\n        type: RoleType.MINION,\n        ability: {\n          id: 'scarlet-woman-transform',\n          when: 'passive',\n          target: 'self',\n          effect: [{ type: 'become_demon_if_demon_dies' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: ['evil']\n          }\n        },\n        precedence: 42\n      },\n      {\n        id: 'butler',\n        name: 'Butler',\n        alignment: Alignment.GOOD,\n        type: RoleType.OUTSIDER,\n        ability: {\n          id: 'butler-vote',\n          when: 'day',\n          target: 'any',\n          effect: [{ type: 'must_vote_with_master' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: []\n          }\n        },\n        precedence: 104\n      },\n      {\n        id: 'baron',\n        name: 'Baron',\n        alignment: Alignment.EVIL,\n        type: RoleType.MINION,\n        ability: {\n          id: 'baron-setup',\n          when: 'passive',\n          target: 'setup',\n          effect: [{ type: 'modify_setup', add_outsiders: 2, remove_townsfolk: 2 }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: ['evil']\n          }\n        },\n        precedence: 44,\n        reminderTokens: ['Setup modification']\n      },\n      // Demon\n      {\n        id: 'imp',\n        name: 'Imp',\n        alignment: Alignment.EVIL,\n        type: RoleType.DEMON,\n        ability: {\n          id: 'imp-kill',\n          when: 'night',\n          target: 'seat!=self & alive',\n          effect: [{ type: 'kill' }]\n        },\n        visibility: {\n          reveals: {\n            public: 'none',\n            privateTo: ['evil']\n          }\n        },\n        precedence: 50\n      }\n    ];\n\n    return {\n      id: 'trouble-brewing',\n      name: 'Trouble Brewing',\n      version: '1.0.0',\n      roles,\n      setup: {\n        playerCount: {\n          min: 5,\n          max: 15\n        },\n        distribution: {\n          [RoleType.TOWNSFOLK]: 0,\n          [RoleType.OUTSIDER]: 0,\n          [RoleType.MINION]: 0,\n          [RoleType.DEMON]: 1\n        }\n      }\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/setup-manager.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 22,
        "column": 29,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { \n  GameState, \n  Script, \n  RoleType, \n  SetupState, \n  CharacterModification, \n  ReminderToken, \n  GrimoireState,\n  SeatId,\n  GameId\n} from '@botc/shared';\nimport { randomUUID } from 'crypto';\nimport { logger } from '../utils/logger';\nimport { resolveLineup } from './lineup-resolver';\nimport { NodeScriptDataSource } from '../data/nodeScriptDataSource';\n\nexport class SetupManager {\n  \n  /**\n   * Initialize setup state when entering SETUP phase\n   */\n  async initializeSetup(game: GameState, script: Script): Promise<SetupState> {\n    const setupState: SetupState = {\n      selectedCharacters: [],\n      characterModifications: [],\n      reminderTokens: [],\n      distributionOverride: undefined,\n      isValidated: false,\n      characterPool: []\n    };\n\n    // Initialize grimoire state if not exists\n    if (!game.grimoireState) {\n      game.grimoireState = {\n        characterPositions: {},\n        reminderTokens: [],\n        nightOrder: [],\n        setupState\n      };\n    } else {\n      game.grimoireState.setupState = setupState;\n    }\n\n    game.setupState = setupState;\n\n    // If the script metadata includes a composition policy, pre-seed selection to target counts\n    try {\n      const playerCount = game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId).length;\n      const dataSource = new NodeScriptDataSource();\n      const rawMeta = await dataSource.loadMetadata(script.id);\n      const composition = rawMeta?.composition;\n      const loadedScriptLike: any = {\n        id: script.id,\n        name: script.name,\n        characters: script.roles.map(r => ({ id: r.id, name: r.name, team: this.roleTypeToTeam(r.type) })) as any,\n        meta: { characterList: rawMeta?.characters || script.roles.map(r => r.id) },\n        composition\n      };\n      if (composition) {\n        const { selection, counts, notes } = resolveLineup({ script: loadedScriptLike, playerCount });\n        setupState.selectedCharacters = selection;\n        // Also set distributionOverride so validation matches seeding\n        setupState.distributionOverride = counts as any;\n        if (notes.length) logger.info(`Seeded setup from composition: ${notes.join('; ')}`);\n      }\n    } catch (e) {\n      logger.warn('Failed to seed setup from composition', e as any);\n    }\n  return setupState;\n  }\n\n  /**\n   * Storyteller selects specific characters for the game\n   */\n  selectCharacters(\n    game: GameState, \n    script: Script, \n    characterIds: string[], \n    storytellerSeatId: SeatId\n  ): { success: boolean; error?: string } {\n    if (!game.setupState) {\n      return { success: false, error: 'Setup not initialized' };\n    }\n\n    // Validate all characters exist in script\n    const scriptCharacterIds = new Set(script.roles.map(r => r.id));\n    const invalidCharacters = characterIds.filter(id => !scriptCharacterIds.has(id));\n    if (invalidCharacters.length > 0) {\n      return { success: false, error: `Invalid characters: ${invalidCharacters.join(', ')}` };\n    }\n\n    // Set selected characters\n    game.setupState.selectedCharacters = [...characterIds];\n    \n    // Apply character modifications\n    this.applyCharacterModifications(game, script);\n\n    logger.info(`Storyteller ${storytellerSeatId} selected characters: ${characterIds.join(', ')}`);\n    return { success: true };\n  }\n\n  /**\n   * Apply character modification rules (e.g., Baron adds Outsiders)\n   */\n  applyCharacterModifications(game: GameState, script: Script): void {\n    if (!game.setupState) return;\n\n    const modifications: CharacterModification[] = [];\n    \n    for (const characterId of game.setupState.selectedCharacters) {\n      const character = script.roles.find(r => r.id === characterId);\n      if (!character) continue;\n\n      // Check for setup modifications based on character abilities\n      switch (characterId) {\n        case 'baron':\n          modifications.push({\n            type: 'add_outsiders',\n            count: 2,\n            condition: 'Baron is in play'\n          });\n          modifications.push({\n            type: 'remove_townsfolk', \n            count: 2,\n            condition: 'Baron is in play'\n          });\n          break;\n        \n        case 'drunk':\n          // Drunk appears as Townsfolk but doesn't add/remove roles\n          // This is handled in role assignment phase\n          break;\n          \n        // Add more character modifications as needed\n      }\n    }\n\n    game.setupState.characterModifications = modifications;\n    logger.info(`Applied ${modifications.length} character modifications`);\n  }\n\n  /**\n   * Validate the current setup meets requirements\n   */\n  validateSetup(game: GameState, script: Script): { isValid: boolean; errors: string[] } {\n    if (!game.setupState) {\n      return { isValid: false, errors: ['Setup not initialized'] };\n    }\n\n    const errors: string[] = [];\n    // Count players excluding storyteller\n    const playerCount = game.seats.filter(seat => seat.id !== (game as any).storytellerSeatId).length;\n    \n    // Calculate required distribution\n    const requiredDistribution = this.calculateRequiredDistribution(playerCount, game.setupState);\n    \n    // Count selected characters by type\n    const selectedByType = this.countCharactersByType(game.setupState.selectedCharacters, script);\n    \n    // Validate distribution matches requirements\n    if (selectedByType.townsfolk !== requiredDistribution.townsfolk) {\n      errors.push(`Need ${requiredDistribution.townsfolk} Townsfolk, selected ${selectedByType.townsfolk}`);\n    }\n    if (selectedByType.outsiders !== requiredDistribution.outsiders) {\n      errors.push(`Need ${requiredDistribution.outsiders} Outsiders, selected ${selectedByType.outsiders}`);\n    }\n    if (selectedByType.minions !== requiredDistribution.minions) {\n      errors.push(`Need ${requiredDistribution.minions} Minions, selected ${selectedByType.minions}`);\n    }\n    if (selectedByType.demons !== requiredDistribution.demons) {\n      errors.push(`Need ${requiredDistribution.demons} Demons, selected ${selectedByType.demons}`);\n    }\n\n    // Validate player count\n    const totalSelected = Object.values(selectedByType).reduce((sum, count) => sum + count, 0);\n    if (totalSelected !== playerCount) {\n      errors.push(`Selected ${totalSelected} characters for ${playerCount} players`);\n    }\n\n    // Check script limits\n    if (playerCount < script.setup.playerCount.min || playerCount > script.setup.playerCount.max) {\n      errors.push(`Player count ${playerCount} not supported by script ${script.id}`);\n    }\n\n    const isValid = errors.length === 0;\n    game.setupState.isValidated = isValid;\n\n    if (isValid) {\n      // Create character pool for random distribution\n      game.setupState.characterPool = [...game.setupState.selectedCharacters];\n      logger.info(`Setup validated successfully for ${playerCount} players`);\n    } else {\n      logger.warn(`Setup validation failed: ${errors.join('; ')}`);\n    }\n\n    return { isValid, errors };\n  }\n\n  /**\n   * Create reminder tokens for characters that need them\n   */\n  createReminderTokens(game: GameState, script: Script): void {\n    if (!game.setupState || !game.grimoireState) return;\n\n    const reminderTokens: ReminderToken[] = [];\n\n    for (const characterId of game.setupState.selectedCharacters) {\n      const character = script.roles.find(r => r.id === characterId);\n      if (!character || !character.reminderTokens) continue;\n\n      // Create reminder tokens for this character\n      for (const tokenText of character.reminderTokens) {\n        const token: ReminderToken = {\n          id: randomUUID(),\n          roleId: characterId,\n          text: tokenText,\n          isActive: true\n        };\n        reminderTokens.push(token);\n      }\n    }\n\n    game.setupState.reminderTokens = reminderTokens;\n    game.grimoireState.reminderTokens = [...reminderTokens];\n    \n    logger.info(`Created ${reminderTokens.length} reminder tokens`);\n  }\n\n  /**\n   * Create random character pool from selected characters (the \"bag\" system)\n   */\n  createCharacterPool(game: GameState): string[] {\n    if (!game.setupState) return [];\n\n    // Shuffle the selected characters for random distribution\n    const pool = [...game.setupState.selectedCharacters];\n    this.shuffleArray(pool);\n    \n    game.setupState.characterPool = pool;\n    return pool;\n  }\n\n  /**\n   * Complete setup process and prepare for role assignment\n   */\n  completeSetup(game: GameState, script: Script): { success: boolean; error?: string } {\n    if (!game.setupState) {\n      return { success: false, error: 'Setup not initialized' };\n    }\n\n    const validation = this.validateSetup(game, script);\n    if (!validation.isValid) {\n      return { success: false, error: validation.errors.join('; ') };\n    }\n\n    // Create reminder tokens\n    this.createReminderTokens(game, script);\n    \n    // Create character pool for distribution\n    this.createCharacterPool(game);\n\n    // Build night order\n    this.buildNightOrder(game, script);\n\n    logger.info(`Setup completed for game ${game.id}`);\n    return { success: true };\n  }\n\n  /**\n   * Build night order from selected characters\n   */\n  private buildNightOrder(game: GameState, script: Script): void {\n    if (!game.grimoireState || !game.setupState) return;\n\n    const nightOrder: string[] = [];\n    \n    // Get all characters with night abilities\n    for (const characterId of game.setupState.selectedCharacters) {\n      const character = script.roles.find(r => r.id === characterId);\n      if (character && character.ability?.when === 'night') {\n        nightOrder.push(characterId);\n      }\n    }\n\n    // Sort by precedence (lower numbers go first)\n    nightOrder.sort((a, b) => {\n      const charA = script.roles.find(r => r.id === a);\n      const charB = script.roles.find(r => r.id === b);\n      return (charA?.precedence || 999) - (charB?.precedence || 999);\n    });\n\n    game.grimoireState.nightOrder = nightOrder;\n  }\n\n  /**\n   * Calculate required character distribution including modifications\n   */\n  private calculateRequiredDistribution(playerCount: number, setupState: SetupState): Record<string, number> {\n    // Start with base distribution (composition override if provided)\n    const distribution = setupState.distributionOverride\n      ? { ...setupState.distributionOverride }\n      : this.getBaseDistribution(playerCount);\n\n    // Apply character modifications on top of base/composition\n    for (const mod of setupState.characterModifications) {\n      switch (mod.type) {\n        case 'add_outsiders':\n          distribution.outsiders += mod.count;\n          break;\n        case 'remove_townsfolk':\n          distribution.townsfolk -= mod.count;\n          break;\n        case 'add_minions':\n          distribution.minions += mod.count;\n          break;\n        case 'remove_outsiders':\n          distribution.outsiders -= mod.count;\n          break;\n      }\n    }\n\n    return distribution;\n  }\n\n  /**\n   * Get base character distribution for player count\n   */\n  private getBaseDistribution(playerCount: number): Record<string, number> {\n    // Standard Blood on the Clocktower distribution\n    if (playerCount >= 5 && playerCount <= 6) {\n      return { townsfolk: 3, outsiders: 1, minions: 1, demons: 1 };\n    } else if (playerCount >= 7 && playerCount <= 9) {\n      return { townsfolk: playerCount - 3, outsiders: 0, minions: 2, demons: 1 };\n    } else if (playerCount >= 10 && playerCount <= 12) {\n      return { townsfolk: playerCount - 4, outsiders: 1, minions: 2, demons: 1 };\n    } else if (playerCount >= 13 && playerCount <= 15) {\n      return { townsfolk: playerCount - 5, outsiders: 2, minions: 2, demons: 1 };\n    } else {\n      // Fallback\n      return { \n        townsfolk: Math.max(2, playerCount - 3), \n        outsiders: Math.max(0, Math.min(2, playerCount - 6)), \n        minions: Math.min(2, Math.max(1, Math.floor(playerCount / 4))), \n        demons: 1 \n      };\n    }\n  }\n\n  private roleTypeToTeam(type: typeof RoleType[keyof typeof RoleType]): 'townsfolk'|'outsider'|'minion'|'demon'|'traveller'|'fabled' {\n    switch (type) {\n      case RoleType.TOWNSFOLK: return 'townsfolk';\n      case RoleType.OUTSIDER: return 'outsider';\n      case RoleType.MINION: return 'minion';\n      case RoleType.DEMON: return 'demon';\n      case RoleType.TRAVELLER: return 'traveller';\n      case RoleType.FABLED: return 'fabled';\n    }\n  }\n\n  /**\n   * Count selected characters by type\n   */\n  private countCharactersByType(characterIds: string[], script: Script): Record<string, number> {\n    const counts = { townsfolk: 0, outsiders: 0, minions: 0, demons: 0 };\n    \n    for (const id of characterIds) {\n      const character = script.roles.find(r => r.id === id);\n      if (!character) continue;\n\n      switch (character.type) {\n        case RoleType.TOWNSFOLK:\n          counts.townsfolk++;\n          break;\n        case RoleType.OUTSIDER:\n          counts.outsiders++;\n          break;\n        case RoleType.MINION:\n          counts.minions++;\n          break;\n        case RoleType.DEMON:\n          counts.demons++;\n          break;\n      }\n    }\n\n    return counts;\n  }\n\n  /**\n   * Shuffle array in place\n   */\n  private shuffleArray<T>(array: T[]): void {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/game/validation-system.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token interface",
        "line": 12,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  Character,\n  LoadedScript,\n  CharacterAction,\n  MetaAction,\n  NightOrderEntry,\n  CharacterActionType,\n  MetaActionType\n} from '@botc/shared';\nimport { logger } from '../utils/logger';\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  missingConfigurations: string[];\n  recommendations: string[];\n}\n\nexport interface CharacterValidationResult extends ValidationResult {\n  characterId: string;\n  missingActions: {\n    firstNight?: boolean;\n    otherNights?: boolean;\n    day?: boolean;\n  };\n  incompleteActions: string[];\n}\n\nexport interface ScriptValidationResult extends ValidationResult {\n  scriptId: string;\n  characterResults: CharacterValidationResult[];\n  missingMetaActions: string[];\n  nightOrderIssues: string[];\n}\n\n/**\n * Validation system for checking completeness of character and script configurations\n * Helps identify missing action metadata and engine features\n */\nexport class ValidationSystem {\n\n  /**\n   * Validate a complete script and all its characters\n   */\n  validateScript(script: LoadedScript): ScriptValidationResult {\n    logger.info(`Validating script: ${script.id}`);\n    \n    const result: ScriptValidationResult = {\n      scriptId: script.id,\n      isValid: true,\n      errors: [],\n      warnings: [],\n      missingConfigurations: [],\n      recommendations: [],\n      characterResults: [],\n      missingMetaActions: [],\n      nightOrderIssues: []\n    };\n\n    // Validate each character\n    for (const character of script.characters) {\n      const charResult = this.validateCharacter(character);\n      result.characterResults.push(charResult);\n      \n      if (!charResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...charResult.errors.map(e => `${character.id}: ${e}`));\n      }\n      \n      result.warnings.push(...charResult.warnings.map(w => `${character.id}: ${w}`));\n      result.missingConfigurations.push(...charResult.missingConfigurations.map(m => `${character.id}: ${m}`));\n    }\n\n    // Validate script-level night order\n    this.validateNightOrder(script, result);\n\n    // Check for required meta actions\n    this.validateMetaActions(script, result);\n\n    // Generate recommendations\n    this.generateScriptRecommendations(script, result);\n\n    return result;\n  }\n\n  /**\n   * Validate a single character's action configuration\n   */\n  validateCharacter(character: Character): CharacterValidationResult {\n    const result: CharacterValidationResult = {\n      characterId: character.id,\n      isValid: true,\n      errors: [],\n      warnings: [],\n      missingConfigurations: [],\n      recommendations: [],\n      missingActions: {},\n      incompleteActions: []\n    };\n\n    // Check if character should have actions based on legacy fields\n    this.checkExpectedActions(character, result);\n    \n    // Validate existing actions\n    if (character.actions) {\n      this.validateCharacterActions(character, result);\n    }\n\n    // Check action completeness\n    this.checkActionCompleteness(character, result);\n\n    return result;\n  }\n\n  /**\n   * Check what actions a character should have based on legacy data\n   */\n  private checkExpectedActions(character: Character, result: CharacterValidationResult): void {\n    // Check if character should have first night action\n    if (character.firstNight && character.firstNight > 0) {\n      if (!character.actions?.firstNight || character.actions.firstNight.length === 0) {\n        result.missingActions.firstNight = true;\n        result.missingConfigurations.push('Missing firstNight actions array despite having firstNight order');\n      }\n    }\n\n    // Check if character should have other nights action\n    if (character.otherNights && character.otherNights > 0) {\n  if (!character.actions?.night || character.actions.night.length === 0) {\n        result.missingActions.otherNights = true;\n        result.missingConfigurations.push('Missing otherNights actions array despite having otherNights order');\n      }\n    }\n\n    // Check for day actions based on ability text\n    const abilityText = character.ability?.toLowerCase() || '';\n    const dayKeywords = ['during the day', 'when you die', 'when nominated', 'when executed', 'once per day'];\n    \n    if (dayKeywords.some(keyword => abilityText.includes(keyword))) {\n      const hasDayActions = character.actions?.day && character.actions.day.length > 0;\n      if (!hasDayActions) {\n        result.missingActions.day = true;\n        result.warnings.push(`Ability suggests day action but no day actions configured (has actions: ${!!character.actions}, day length: ${character.actions?.day?.length || 0})`);\n      }\n    }\n  }\n\n  /**\n   * Validate the structure and completeness of character actions\n   */\n  private validateCharacterActions(character: Character, result: CharacterValidationResult): void {\n    const actions = character.actions!;\n\n    // Validate first night actions\n    if (actions.firstNight) {\n      for (const action of actions.firstNight) {\n        this.validateAction(action, 'firstNight', result);\n      }\n    }\n\n    // Validate other night actions\n  if (actions.night) {\n  for (const action of actions.night) {\n        this.validateAction(action, 'otherNights', result);\n      }\n    }\n\n    // Validate day actions\n    if (actions.day) {\n      for (const action of actions.day) {\n        this.validateAction(action, 'day', result);\n      }\n    }\n\n    // Check for actions in other phases\n    ['nominations', 'voting', 'execution'].forEach(phase => {\n      const phaseActions = (actions as any)[phase];\n      if (phaseActions) {\n        for (const action of phaseActions) {\n          this.validateAction(action, phase, result);\n        }\n      }\n    });\n  }\n\n  /**\n   * Validate a single action's structure and data\n   */\n  private validateAction(action: CharacterAction, phase: string, result: CharacterValidationResult): void {\n    const actionId = action.id || 'unknown';\n\n    // Required fields\n    if (!action.action) {\n      result.errors.push(`Action ${actionId} missing 'action' field`);\n      result.isValid = false;\n    }\n\n    if (!action.description) {\n      result.warnings.push(`Action ${actionId} missing description`);\n    }\n\n    if (!action.targets || action.targets.length === 0) {\n      result.warnings.push(`Action ${actionId} has no targets specified`);\n    }\n\n    // Check if action type is recognized (support both old and new formats)\n    const actionType = action.actionType || action.action;\n    if (!actionType) {\n      result.errors.push(`Action ${actionId} has no action type specified`);\n      return;\n    }\n\n    // Get all known action types as strings from our enums\n    const knownCharacterActions = Object.values(CharacterActionType) as string[];\n    const knownMetaActions = Object.values(MetaActionType) as string[];\n\n    const allKnownActions = [...knownCharacterActions, ...knownMetaActions];\n\n    if (!allKnownActions.includes(actionType)) {\n      result.missingConfigurations.push(`Action type '${actionType}' not implemented in engine`);\n    }\n\n    // Validate information specification\n    if (action.information) {\n      this.validateInformationSpec(action.information, actionId, result);\n    }\n\n    // Check if action has order for proper sequencing\n    if (phase.includes('night') && action.order === undefined) {\n      result.warnings.push(`Action ${actionId} missing order for night sequencing`);\n    }\n  }\n\n  /**\n   * Validate information specification structure\n   */\n  private validateInformationSpec(info: any, actionId: string, result: CharacterValidationResult): void {\n    const hasShowPlayers = info.showPlayersByTeam || info.showPlayers || info.showPlayer;\n    const hasCustomMessage = info.customMessage;\n    const hasBluffs = info.giveBluffs;\n\n    if (!hasShowPlayers && !hasCustomMessage && !hasBluffs) {\n      result.warnings.push(`Action ${actionId} has information spec but no delivery method specified`);\n    }\n\n    if (info.customMessage && info.customMessage.includes('[COUNT]') && !actionId.includes('count')) {\n      result.warnings.push(`Action ${actionId} uses [COUNT] placeholder but action name doesn't suggest counting`);\n    }\n  }\n\n  /**\n   * Check overall action completeness and consistency\n   */\n  private checkActionCompleteness(character: Character, result: CharacterValidationResult): void {\n    // Check goal vs actions alignment\n    if (character.goal) {\n      const goalAction = character.goal.action;\n      const hasMatchingAction = character.actions && Object.values(character.actions).some(actions => \n        actions && actions.some(action => action.action === goalAction)\n      );\n\n      if (!hasMatchingAction) {\n        result.warnings.push(`Goal specifies action '${goalAction}' but no matching action found`);\n      }\n    }\n\n    // Check for actions without goals\n    if (character.actions && !character.goal) {\n      const hasComplexActions = Object.values(character.actions).some(actions =>\n        actions && actions.length > 0\n      );\n\n      if (hasComplexActions) {\n        result.recommendations.push('Character has actions but no goal specified - consider adding goal metadata');\n      }\n    }\n  }\n\n  /**\n   * Validate script night order and meta actions\n   */\n  private validateNightOrder(script: LoadedScript, result: ScriptValidationResult): void {\n    // Check first night order\n    if (script.firstNight) {\n      this.validateNightOrderEntries(script.firstNight, 'firstNight', script, result);\n    } else {\n      result.warnings.push('No structured firstNight order found');\n    }\n\n    // Check other nights order\n    if (script.nightOrder) {\n      this.validateNightOrderEntries(script.nightOrder, 'nightOrder', script, result);\n    } else {\n      result.warnings.push('No structured nightOrder found');\n    }\n  }\n\n  /**\n   * Validate night order entries\n   */\n  private validateNightOrderEntries(\n    entries: NightOrderEntry[], \n    phase: string, \n    script: LoadedScript, \n    result: ScriptValidationResult\n  ): void {\n    const characterIds = new Set(script.characters.map(c => c.id));\n\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n\n      if (typeof entry === 'string') {\n        // Character ID entry\n        if (!characterIds.has(entry)) {\n          result.errors.push(`${phase}[${i}]: Character '${entry}' not found in script`);\n          result.isValid = false;\n        }\n      } else {\n        // Meta action entry\n        this.validateMetaAction(entry, `${phase}[${i}]`, result);\n      }\n    }\n  }\n\n  /**\n   * Validate meta action structure\n   */\n  private validateMetaAction(action: MetaAction, context: string, result: ScriptValidationResult): void {\n    if (!action.id) {\n      result.errors.push(`${context}: Meta action missing id`);\n      result.isValid = false;\n    }\n\n    if (!action.action) {\n      result.errors.push(`${context}: Meta action ${action.id} missing action`);\n      result.isValid = false;\n    }\n\n    if (!action.targets || action.targets.length === 0) {\n      result.warnings.push(`${context}: Meta action ${action.id} has no targets`);\n    }\n\n    // Check if meta action is implemented (support both old and new formats)\n    const metaActionType = action.actionType || action.action;\n    if (!metaActionType) {\n      result.errors.push(`${context}: Meta action ${action.id} missing action type`);\n      result.isValid = false;\n      return;\n    }\n\n    const knownMetaActions = Object.values(MetaActionType) as string[];\n    if (!knownMetaActions.includes(metaActionType)) {\n      result.missingConfigurations.push(`${context}: Meta action '${metaActionType}' not implemented in engine`);\n    }\n  }\n\n  /**\n   * Check for required meta actions\n   */\n  private validateMetaActions(script: LoadedScript, result: ScriptValidationResult): void {\n    const hasMinions = script.characters.some(c => c.team === 'minion');\n    const hasDemons = script.characters.some(c => c.team === 'demon');\n\n    if (hasMinions || hasDemons) {\n      const firstNightActions = script.firstNight || [];\n      const hasMinionsInfo = firstNightActions.some(entry => \n        typeof entry === 'object' && entry.action === 'showTeamToMinions'\n      );\n      const hasDemonInfo = firstNightActions.some(entry => \n        typeof entry === 'object' && entry.action === 'showTeamAndBluffsToDemon'\n      );\n\n      if (hasMinions && !hasMinionsInfo) {\n        result.missingMetaActions.push('showTeamToMinions - required when minions are present');\n      }\n\n      if (hasDemons && !hasDemonInfo) {\n        result.missingMetaActions.push('showTeamAndBluffsToDemon - required when demons are present');\n      }\n    }\n  }\n\n  /**\n   * Generate recommendations for script improvement\n   */\n  private generateScriptRecommendations(script: LoadedScript, result: ScriptValidationResult): void {\n    const missingActionCharacters = result.characterResults.filter(cr => \n      Object.keys(cr.missingActions).length > 0\n    );\n\n    if (missingActionCharacters.length > 0) {\n      result.recommendations.push(\n        `${missingActionCharacters.length} characters missing action configurations: ${\n          missingActionCharacters.map(cr => cr.characterId).join(', ')\n        }`\n      );\n    }\n\n    const unimplementedActions = result.missingConfigurations.filter(mc => \n      mc.includes('not implemented in engine')\n    );\n\n    if (unimplementedActions.length > 0) {\n      result.recommendations.push(\n        `Consider implementing these action types in the engine: ${ \n        [...new Set(unimplementedActions.map(ua => ua.split(\"'\")[1]))].join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Generate a summary report of validation results\n   */\n  generateReport(result: ScriptValidationResult): string {\n    const lines: string[] = [];\n    \n    lines.push(`=== Validation Report for ${result.scriptId} ===`);\n    lines.push(`Overall Status: ${result.isValid ? 'VALID' : 'INVALID'}`);\n    lines.push('');\n\n    if (result.errors.length > 0) {\n      lines.push('ERRORS:');\n      result.errors.forEach(error => lines.push(`  - ${error}`));\n      lines.push('');\n    }\n\n    if (result.warnings.length > 0) {\n      lines.push('WARNINGS:');\n      result.warnings.forEach(warning => lines.push(`  - ${warning}`));\n      lines.push('');\n    }\n\n    if (result.missingConfigurations.length > 0) {\n      lines.push('MISSING CONFIGURATIONS:');\n      result.missingConfigurations.forEach(missing => lines.push(`  - ${missing}`));\n      lines.push('');\n    }\n\n    if (result.missingMetaActions.length > 0) {\n      lines.push('MISSING META ACTIONS:');\n      result.missingMetaActions.forEach(meta => lines.push(`  - ${meta}`));\n      lines.push('');\n    }\n\n    if (result.recommendations.length > 0) {\n      lines.push('RECOMMENDATIONS:');\n      result.recommendations.forEach(rec => lines.push(`  - ${rec}`));\n      lines.push('');\n    }\n\n    // Character summary\n    const validCharacters = result.characterResults.filter(cr => cr.isValid).length;\n    const totalCharacters = result.characterResults.length;\n    lines.push(`CHARACTER SUMMARY: ${validCharacters}/${totalCharacters} valid`);\n    \n    const incompleteCharacters = result.characterResults.filter(cr => !cr.isValid);\n    if (incompleteCharacters.length > 0) {\n      lines.push('Incomplete characters:');\n      incompleteCharacters.forEach(cr => {\n        lines.push(`  - ${cr.characterId}: ${cr.errors.length} errors, ${cr.warnings.length} warnings`);\n      });\n    }\n\n    return lines.join('\\n');\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/index.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 36,
        "column": 13,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import 'dotenv/config';\nimport Fastify from 'fastify';\nimport websocket from '@fastify/websocket';\nimport cors from '@fastify/cors';\nimport { randomUUID } from 'crypto';\nimport fs from 'fs';\nimport path from 'path';\nimport { GameId, GameState, SeatId } from '@botc/shared';\nimport { maskGameStateForSeat, maskGameStatePublic } from '@botc/shared';\nimport { GameEngine } from './game/engine';\nimport { WebSocketHandler } from './websocket/handler';\nimport { MatchmakingService } from './services/matchmaking';\nimport { scriptCache } from './services/scriptCache';\nimport { logger } from './utils/logger';\nimport setupRoutes from './routes/setupRoutes';\n\nconst fastify = Fastify({\n  logger: {\n    level: process.env.LOG_LEVEL || 'info'\n  }\n});\n\nasync function start() {\n  try {\n    // Initialize script cache first for fast script loading\n    await scriptCache.initialize();\n    const { scriptCount, totalCharacters } = scriptCache.getStats();\n    logger.info(`🎭 Script cache ready: ${scriptCount} scripts, ${totalCharacters} characters`);\n\n    // Register plugins\n    const isProd = process.env.NODE_ENV === 'production';\n    await fastify.register(cors, {\n      // In dev, allow all origins so Vite (5173) works; in prod, use CORS_ORIGIN or disable\n      origin: isProd\n        ? (process.env.CORS_ORIGIN || false)\n  : ((origin: string | undefined, cb: (err: Error | null, allow?: boolean) => void) => cb(null, true))\n    } as any);\n    \n    await fastify.register(websocket);\n\n    // Initialize services\n    const gameEngine = new GameEngine();\n    const matchmaking = new MatchmakingService(gameEngine);\n    const wsHandler = new WebSocketHandler(gameEngine, matchmaking);\n\n    // Broadcast updates to subscribed clients when matchmaking changes occur\n    matchmaking.setOnUpdate((\n      args: { gameId: GameId; game: GameState; eventType: string; payload?: Record<string, any> }\n    ) => {\n      const { gameId, game, eventType, payload } = args;\n      wsHandler.broadcastToGame(gameId, {\n        type: 'event',\n        event: {\n          id: randomUUID(),\n          gameId,\n          type: eventType as any,\n          timestamp: new Date(),\n          payload: { gameState: game, ...payload }\n        }\n      });\n    });\n\n    // Health check\n    fastify.get('/health', async () => {\n      return { status: 'ok', timestamp: new Date().toISOString() };\n    });\n\n    // Game API routes\n    fastify.get('/api/games', async () => {\n      return matchmaking.getActiveGames();\n    });\n\n    // Get only public games (for join game listings)\n    fastify.get('/api/games/public', async () => {\n      return matchmaking.getPublicGames();\n    });\n\n    // List available scripts\n    fastify.get('/api/scripts', async () => {\n      return gameEngine.listScripts();\n    });\n\n    // Static-like route to serve character artwork from repo data (png files)\n    fastify.get('/artwork/characters/:image', async (request, reply) => {\n      const { image } = request.params as { image: string };\n      // Basic validation: only .png under known folder, prevent path traversal\n      if (!image || !/^[a-z0-9\\-]+\\.png$/i.test(image)) {\n        reply.code(400);\n        return { error: 'Invalid image name' };\n      }\n      // Resolve from monorepo root: packages/server/src -> ../../.. -> repo root\n      const repoRoot = path.resolve(__dirname, '../../..');\n      const filePath = path.join(repoRoot, 'data', 'artwork', 'characters', image);\n      try {\n        await fs.promises.access(filePath, fs.constants.R_OK);\n        reply.type('image/png');\n        return fs.createReadStream(filePath);\n      } catch {\n        reply.code(404);\n        return { error: 'Not found' };\n      }\n    });\n\n    fastify.get('/api/scripts/:scriptId', async (request) => {\n      const { scriptId } = request.params as { scriptId: string };\n      const script = await gameEngine.getScript(scriptId);\n      if (!script) return { error: 'Not found' };\n      return {\n        id: script.id,\n        name: script.name,\n        version: script.version,\n    playerCount: script.setup?.playerCount,\n        roles: script.roles.map((r: any) => ({ id: r.id, name: r.name, type: r.type, alignment: r.alignment }))\n      };\n    });\n\n    // Fast cached script routes for lobby\n    fastify.get('/api/scripts/cached/list', async (request, reply) => {\n      try {\n        const scripts = scriptCache.getScriptsList();\n        return { scripts };\n      } catch (error) {\n        reply.code(500);\n        return { error: 'Failed to load scripts' };\n      }\n    });\n\n    fastify.get('/api/scripts/cached/:scriptId', async (request, reply) => {\n      try {\n        const { scriptId } = request.params as { scriptId: string };\n        const script = scriptCache.getScript(scriptId);\n        if (!script) {\n          reply.code(404);\n          return { error: 'Script not found' };\n        }\n        return script;\n      } catch (error) {\n        reply.code(500);\n        return { error: 'Failed to load script' };\n      }\n    });\n\n    fastify.get('/api/scripts/cached/:scriptId/characters', async (request, reply) => {\n      try {\n        const { scriptId } = request.params as { scriptId: string };\n        const script = scriptCache.getScript(scriptId);\n        if (!script) {\n          reply.code(404);\n          return { error: 'Script not found' };\n        }\n        return { characters: script.characters };\n      } catch (error) {\n        reply.code(500);\n        return { error: 'Failed to load characters' };\n      }\n    });    fastify.post('/api/games', async (request, reply) => {\n      try {\n        const { gameName, isPublic } = ((request.body as any) || {});\n        const gameId = await matchmaking.createGame(undefined, { isPublic: isPublic !== false }); // default to public\n        if (typeof gameName === 'string' && gameName.trim()) {\n          const game = gameEngine.getGame(gameId);\n          if (game) {\n            (game as any).gameName = gameName.trim().slice(0, 60);\n          }\n        }\n        return { gameId };\n      } catch (error) {\n  logger.error('POST /api/games failed:', error);\n  reply.code(500);\n  return { error: 'Failed to create game', details: (error && typeof error === 'object' && 'message' in error) ? (error as any).message : String(error) };\n      }\n    });\n\n    // Get a game's current state; optional viewerSeatId to return masked view\n    fastify.get('/api/games/:gameId', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { viewerSeatId } = request.query as { viewerSeatId?: string };\n      const game = gameEngine.getGame(gameId as any);\n      if (!game) {\n        reply.code(404);\n        return { error: 'Game not found' };\n      }\n      if (!viewerSeatId) return maskGameStatePublic(game);\n      try {\n        // Storyteller gets full state\n        if (game.storytellerSeatId && viewerSeatId === game.storytellerSeatId) return game;\n        return maskGameStateForSeat(game, viewerSeatId as SeatId);\n      } catch {\n        return maskGameStatePublic(game);\n      }\n    });\n\n    // Join a game (simple: playerId from query for now)\n    fastify.post('/api/games/:gameId/join', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { playerId } = (request.body as any) || {};\n      if (!playerId) {\n        reply.code(400);\n        return { error: 'playerId required' };\n      }\n      const seatId = await matchmaking.joinGame(gameId as any, playerId);\n      if (!seatId) {\n        reply.code(400);\n        return { error: 'Failed to join game' };\n      }\n      const game = gameEngine.getGame(gameId as any)!;\n      const isStoryteller = game.storytellerSeatId === seatId;\n      return { ok: true, seatId, isStoryteller };\n    });\n\n    // Assign/change storyteller (only current storyteller can set)\n    fastify.post('/api/games/:gameId/storyteller', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { setterSeatId, targetSeatId } = (request.body as any) || {};\n      if (!setterSeatId || !targetSeatId) { reply.code(400); return { error: 'setterSeatId and targetSeatId required' }; }\n      const res = gameEngine.setStoryteller(gameId as any, setterSeatId as any, targetSeatId as any);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'storyteller_changed', payload: { storytellerSeatId: game.storytellerSeatId } });\n      return { ok: true, storytellerSeatId: game.storytellerSeatId };\n    });\n\n    // Start a game\n    fastify.post('/api/games/:gameId/start', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const ok = await matchmaking.startGame(gameId as any);\n      if (!ok) {\n        reply.code(400);\n        return { error: 'Failed to start game' };\n      }\n      return { ok: true };\n    });\n\n    // Manual phase controls (Storyteller only)\n    fastify.post('/api/games/:gameId/phase/advance', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId } = (request.body as any) || {};\n      const res = await gameEngine.advancePhase(gameId as any, storytellerSeatId);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'phase_changed', payload: { phase: game.phase } });\n      }\n      return { ok: true, phase: game.phase, day: game.day };\n    });\n\n    fastify.post('/api/games/:gameId/phase/set', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId, phase } = (request.body as any) || {};\n      const res = await gameEngine.setPhase(gameId as any, storytellerSeatId, phase);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'phase_changed', payload: { phase: game.phase } });\n      }\n      return { ok: true, phase: game.phase, day: game.day };\n    });\n\n    fastify.post('/api/games/:gameId/end', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId } = (request.body as any) || {};\n      const res = await gameEngine.endGame(gameId as any, storytellerSeatId);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'phase_changed', payload: { phase: game.phase } });\n      }\n      return { ok: true, phase: game?.phase };\n    });\n\n    // Set the game's display name (storyteller only, lobby only)\n    fastify.post('/api/games/:gameId/name', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId, name } = (request.body as any) || {};\n      const res = gameEngine.setGameName(gameId as any, storytellerSeatId as any, name as string);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'game_created', payload: { renamed: true } });\n      }\n      return { ok: true };\n    });\n\n    // Add an NPC player\n    fastify.post('/api/games/:gameId/npc', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const ok = await matchmaking.addNPC(gameId as any);\n      if (!ok) {\n        reply.code(400);\n        return { error: 'Failed to add NPC' };\n      }\n      return { ok: true };\n    });\n\n    // Leave a game (lobby only)\n    fastify.post('/api/games/:gameId/leave', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { seatId } = (request.body as any) || {};\n      if (!seatId) { reply.code(400); return { error: 'seatId required' }; }\n      const res = gameEngine.removePlayer(gameId as any, seatId as any);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'player_left', payload: { seatId } });\n      }\n      return { ok: true };\n    });\n\n    // Role selection and claiming\n    fastify.post('/api/games/:gameId/roles/select', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId, roleIds } = (request.body as any) || {};\n      if (!Array.isArray(roleIds) || !storytellerSeatId) { reply.code(400); return { error: 'Invalid body' }; }\n      const ok = gameEngine.selectRoles(gameId as any, storytellerSeatId as any, roleIds);\n      if (!ok) { reply.code(400); return { error: 'Failed to select roles' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'roles_selected', payload: { roleCount: roleIds.length } });\n      }\n      return { ok: true };\n    });\n\n    // Set available scripts for players (storyteller only)\n    fastify.post('/api/games/:gameId/scripts/available', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId, scriptIds } = (request.body as any) || {};\n      if (!Array.isArray(scriptIds) || !storytellerSeatId) { reply.code(400); return { error: 'Invalid body' }; }\n      const ok = gameEngine.setAvailableScripts(gameId as any, storytellerSeatId as any, scriptIds);\n      if (!ok) { reply.code(400); return { error: 'Failed to set available scripts' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'available_scripts_updated', payload: { scriptIds } });\n      }\n      return { ok: true };\n    });\n\n    fastify.post('/api/games/:gameId/roles/claim', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { seatId, roleId } = (request.body as any) || {};\n      if (!seatId || !roleId) { reply.code(400); return { error: 'Invalid body' }; }\n      const ok = gameEngine.claimRole(gameId as any, seatId as any, roleId);\n      if (!ok) { reply.code(400); return { error: 'Failed to claim role' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'chat_message', payload: { text: 'role claimed' } });\n      }\n      return { ok: true };\n    });\n\n    fastify.post('/api/games/:gameId/roles/claim-random', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { seatId } = (request.body as any) || {};\n      if (!seatId) { reply.code(400); return { error: 'Invalid body' }; }\n      const roleId = await gameEngine.claimRandomRole(gameId as any, seatId as any);\n      if (!roleId) { reply.code(400); return { error: 'Failed to claim random role' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'chat_message', payload: { text: 'random role claimed' } });\n      }\n      return { ok: true, roleId };\n    });\n\n    // WebSocket connection\n    fastify.register(async function (fastify) {\n      fastify.get('/ws', { websocket: true }, wsHandler.handleConnection.bind(wsHandler));\n    });\n\n    // Setup routes\n    fastify.register(setupRoutes, { prefix: '/api/games', gameEngine });\n\n    // ASR routes\n    fastify.register(async function (fastify) {\n      fastify.post('/asr/stream', async (request, reply) => {\n        const { ASRController } = await import('./controllers/asrController');\n        return ASRController.streamAudio(request as any, reply);\n      });\n\n      fastify.post('/asr/summarize', async (request, reply) => {\n        const { ASRController } = await import('./controllers/asrController');\n        return ASRController.summarizePhase(request as any, reply);\n      });\n    });\n\n    // Day mechanics: nomination & voting\n    fastify.post('/api/games/:gameId/nominate', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { nominator, nominee } = (request.body as any) || {};\n      const res = gameEngine.nominate(gameId as any, nominator as any, nominee as any);\n      if (!('ok' in res) || !res.ok) { reply.code(400); return { error: (res as any).error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'nomination_made', payload: { nominee } });\n      return { ok: true, nominationId: res.nominationId };\n    });\n\n    fastify.post('/api/games/:gameId/vote/start', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId } = (request.body as any) || {};\n      const res = gameEngine.startVote(gameId as any, storytellerSeatId as any);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'vote_cast', payload: { started: true } });\n      return { ok: true };\n    });\n\n    fastify.post('/api/games/:gameId/vote/cast', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { voter, vote } = (request.body as any) || {};\n      const res = gameEngine.castVote(gameId as any, voter as any, !!vote);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'vote_cast', payload: { voter, vote: !!vote } });\n      return { ok: true };\n    });\n\n    fastify.post('/api/games/:gameId/vote/finish', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { storytellerSeatId } = (request.body as any) || {};\n      const res = gameEngine.finishVote(gameId as any, storytellerSeatId as any);\n      if (!res.ok) { reply.code(400); return { error: res.error }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'execution_occurred', payload: { executed: res.executed } });\n      return { ok: true, executed: res.executed, nominee: res.nominee };\n    });\n\n    // Script proposal endpoints (simple)\n    fastify.post('/api/games/:gameId/scripts/propose', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { proposerSeatId, scriptId, active } = (request.body as any) || {};\n      if (!proposerSeatId || !scriptId) {\n        reply.code(400); return { error: 'proposerSeatId and scriptId required' };\n      }\n      const ok = matchmaking.proposeScript(gameId as any, proposerSeatId, scriptId, active !== false);\n      if (!ok) { reply.code(400); return { error: 'Failed to propose script' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'script_proposed', payload: { scriptId, active: active !== false } });\n      }\n      return { ok: true };\n    });\n\n    fastify.post('/api/games/:gameId/scripts/vote', async (request, reply) => {\n      const { gameId } = request.params as { gameId: string };\n      const { voterSeatId, proposalId, vote, difficulty } = (request.body as any) || {};\n      if (!voterSeatId || !proposalId) { reply.code(400); return { error: 'voterSeatId and proposalId required' }; }\n      let ok = true;\n      if (typeof vote === 'boolean' || vote === null) {\n        ok = matchmaking.voteOnScript(gameId as any, voterSeatId, proposalId, vote);\n      }\n      if (ok && difficulty) {\n        ok = gameEngine.voteScriptDifficulty(gameId as any, voterSeatId as any, proposalId, difficulty);\n      }\n      if (!ok) { reply.code(400); return { error: 'Failed to vote' }; }\n      const game = gameEngine.getGame(gameId as any)!;\n      if (game && matchmaking['onUpdate']) {\n        matchmaking['onUpdate']!({ gameId: game.id, game, eventType: 'script_vote', payload: { proposalId } });\n      }\n      return { ok: true };\n    });\n\n    const port = parseInt(process.env.PORT || '3001');\n    const host = process.env.HOST || '0.0.0.0';\n\n    await fastify.listen({ port, host });\n    logger.info(`🚀 Server listening on http://${host}:${port}`);\n  } catch (error) {\n    logger.error('Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\nstart();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/middleware/keycloakAuth.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 6,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import jwt from 'jsonwebtoken';\nimport jwksClient, { SigningKey } from 'jwks-rsa';\nimport { FastifyRequest, FastifyReply } from 'fastify';\nimport { logger } from '../utils/logger';\n\ninterface KeycloakToken {\n  sub: string;\n  preferred_username?: string;\n  email?: string;\n  realm_access?: {\n    roles: string[];\n  };\n  resource_access?: {\n    [clientId: string]: {\n      roles: string[];\n    };\n  };\n}\n\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    user?: KeycloakToken;\n  }\n}\n\nexport class KeycloakAuth {\n  private client: jwksClient.JwksClient;\n  private issuer: string;\n\n  constructor() {\n    const keycloakUrl = process.env.KEYCLOAK_URL || 'http://localhost:8080';\n    const realm = process.env.KEYCLOAK_REALM || 'botct';\n    \n    this.issuer = `${keycloakUrl}/realms/${realm}`;\n    this.client = jwksClient({\n      jwksUri: `${this.issuer}/protocol/openid-connect/certs`,\n      requestHeaders: {}, // Optional headers\n      timeout: 30000 // Defaults to 30s\n    });\n  }\n\n  private getKey = (header: any, callback: (err: Error | null, key?: string) => void) => {\n    this.client.getSigningKey(header.kid, (err: Error | null, key?: SigningKey) => {\n      if (err) {\n        callback(err);\n      } else {\n        const signingKey = key?.getPublicKey();\n        callback(null, signingKey);\n      }\n    });\n  };\n\n  public authenticate = async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const authHeader = request.headers.authorization;\n      \n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        reply.code(401).send({ error: 'Missing or invalid authorization header' });\n        return;\n      }\n\n      const token = authHeader.substring(7);\n\n      const decoded = await new Promise<KeycloakToken>((resolve, reject) => {\n        jwt.verify(token, this.getKey, {\n          issuer: this.issuer,\n          algorithms: ['RS256']\n        }, (err, decoded) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(decoded as KeycloakToken);\n          }\n        });\n      });\n\n      request.user = decoded;\n    } catch (error) {\n      logger.error('Authentication failed:', error);\n      reply.code(401).send({ error: 'Invalid token' });\n    }\n  };\n\n  public optional = async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const authHeader = request.headers.authorization;\n      \n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        // Continue without authentication\n        return;\n      }\n\n      const token = authHeader.substring(7);\n\n      const decoded = await new Promise<KeycloakToken>((resolve, reject) => {\n        jwt.verify(token, this.getKey, {\n          issuer: this.issuer,\n          algorithms: ['RS256']\n        }, (err, decoded) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(decoded as KeycloakToken);\n          }\n        });\n      });\n\n      request.user = decoded;\n    } catch (error) {\n      // Log but don't fail the request for optional auth\n      logger.debug('Optional authentication failed:', error);\n    }\n  };\n}\n\nexport const keycloakAuth = new KeycloakAuth();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/routes/asrRoutes.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 4,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';\nimport { ASRController } from '../controllers/asrController';\n\ninterface StreamAudioBody {\n  audioData: string; // base64 encoded audio\n  sessionId: string;\n  seatId: string;\n}\n\ninterface SummarizePhaseBody {\n  turns: any[];\n  events: any[];\n  viewerRole: string;\n  phase: string;\n  gameId: string;\n}\n\nexport default async function asrRoutes(fastify: FastifyInstance) {\n  // Stream audio for ASR processing\n  fastify.post('/asr/stream', async (request: FastifyRequest<{ Body: StreamAudioBody }>, reply: FastifyReply) => {\n    return ASRController.streamAudio(request, reply);\n  });\n\n  // Get ASR summary for phase transition\n  fastify.post('/asr/summarize', async (request: FastifyRequest<{ Body: SummarizePhaseBody }>, reply: FastifyReply) => {\n    return ASRController.summarizePhase(request, reply);\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/routes/dataRoutes.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 6,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { dataManager } from '../data/dataManager';\nimport { NodeScriptDataSource } from '../data/nodeScriptDataSource';\nimport { logger } from '../utils/logger';\n\ninterface TownParams {\n  id: string;\n}\n\ninterface CharacterParams {\n  id: string;\n}\n\ninterface SearchQuery {\n  q?: string;\n  category?: string;\n  edition?: string;\n  tags?: string;\n}\n\nexport default async function dataRoutes(fastify: FastifyInstance) {\n  // Initialize data manager\n  await dataManager.initialize();\n\n  // Towns endpoints\n  fastify.get('/api/towns', async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const towns = await dataManager.getAllTowns();\n      return reply.send({ towns });\n    } catch (error) {\n      logger.error('Error fetching towns');\n      return reply.status(500).send({ error: 'Failed to fetch towns' });\n    }\n  });\n\n  fastify.get('/api/towns/:id', async (request: FastifyRequest<{ Params: TownParams }>, reply: FastifyReply) => {\n    try {\n      const { id } = request.params;\n      const town = await dataManager.getTownById(id);\n      \n      if (!town) {\n        return reply.status(404).send({ error: 'Town not found' });\n      }\n\n      const characters = await dataManager.getCharactersByTown(id);\n      return reply.send({ town, characters });\n    } catch (error) {\n      logger.error('Error fetching town');\n      return reply.status(500).send({ error: 'Failed to fetch town' });\n    }\n  });\n\n  // Characters endpoints\n  fastify.get('/api/characters', async (request: FastifyRequest<{ Querystring: SearchQuery }>, reply: FastifyReply) => {\n    try {\n      const { q, category, edition, tags } = request.query;\n      let characters = await dataManager.getAllCharacters();\n\n      // Apply filters\n      if (q) {\n        characters = await dataManager.searchCharacters(q);\n      }\n\n      if (category) {\n        characters = characters.filter(c => c.category === category);\n      }\n\n      if (edition) {\n        characters = characters.filter(c => c.edition.includes(edition));\n      }\n\n      if (tags) {\n        const searchTags = tags.split(',').map(t => t.trim().toLowerCase());\n        characters = characters.filter(c => \n          c.tags.some(tag => searchTags.includes(tag.toLowerCase()))\n        );\n      }\n\n      return reply.send({ characters });\n    } catch (error) {\n      logger.error('Error fetching characters');\n      return reply.status(500).send({ error: 'Failed to fetch characters' });\n    }\n  });\n\n  fastify.get('/api/characters/:id', async (request: FastifyRequest<{ Params: CharacterParams }>, reply: FastifyReply) => {\n    try {\n      const { id } = request.params;\n      const character = await dataManager.getCharacterById(id);\n      \n      if (!character) {\n        return reply.status(404).send({ error: 'Character not found' });\n      }\n\n      return reply.send({ character });\n    } catch (error) {\n      logger.error('Error fetching character');\n      return reply.status(500).send({ error: 'Failed to fetch character' });\n    }\n  });\n\n  // Search endpoints\n  fastify.get('/api/search/towns', async (request: FastifyRequest<{ Querystring: { q: string } }>, reply: FastifyReply) => {\n    try {\n      const { q } = request.query;\n      if (!q) {\n        return reply.status(400).send({ error: 'Query parameter \"q\" is required' });\n      }\n\n      const towns = await dataManager.searchTowns(q);\n      return reply.send({ towns });\n    } catch (error) {\n      logger.error('Error searching towns');\n      return reply.status(500).send({ error: 'Failed to search towns' });\n    }\n  });\n\n  fastify.get('/api/search/characters', async (request: FastifyRequest<{ Querystring: { q: string } }>, reply: FastifyReply) => {\n    try {\n      const { q } = request.query;\n      if (!q) {\n        return reply.status(400).send({ error: 'Query parameter \"q\" is required' });\n      }\n\n      const characters = await dataManager.searchCharacters(q);\n      return reply.send({ characters });\n    } catch (error) {\n      logger.error('Error searching characters');\n      return reply.status(500).send({ error: 'Failed to search characters' });\n    }\n  });\n\n  // Statistics endpoint\n  fastify.get('/api/statistics', async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const statistics = await dataManager.getStatistics();\n      return reply.send({ statistics });\n    } catch (error) {\n      logger.error('Error fetching statistics');\n      return reply.status(500).send({ error: 'Failed to fetch statistics' });\n    }\n  });\n\n  // Import endpoints (for admin use)\n  fastify.post('/api/import/towns', async (request: FastifyRequest<{ Body: { filePath: string } }>, reply: FastifyReply) => {\n    try {\n      const { filePath } = request.body;\n      if (!filePath) {\n        return reply.status(400).send({ error: 'File path is required' });\n      }\n\n      await dataManager.importTownsFromFile(filePath);\n      return reply.send({ success: true, message: 'Towns imported successfully' });\n    } catch (error) {\n      logger.error('Error importing towns');\n      return reply.status(500).send({ error: 'Failed to import towns' });\n    }\n  });\n\n  fastify.post('/api/import/characters', async (request: FastifyRequest<{ Body: { filePath: string } }>, reply: FastifyReply) => {\n    try {\n      const { filePath } = request.body;\n      if (!filePath) {\n        return reply.status(400).send({ error: 'File path is required' });\n      }\n\n      await dataManager.importCharactersFromFile(filePath);\n      return reply.send({ success: true, message: 'Characters imported successfully' });\n    } catch (error) {\n      logger.error('Error importing characters');\n      return reply.status(500).send({ error: 'Failed to import characters' });\n    }\n  });\n\n  // Export endpoint\n  fastify.post('/api/export', async (request: FastifyRequest<{ Body: { outputDir: string } }>, reply: FastifyReply) => {\n    try {\n      const { outputDir } = request.body;\n      if (!outputDir) {\n        return reply.status(400).send({ error: 'Output directory is required' });\n      }\n\n      await dataManager.exportData(outputDir);\n      return reply.send({ success: true, message: 'Data exported successfully' });\n    } catch (error) {\n      logger.error('Error exporting data');\n      return reply.status(500).send({ error: 'Failed to export data' });\n    }\n  });\n\n  // Script data endpoints\n  const scriptDataSource = new NodeScriptDataSource();\n\n  fastify.get('/api/data/scripts/:scriptPath*/characters', async (request: FastifyRequest<{ Params: { scriptPath: string } }>, reply: FastifyReply) => {\n    try {\n      const { scriptPath } = request.params;\n      const characters = await scriptDataSource.loadCharacters(scriptPath);\n      return reply.send(characters);\n    } catch (error) {\n      logger.error(`Error loading characters for script ${request.params.scriptPath}:`, error);\n      return reply.status(404).send({ error: 'Script characters not found' });\n    }\n  });\n\n  fastify.get('/api/data/scripts/:scriptPath*/metadata', async (request: FastifyRequest<{ Params: { scriptPath: string } }>, reply: FastifyReply) => {\n    try {\n      const { scriptPath } = request.params;\n      const metadata = await scriptDataSource.loadMetadata(scriptPath);\n      return reply.send(metadata);\n    } catch (error) {\n      logger.error(`Error loading metadata for script ${request.params.scriptPath}:`, error);\n      return reply.status(404).send({ error: 'Script metadata not found' });\n    }\n  });\n\n  fastify.get('/api/data/scripts', async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const scripts = await scriptDataSource.listAvailableScripts();\n      return reply.send({ scripts });\n    } catch (error) {\n      logger.error('Error listing available scripts:', error);\n      return reply.status(500).send({ error: 'Failed to list scripts' });\n    }\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/routes/journal.routes.ts",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 400.",
        "line": 15,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 15,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 20,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 20,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 28,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 28,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 30,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 30,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 42,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 42,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 50,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 50,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 52,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 52,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 64,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 64,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 73,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 73,
        "endColumn": 19
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 75,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 75,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 404.",
        "line": 87,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 87,
        "endColumn": 28
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 97,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 97,
        "endColumn": 21
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 500.",
        "line": 99,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 99,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { JournalService } from '../services/journal.service';\nimport { GameEngine } from '../game/engine';\n\nconst router = Router();\nconst gameEngine = new GameEngine();\n\n// Add a note to player's journal\nrouter.post('/:gameId/seats/:seatId/notes', (req, res) => {\n  try {\n    const { gameId, seatId } = req.params;\n    const { text } = req.body;\n\n    if (!text || typeof text !== 'string') {\n      return res.status(400).json({ error: 'Note text is required' });\n    }\n\n    const gameState = gameEngine.getGame(gameId);\n    if (!gameState) {\n      return res.status(404).json({ error: 'Game not found' });\n    }\n\n    JournalService.addNote(gameState, seatId, text);\n    \n    res.json({ success: true });\n  } catch (error) {\n    if (error instanceof Error) {\n    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });\n    } else {\n      res.status(500).json({ error });\n    }\n  }\n});\n\n// Get player's journal\nrouter.get('/:gameId/seats/:seatId/journal', (req, res) => {\n  try {\n    const { gameId, seatId } = req.params;\n\n    const gameState = gameEngine.getGame(gameId);\n    if (!gameState) {\n      return res.status(404).json({ error: 'Game not found' });\n    }\n\n    const journal = JournalService.getJournal(gameState, seatId);\n    \n    res.json({ journal });\n  } catch (error) {\n    if (error instanceof Error) {\n    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });\n    } else {\n      res.status(500).json({ error });\n    }\n  }\n});\n\n// Update available moves for a player\nrouter.post('/:gameId/seats/:seatId/moves', (req, res) => {\n  try {\n    const { gameId, seatId } = req.params;\n\n    const gameState = gameEngine.getGame(gameId);\n    if (!gameState) {\n      return res.status(404).json({ error: 'Game not found' });\n    }\n\n    JournalService.updateAvailableMoves(gameState, seatId);\n    \n    const journal = JournalService.getJournal(gameState, seatId);\n    res.json({ moves: journal?.moves || [] });\n  } catch (error) {\n    if (error instanceof Error) {\n    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });\n    } else {\n      res.status(500).json({ error });\n    }\n  }\n});\n\n// Storyteller: Get all journals for audit\nrouter.get('/:gameId/journals', (req, res) => {\n  try {\n    const { gameId } = req.params;\n\n    const gameState = gameEngine.getGame(gameId);\n    if (!gameState) {\n      return res.status(404).json({ error: 'Game not found' });\n    }\n\n    // TODO: Add authorization check to ensure this is the storyteller\n    \n    const journals = JournalService.getAllJournals(gameState);\n    \n    res.json({ journals });\n  } catch (error) {\n    if (error instanceof Error) {\n      res.status(500).json({ error: error.message });\n    } else {\n      res.status(500).json({ error });\n    }\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/routes/journalRoutes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/routes/setupRoutes.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 6,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';\nimport { GameEngine } from '../game/engine';\nimport { logger } from '../utils/logger';\nimport { RoleType } from '@botc/shared';\n\ninterface SetupParams {\n  gameId: string;\n}\n\ninterface EnterSetupBody {\n  storytellerSeatId: string;\n}\n\ninterface SelectCharactersBody {\n  storytellerSeatId: string;\n  characterIds: string[];\n}\n\ninterface ValidateSetupBody {\n  storytellerSeatId: string;\n}\n\ninterface CompleteSetupBody {\n  storytellerSeatId: string;\n}\n\nexport default async function setupRoutes(fastify: FastifyInstance, options: { gameEngine: GameEngine }) {\n  const { gameEngine } = options;\n  \n  // Enter setup phase\n  fastify.post<{ Params: SetupParams; Body: EnterSetupBody }>(\n    '/:gameId/setup/enter', \n    async (request: FastifyRequest<{ Params: SetupParams; Body: EnterSetupBody }>, reply: FastifyReply) => {\n      try {\n        const { gameId } = request.params;\n        const { storytellerSeatId } = request.body;\n\n        if (!storytellerSeatId) {\n          return reply.status(400).send({ error: 'storytellerSeatId is required' });\n        }\n\n        const result = await gameEngine.enterSetup(gameId, storytellerSeatId);\n        \n        if (!result.ok) {\n          return reply.status(400).send({ error: result.error });\n        }\n\n        return reply.send({ success: true });\n      } catch (error) {\n        logger.error('Error entering setup:', error);\n        return reply.status(500).send({ error: 'Internal server error' });\n      }\n    }\n  );\n\n  // Select characters for setup\n  fastify.post<{ Params: SetupParams; Body: SelectCharactersBody }>(\n    '/:gameId/setup/characters', \n    async (request: FastifyRequest<{ Params: SetupParams; Body: SelectCharactersBody }>, reply: FastifyReply) => {\n      try {\n        const { gameId } = request.params;\n        const { storytellerSeatId, characterIds } = request.body;\n\n        if (!storytellerSeatId) {\n          return reply.status(400).send({ error: 'storytellerSeatId is required' });\n        }\n\n        if (!Array.isArray(characterIds)) {\n          return reply.status(400).send({ error: 'characterIds must be an array' });\n        }\n\n        const result = await gameEngine.selectSetupCharacters(gameId, storytellerSeatId, characterIds);\n        \n        if (!result.ok) {\n          return reply.status(400).send({ error: result.error });\n        }\n\n        return reply.send({ success: true });\n      } catch (error) {\n        logger.error('Error selecting setup characters:', error);\n        return reply.status(500).send({ error: 'Internal server error' });\n      }\n    }\n  );\n\n  // Validate current setup\n  fastify.post<{ Params: SetupParams; Body: ValidateSetupBody }>(\n    '/:gameId/setup/validate', \n    async (request: FastifyRequest<{ Params: SetupParams; Body: ValidateSetupBody }>, reply: FastifyReply) => {\n      try {\n        const { gameId } = request.params;\n        const { storytellerSeatId } = request.body;\n\n        if (!storytellerSeatId) {\n          return reply.status(400).send({ error: 'storytellerSeatId is required' });\n        }\n\n  const result = await gameEngine.validateSetup(gameId, storytellerSeatId);\n        \n        if (!result.ok) {\n          return reply.status(400).send({ \n            error: result.error,\n            details: result.details \n          });\n        }\n\n  return reply.send({ success: true, valid: true, details: [] });\n      } catch (error) {\n        logger.error('Error validating setup:', error);\n        return reply.status(500).send({ error: 'Internal server error' });\n      }\n    }\n  );\n\n  // Complete setup and start game\n  fastify.post<{ Params: SetupParams; Body: CompleteSetupBody }>(\n    '/:gameId/setup/complete', \n    async (request: FastifyRequest<{ Params: SetupParams; Body: CompleteSetupBody }>, reply: FastifyReply) => {\n      try {\n        const { gameId } = request.params;\n        const { storytellerSeatId } = request.body;\n\n        if (!storytellerSeatId) {\n          return reply.status(400).send({ error: 'storytellerSeatId is required' });\n        }\n\n        const result = await gameEngine.completeSetup(gameId, storytellerSeatId);\n        \n        if (!result.ok) {\n          return reply.status(400).send({ error: result.error });\n        }\n\n        return reply.send({ success: true });\n      } catch (error) {\n        logger.error('Error completing setup:', error);\n        return reply.status(500).send({ error: 'Internal server error' });\n      }\n    }\n  );\n\n  // Get setup state\n  fastify.get<{ Params: SetupParams }>(\n    '/:gameId/setup', \n    async (request: FastifyRequest<{ Params: SetupParams }>, reply: FastifyReply) => {\n      try {\n        const { gameId } = request.params;\n        const game = gameEngine.getGame(gameId);\n\n        if (!game) {\n          return reply.status(404).send({ error: 'Game not found' });\n        }\n\n        // Enrich setup state for client convenience\n        let script: any = null;\n        try {\n          script = await gameEngine.getScript(game.scriptId);\n        } catch {}\n\n  const playerCount = game.seats.filter((s: any) => !s.isStoryteller).length;\n\n        // Compute base distribution\n        const baseDistribution = (() => {\n          if (playerCount >= 5 && playerCount <= 6) {\n            return { townsfolk: 3, outsiders: 1, minions: 1, demons: 1 };\n          } else if (playerCount >= 7 && playerCount <= 9) {\n            return { townsfolk: playerCount - 3, outsiders: 0, minions: 2, demons: 1 };\n          } else if (playerCount >= 10 && playerCount <= 12) {\n            return { townsfolk: playerCount - 4, outsiders: 1, minions: 2, demons: 1 };\n          } else if (playerCount >= 13 && playerCount <= 15) {\n            return { townsfolk: playerCount - 5, outsiders: 2, minions: 2, demons: 1 };\n          }\n          return {\n            townsfolk: Math.max(2, playerCount - 3),\n            outsiders: Math.max(0, Math.min(2, playerCount - 6)),\n            minions: Math.min(2, Math.max(1, Math.floor(playerCount / 4))),\n            demons: 1\n          };\n        })();\n\n        // Apply character modifications from setup (if any)\n        const expectedDistribution = { ...baseDistribution } as Record<string, number>;\n        const mods = game.setupState?.characterModifications || [];\n        for (const mod of mods) {\n          switch (mod.type) {\n            case 'add_outsiders':\n              expectedDistribution.outsiders += mod.count; break;\n            case 'remove_townsfolk':\n              expectedDistribution.townsfolk -= mod.count; break;\n            case 'add_minions':\n              expectedDistribution.minions += mod.count; break;\n            case 'remove_outsiders':\n              expectedDistribution.outsiders -= mod.count; break;\n          }\n        }\n\n        // Map available characters from script\n        const availableCharacters = Array.isArray(script?.roles) ? script.roles.map((r: any) => ({\n          id: r.id,\n          name: r.name,\n          team: r.type === RoleType.TOWNSFOLK ? 'townsfolk'\n            : r.type === RoleType.OUTSIDER ? 'outsiders'\n            : r.type === RoleType.MINION ? 'minions'\n            : r.type === RoleType.DEMON ? 'demons'\n            : 'unknown',\n          ability: r.ability ? r.ability.id.replace(/[-_]/g, ' ') : '',\n          firstNight: undefined,\n          otherNight: undefined,\n          reminders: undefined\n        })) : [];\n\n        const enrichedSetup = {\n          ...(game.setupState || {}),\n          availableCharacters,\n          expectedDistribution,\n          scriptName: script?.name || game.scriptId\n        };\n\n        return reply.send({\n          setupState: enrichedSetup,\n          grimoireState: game.grimoireState,\n          phase: game.phase\n        });\n      } catch (error) {\n        logger.error('Error getting setup state:', error);\n        return reply.status(500).send({ error: 'Internal server error' });\n      }\n    }\n  );\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/asrService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token sessions",
        "line": 6,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { randomUUID } from 'crypto';\nimport { PTTSession, GameEvent, ASRSummaryRequest, ASRSummaryResponse, PTTJournalEntry } from '@botc/shared';\nimport { logger } from '../utils/logger';\n\nexport class ASRService {\n  private sessions: Map<string, PTTSession> = new Map();\n  private events: Map<string, GameEvent[]> = new Map();\n\n  /**\n   * Process streaming audio data for ASR\n   */\n  async processAudioStream(audioData: string, sessionId: string, seatId: string): Promise<{\n    transcript?: string;\n    wordLevelTranscript?: any[];\n    confidence?: number;\n  }> {\n    try {\n      // TODO: Integrate with actual ASR service (e.g., Google Speech-to-Text, Azure Speech, etc.)\n      // For now, return mock data\n      logger.info(`Processing audio stream for session ${sessionId}, seat ${seatId}`);\n\n      // Mock ASR processing\n      const mockTranscript = \"This is a mock transcript of the audio data\";\n      const mockWordLevel = [\n        { word: \"This\", start: 0, end: 0.5, confidence: 0.95 },\n        { word: \"is\", start: 0.5, end: 0.8, confidence: 0.92 },\n        { word: \"a\", start: 0.8, end: 0.9, confidence: 0.98 },\n        { word: \"mock\", start: 0.9, end: 1.2, confidence: 0.88 },\n        { word: \"transcript\", start: 1.2, end: 1.8, confidence: 0.91 }\n      ];\n\n      return {\n        transcript: mockTranscript,\n        wordLevelTranscript: mockWordLevel,\n        confidence: 0.92\n      };\n    } catch (error) {\n      logger.error('Error processing audio stream:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract game events from transcript\n   */\n  extractGameEvents(transcript: string, seatId: string): GameEvent[] {\n    const events: GameEvent[] = [];\n    const lowerTranscript = transcript.toLowerCase();\n\n    // Mock event extraction - in real implementation, use NLP/ML\n    if (lowerTranscript.includes('nominate') || lowerTranscript.includes('i nominate')) {\n      events.push({\n        id: randomUUID(),\n        type: 'nomination',\n        seatId,\n        timestamp: new Date(),\n        content: transcript,\n        confidence: 0.85\n      });\n    }\n\n    if (lowerTranscript.includes('vote') || lowerTranscript.includes('i vote')) {\n      events.push({\n        id: randomUUID(),\n        type: 'vote',\n        seatId,\n        timestamp: new Date(),\n        content: transcript,\n        confidence: 0.90\n      });\n    }\n\n    if (lowerTranscript.includes('claim') || lowerTranscript.includes('i am')) {\n      events.push({\n        id: randomUUID(),\n        type: 'claim',\n        seatId,\n        timestamp: new Date(),\n        content: transcript,\n        confidence: 0.75\n      });\n    }\n\n    // Check for contradictions or suspicious statements\n    if (lowerTranscript.includes('but') || lowerTranscript.includes('however') || lowerTranscript.includes('actually')) {\n      events.push({\n        id: randomUUID(),\n        type: 'contradiction',\n        seatId,\n        timestamp: new Date(),\n        content: transcript,\n        confidence: 0.60\n      });\n    }\n\n    return events;\n  }\n\n  /**\n   * Generate phase summary and watchlist\n   */\n  async generateSummary(request: ASRSummaryRequest): Promise<ASRSummaryResponse> {\n    try {\n      logger.info(`Generating summary for phase ${request.phase}`);\n\n      // Mock summary generation - in real implementation, use LLM\n      const highlights = [\n        \"Key nominations were made during this phase\",\n        \"Several votes were cast with interesting patterns\",\n        \"Some players made claims about their roles\"\n      ];\n\n      const watchlist = request.events\n        .filter(event => event.confidence && event.confidence > 0.8)\n        .slice(0, 3) // Top 3 suspicious events\n        .map(event => ({\n          seatId: event.seatId,\n          reason: `Suspicious ${event.type} detected`,\n          priority: event.confidence! > 0.9 ? 'high' as const : event.confidence! > 0.8 ? 'medium' as const : 'low' as const\n        }));\n\n      const summary = `During the ${request.phase} phase, ${request.turns.length} speaking turns were recorded and ${request.events.length} game events were detected. The most notable activities included nominations, voting, and role claims.`;\n\n      return {\n        highlights,\n        watchlist,\n        summary\n      };\n    } catch (error) {\n      logger.error('Error generating summary:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Redact night information from summary for non-storyteller players\n   */\n  redactForPlayer(summary: ASRSummaryResponse, viewerRole: string): ASRSummaryResponse {\n    if (viewerRole === 'storyteller') {\n      return summary; // Storyteller sees everything\n    }\n\n    // Redact night-specific information\n    return {\n      ...summary,\n      highlights: summary.highlights.filter(h =>\n        !h.toLowerCase().includes('night') &&\n        !h.toLowerCase().includes('demon') &&\n        !h.toLowerCase().includes('minion')\n      ),\n      watchlist: summary.watchlist.filter(w =>\n        !w.reason.toLowerCase().includes('night')\n      ),\n      summary: summary.summary.replace(/night|demon|minion/gi, '[REDACTED]')\n    };\n  }\n\n  /**\n   * Store session data\n   */\n  storeSession(session: PTTSession): void {\n    this.sessions.set(session.id, session);\n  }\n\n  /**\n   * Store game events\n   */\n  storeEvents(gameId: string, events: GameEvent[]): void {\n    const existing = this.events.get(gameId) || [];\n    this.events.set(gameId, [...existing, ...events]);\n  }\n\n  /**\n   * Get recent sessions and events for a game\n   */\n  getRecentData(gameId: string, limit: number = 50): { turns: PTTSession[], events: GameEvent[] } {\n    const turns = Array.from(this.sessions.values())\n      .filter(s => s.seatId.startsWith(gameId.slice(0, 8))) // Rough game association\n      .sort((a, b) => b.startTime.getTime() - a.startTime.getTime())\n      .slice(0, limit);\n\n    const events = this.events.get(gameId) || [];\n\n    return { turns, events };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/available-moves.service.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 8,
        "column": 14,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, Seat, AvailableMove, GamePhase } from '@botc/shared';\n\nexport class AvailableMovesService {\n  /**\n   * Generate available moves for a player based on their character, game state, and current phase\n   */\n  static generateAvailableMoves(\n    gameState: GameState,\n    seatId: string,\n    phase: GamePhase\n  ): AvailableMove[] {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat || !seat.role) {\n      return this.getGenericMoves(phase);\n    }\n\n    const moves: AvailableMove[] = [];\n    \n    // Add generic moves available to all players\n    moves.push(...this.getGenericMoves(phase));\n    \n    // Add character-specific moves\n    moves.push(...this.getCharacterSpecificMoves(seat, gameState, phase));\n    \n    // Add phase-specific moves\n    moves.push(...this.getPhaseSpecificMoves(seat, gameState, phase));\n    \n    return moves;\n  }\n\n  private static getGenericMoves(phase: GamePhase): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n\n    switch (phase) {\n      case GamePhase.DAY:\n        moves.push({\n          id: 'take_notes',\n          label: 'Take Notes',\n          description: 'Record observations, suspicions, or information in your journal'\n        });\n        moves.push({\n          id: 'whisper_with_player',\n          label: 'Whisper with Player',\n          description: 'Have a private conversation with another player'\n        });\n        moves.push({\n          id: 'make_public_statement',\n          label: 'Make Public Statement',\n          description: 'Share information or suspicions with the whole group'\n        });\n        moves.push({\n          id: 'analyze_voting_patterns',\n          label: 'Analyze Voting Patterns',\n          description: 'Look at how players voted in previous nominations for clues'\n        });\n        break;\n      \n      case GamePhase.NOMINATION:\n        moves.push({\n          id: 'nominate_player',\n          label: 'Nominate Player',\n          description: 'Put a player up for execution (if you haven\\'t already today)'\n        });\n        moves.push({\n          id: 'evaluate_nomination',\n          label: 'Evaluate Nomination',\n          description: 'Consider whether to vote for the current nominee'\n        });\n        break;\n      \n      case GamePhase.VOTE:\n        moves.push({\n          id: 'vote_execute',\n          label: 'Vote to Execute',\n          description: 'Vote to execute the nominated player'\n        });\n        moves.push({\n          id: 'vote_pardon',\n          label: 'Vote to Pardon',\n          description: 'Vote to spare the nominated player'\n        });\n        break;\n      \n      case GamePhase.NIGHT:\n        moves.push({\n          id: 'review_day_events',\n          label: 'Review Day Events',\n          description: 'Think about what happened during the day and update your notes'\n        });\n        break;\n    }\n\n    return moves;\n  }\n\n  private static getCharacterSpecificMoves(\n    seat: Seat,\n    gameState: GameState,\n    phase: GamePhase\n  ): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n    \n    if (!seat.role) return moves;\n\n    // Information-sharing characters (like Chef, Empath, Fortune Teller)\n    if (this.isInformationCharacter(seat.role)) {\n      if (phase === GamePhase.DAY) {\n        moves.push({\n          id: 'share_information',\n          label: 'Share Your Information',\n          description: `Reveal what you learned as the ${seat.role}`\n        });\n        moves.push({\n          id: 'coordinate_with_others',\n          label: 'Coordinate with Other Info Characters',\n          description: 'Work with other information characters to cross-reference data'\n        });\n      }\n    }\n\n    // Detective characters (like Investigator, Washerwoman, Librarian)\n    if (this.isDetectiveCharacter(seat.role)) {\n      if (phase === GamePhase.DAY) {\n        moves.push({\n          id: 'question_suspects',\n          label: 'Question Your Suspects',\n          description: 'Talk to the players from your information to gather more clues'\n        });\n      }\n    }\n\n    // Protective characters (like Monk, Soldier)\n    if (this.isProtectiveCharacter(seat.role)) {\n      if (phase === GamePhase.DAY) {\n        moves.push({\n          id: 'coordinate_protection',\n          label: 'Coordinate Protection',\n          description: 'Work with other good players to protect important targets'\n        });\n      }\n    }\n\n    return moves;\n  }\n\n  private static getPhaseSpecificMoves(\n    seat: Seat,\n    gameState: GameState,\n    phase: GamePhase\n  ): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n\n    // Add moves based on specific game situations\n    if (phase === GamePhase.DAY && gameState.day > 1) {\n      moves.push({\n        id: 'analyze_death_pattern',\n        label: 'Analyze Death Pattern',\n        description: 'Consider who died and what that might reveal about evil players'\n      });\n    }\n\n    // Final day considerations\n    if (this.isFinalDay(gameState)) {\n      moves.push({\n        id: 'final_day_strategy',\n        label: 'Final Day Strategy',\n        description: 'Consider who must be the demon to win the game'\n      });\n    }\n\n    return moves;\n  }\n\n  private static isInformationCharacter(role: string): boolean {\n    const infoCharacters = ['chef', 'empath', 'fortune-teller', 'clockmaker', 'seamstress'];\n    return infoCharacters.includes(role.toLowerCase());\n  }\n\n  private static isDetectiveCharacter(role: string): boolean {\n    const detectiveCharacters = ['investigator', 'washerwoman', 'librarian', 'steward'];\n    return detectiveCharacters.includes(role.toLowerCase());\n  }\n\n  private static isProtectiveCharacter(role: string): boolean {\n    const protectiveCharacters = ['monk', 'soldier', 'tea-lady', 'innkeeper'];\n    return protectiveCharacters.includes(role.toLowerCase());\n  }\n\n  private static isFinalDay(gameState: GameState): boolean {\n    const aliveCount = gameState.seats.filter(s => s.isAlive).length;\n    return aliveCount <= 3;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/characterDatabase.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 6,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { promises as fs } from 'fs';\nimport path from 'path';\nimport { Character } from '@botc/shared';\nimport { logger } from '../utils/logger';\n\ninterface CentralizedCharacter {\n  id: string;\n  name: string;\n  team?: 'townsfolk' | 'outsider' | 'minion' | 'demon' | 'traveller' | 'fabled';\n  category?: 'townsfolk' | 'outsider' | 'minion' | 'demon' | 'traveller' | 'fabled';\n  editions?: string[];\n  ability?: string;\n  ability_summary?: string;\n  ability_description?: string;\n  firstNight?: number | null;\n  otherNights?: number | null;\n  firstNightDescription?: string;\n  otherNightReminder?: string;\n  first_night_reminder?: string;\n  other_night_reminder?: string;\n  setup?: boolean;\n  reminders?: string[];\n  tokens_used?: string[];\n  tags?: string[];\n  wikiUrl?: string;\n  wiki_url?: string;\n  imageUrl?: string | null;\n  image_url?: string;\n  howToRun?: string;\n  tipsAndTricks?: string;\n  bluffing?: string;\n  legacy?: any;\n  actions?: any;\n  goal?: any;\n}\n\nclass CharacterDatabase {\n  private characterCache = new Map<string, Character>();\n  private initialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    \n    logger.info('📚 Initializing centralized character database...');\n    const startTime = Date.now();\n    \n    await this.loadAllCharacters();\n    \n    const endTime = Date.now();\n    logger.info(`✅ Character database initialized in ${endTime - startTime}ms - ${this.characterCache.size} characters loaded`);\n    this.initialized = true;\n  }\n\n  private async loadAllCharacters(): Promise<void> {\n    const charactersPath = path.join(__dirname, '../../../../data/characters');\n    \n    try {\n      const files = await fs.readdir(charactersPath);\n      const characterFiles = files.filter(file => file.endsWith('.json') && file !== 'README.md');\n      \n      const loadPromises = characterFiles.map(async (file) => {\n        try {\n          const filePath = path.join(charactersPath, file);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const charData: CentralizedCharacter = JSON.parse(content);\n          \n          const character: Character = this.transformCentralizedCharacter(charData);\n          this.characterCache.set(character.id, character);\n          \n        } catch (error) {\n          logger.warn(`⚠️  Failed to load character from ${file}:`, error instanceof Error ? error.message : 'Unknown error');\n        }\n      });\n      \n      await Promise.all(loadPromises);\n      \n    } catch (error) {\n      logger.error('Failed to load character database:', error instanceof Error ? error.message : 'Unknown error');\n    }\n  }\n\n  private transformCentralizedCharacter(char: CentralizedCharacter): Character {\n    return {\n      id: char.id,\n      name: char.name,\n      team: this.mapCategoryToTeam((char.team || char.category) ?? 'townsfolk'),\n      ability: char.ability || char.ability_summary || char.ability_description || '',\n      firstNight: char.firstNight || this.deriveFirstNightIndex(char),\n      otherNights: char.otherNights || this.deriveOtherNightsIndex(char),\n      reminders: char.reminders || char.tokens_used || [],\n      setup: char.setup || char.tags?.includes('setup') || false,\n      // Legacy fields for compatibility\n      category: (char.team || char.category) ?? 'townsfolk',\n      edition: char.editions || [],\n      abilitySummary: char.ability_summary,\n      firstNightAction: char.firstNightDescription || char.first_night_reminder,\n      otherNightsAction: char.otherNightReminder || char.other_night_reminder,\n      dayAction: null, // Not stored in centralized format yet\n      tags: char.tags || [],\n      tokensUsed: char.reminders || char.tokens_used || [],\n      wikiUrl: char.wikiUrl || char.wiki_url,\n      imageUrl: char.imageUrl || char.image_url\n    };\n  }\n\n  private mapCategoryToTeam(category: string): 'townsfolk' | 'outsider' | 'minion' | 'demon' | 'traveller' | 'fabled' {\n    const cat = category?.toLowerCase();\n    switch (cat) {\n      case 'townsfolk':\n        return 'townsfolk';\n      case 'outsider':\n      case 'outsiders':\n        return 'outsider';\n      case 'minion':\n      case 'minions':\n        return 'minion';\n      case 'demon':\n      case 'demons':\n        return 'demon';\n      case 'fabled':\n        return 'fabled';\n      case 'traveller':\n      case 'travellers':\n        return 'traveller';\n      default:\n        return 'townsfolk'; // Default fallback\n    }\n  }\n\n  private deriveFirstNightIndex(char: CentralizedCharacter): number | undefined {\n    // Simple heuristic based on tags and reminders\n    if (char.tags?.includes('setup') || char.first_night_reminder || char.firstNightDescription) {\n      if (char.tags?.includes('information')) return 10;\n      const category = char.team || char.category;\n      if (category === 'townsfolk') return 20;\n      if (category === 'outsider') return 30;\n      if (category === 'minion') return 40;\n      if (category === 'demon') return 50;\n    }\n    return undefined;\n  }\n\n  private deriveOtherNightsIndex(char: CentralizedCharacter): number | undefined {\n    // Simple heuristic\n    if (char.other_night_reminder || char.otherNightReminder) {\n      const category = char.team || char.category;\n      if (category === 'townsfolk') return 20;\n      if (category === 'outsider') return 30;\n      if (category === 'minion') return 40;\n      if (category === 'demon') return 50;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get a character by ID from the centralized database\n   */\n  getCharacter(id: string): Character | undefined {\n    return this.characterCache.get(id);\n  }\n\n  /**\n   * Get multiple characters by IDs\n   */\n  getCharacters(ids: string[]): Character[] {\n    return ids.map(id => this.getCharacter(id)).filter(Boolean) as Character[];\n  }\n\n  /**\n   * Get all characters from a specific edition\n   */\n  getCharactersByEdition(edition: string): Character[] {\n    return Array.from(this.characterCache.values()).filter(char => \n      char.edition?.includes(edition)\n    );\n  }\n\n  /**\n   * Get all characters\n   */\n  getAllCharacters(): Character[] {\n    return Array.from(this.characterCache.values());\n  }\n\n  /**\n   * Check if the database has been initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\nexport const characterDatabase = new CharacterDatabase();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/journal.service.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 8,
        "column": 27,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, Journal, JournalEntry, AvailableMove } from '@botc/shared';\nimport { AvailableMovesService } from './available-moves.service';\n\nexport class JournalService {\n  /**\n   * Add a note to a player's journal\n   */\n  static addNote(gameState: GameState, seatId: string, text: string): void {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat) throw new Error('Seat not found');\n\n    if (!seat.journal) {\n      seat.journal = { notes: [], moves: [] };\n    }\n\n    const note: JournalEntry = {\n      text,\n      timestamp: new Date()\n    };\n\n    seat.journal.notes.push(note);\n  }\n\n  /**\n   * Update available moves for a player's journal based on current game state\n   */\n  static updateAvailableMoves(gameState: GameState, seatId: string): void {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat) throw new Error('Seat not found');\n\n    if (!seat.journal) {\n      seat.journal = { notes: [], moves: [] };\n    }\n\n    // Generate available moves based on current game state and phase\n    const availableMoves = AvailableMovesService.generateAvailableMoves(\n      gameState,\n      seatId,\n      gameState.phase\n    );\n\n    seat.journal.moves = availableMoves;\n  }\n\n  /**\n   * Get a player's journal (for the player themselves or storyteller audit)\n   */\n  static getJournal(gameState: GameState, seatId: string): Journal | null {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    return seat?.journal || null;\n  }\n\n  /**\n   * Get all journals for storyteller audit\n   */\n  static getAllJournals(gameState: GameState): Record<string, Journal> {\n    const journals: Record<string, Journal> = {};\n    \n    for (const seat of gameState.seats) {\n      if (seat.journal) {\n        journals[seat.id] = seat.journal;\n      }\n    }\n\n    return journals;\n  }\n\n  /**\n   * Initialize journal for a player\n   */\n  static initializeJournal(gameState: GameState, seatId: string): void {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat) throw new Error('Seat not found');\n\n    seat.journal = { notes: [], moves: [] };\n    this.updateAvailableMoves(gameState, seatId);\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/journalService.test.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 5,
        "column": 16,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { JournalService } from '../services/journalService';\nimport { GameState, Seat, GamePhase, Character, Journal } from '@botc/shared';\n\ndescribe('JournalService', () => {\n  let gameState: GameState;\n  let playerSeat: Seat;\n  let character: Character;\n\n  beforeEach(() => {\n    // Create a mock game state\n    gameState = {\n      id: 'test-game',\n      phase: GamePhase.DAY,\n      day: 1,\n      seed: 'test-seed',\n      scriptId: 'test-script',\n      seats: [],\n      abilities: [],\n      availableScriptIds: [],\n      scriptProposals: [],\n      createdAt: new Date(),\n      updatedAt: new Date()\n    } as GameState;\n\n    // Create a mock player seat\n    playerSeat = {\n      id: 'seat-1',\n      isNPC: false,\n      position: 1,\n      isAlive: true,\n      votingPower: 1,\n      statuses: [],\n      journal: {\n        notes: [],\n        moves: []\n      }\n    };\n\n    // Create a mock character with available moves\n    character = {\n      id: 'chef',\n      name: 'Chef',\n      team: 'townsfolk',\n      ability: 'You start knowing how many pairs of evil players there are.',\n      availableMoves: {\n        morning: [\n          {\n            id: 'share_chef_info',\n            label: 'Share Chef Information',\n            description: 'Tell other players how many pairs of evil players you detected'\n          }\n        ],\n        day: [\n          {\n            id: 'analyze_seating',\n            label: 'Analyze Seating',\n            description: 'Look for patterns in player seating that might reveal evil pairs'\n          }\n        ]\n      }\n    };\n\n    gameState.seats = [playerSeat];\n  });\n\n  describe('getAvailableMovesForPlayer', () => {\n    it('should return universal moves for all players', () => {\n      const moves = JournalService.getAvailableMovesForPlayer(gameState, playerSeat);\n      \n      expect(moves).toContainEqual({\n        id: 'make_public_statement',\n        label: 'Make Public Statement',\n        description: 'Share information or make a claim to all players'\n      });\n      \n      expect(moves).toContainEqual({\n        id: 'talk_to_storyteller',\n        label: 'Talk to Storyteller',\n        description: 'Ask questions or clarify rules with the storyteller'\n      });\n    });\n\n    it('should include character-specific moves when character is provided', () => {\n      const moves = JournalService.getAvailableMovesForPlayer(gameState, playerSeat, character);\n      \n      expect(moves).toContainEqual({\n        id: 'share_chef_info',\n        label: 'Share Chef Information',\n        description: 'Tell other players how many pairs of evil players you detected'\n      });\n      \n      expect(moves).toContainEqual({\n        id: 'analyze_seating',\n        label: 'Analyze Seating',\n        description: 'Look for patterns in player seating that might reveal evil pairs'\n      });\n    });\n\n    it('should include nomination moves during nomination phase', () => {\n      gameState.phase = GamePhase.NOMINATION;\n      const moves = JournalService.getAvailableMovesForPlayer(gameState, playerSeat);\n      \n      expect(moves).toContainEqual({\n        id: 'nominate_player',\n        label: 'Nominate Player',\n        description: 'Nominate a player for execution'\n      });\n    });\n\n    it('should include night-specific moves during night phase', () => {\n      gameState.phase = GamePhase.NIGHT;\n      const moves = JournalService.getAvailableMovesForPlayer(gameState, playerSeat);\n      \n      expect(moves).toContainEqual({\n        id: 'use_night_ability',\n        label: 'Use Night Ability',\n        description: 'Use your character\\'s night ability if available'\n      });\n    });\n  });\n\n  describe('updatePlayerJournal', () => {\n    it('should initialize journal if it does not exist', () => {\n      playerSeat.journal = undefined;\n      JournalService.updatePlayerJournal(gameState, playerSeat.id, character);\n      \n      expect(playerSeat.journal).toBeDefined();\n      expect(playerSeat.journal!.notes).toEqual([]);\n      expect(playerSeat.journal!.moves).toBeDefined();\n    });\n\n    it('should update available moves in player journal', () => {\n      JournalService.updatePlayerJournal(gameState, playerSeat.id, character);\n      \n      expect(playerSeat.journal?.moves).toContainEqual({\n        id: 'share_chef_info',\n        label: 'Share Chef Information',\n        description: 'Tell other players how many pairs of evil players you detected'\n      });\n    });\n  });\n\n  describe('addJournalNote', () => {\n    it('should add a note to player journal', () => {\n      const noteText = 'I think Player 3 might be evil based on their voting pattern';\n      JournalService.addJournalNote(gameState, playerSeat.id, noteText);\n      \n      expect(playerSeat.journal!.notes).toHaveLength(1);\n      expect(playerSeat.journal!.notes[0].text).toBe(noteText);\n      expect(playerSeat.journal!.notes[0].timestamp).toBeInstanceOf(Date);\n    });\n\n    it('should initialize journal if it does not exist when adding note', () => {\n      playerSeat.journal = undefined;\n      JournalService.addJournalNote(gameState, playerSeat.id, 'Test note');\n      \n      expect(playerSeat.journal).toBeDefined();\n      expect(playerSeat.journal?.notes).toHaveLength(1);\n    });\n  });\n\n  describe('getPlayerJournalsForStoryteller', () => {\n    it('should return all player journals with notes', () => {\n      // Add notes to player journals\n      JournalService.addJournalNote(gameState, playerSeat.id, 'First note');\n      \n      // Add another player with a journal\n      const secondSeat: Seat = {\n        id: 'seat-2',\n        isNPC: false,\n        position: 2,\n        isAlive: true,\n        votingPower: 1,\n        statuses: [],\n        journal: {\n          notes: [{\n            text: 'Second player note',\n            timestamp: new Date()\n          }],\n          moves: []\n        }\n      };\n      gameState.seats.push(secondSeat);\n      \n      const journals = JournalService.getPlayerJournalsForStoryteller(gameState);\n      \n      expect(Object.keys(journals)).toHaveLength(2);\n      expect(journals[playerSeat.id]).toBeDefined();\n      expect(journals[secondSeat.id]).toBeDefined();\n    });\n\n    it('should not return journals without notes', () => {\n      // Player has journal but no notes\n      playerSeat.journal = { notes: [], moves: [] };\n      \n      const journals = JournalService.getPlayerJournalsForStoryteller(gameState);\n      \n      expect(Object.keys(journals)).toHaveLength(0);\n    });\n  });\n});\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/journalService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 10,
        "column": 46,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, Seat, AvailableMove, GamePhase, Character } from '@botc/shared';\n\n/**\n * Generates available moves for a player based on their character and current game state\n */\nexport class JournalService {\n  /**\n   * Get available moves for a player based on their seat and current game state\n   */\n  static getAvailableMovesForPlayer(gameState: GameState, seat: Seat, character?: Character): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n    \n    // Universal moves available to all players\n    moves.push(...this.getUniversalMoves(gameState, seat));\n    \n    // Character-specific moves\n    if (character?.actions) {\n      moves.push(...this.getCharacterSpecificMoves(gameState, character, seat));\n    }\n    \n    // Phase-specific moves\n    moves.push(...this.getPhaseSpecificMoves(gameState, seat));\n    \n    return moves;\n  }\n\n  /**\n   * Universal moves available to all players regardless of character\n   */\n  private static getUniversalMoves(gameState: GameState, seat: Seat): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n    \n    if (gameState.phase === GamePhase.DAY) {\n      moves.push({\n        id: 'make_public_statement',\n        label: 'Make Public Statement',\n        description: 'Share information or make a claim to all players'\n      });\n      \n      moves.push({\n        id: 'whisper_privately',\n        label: 'Whisper Privately',\n        description: 'Have a private conversation with another player'\n      });\n      \n      moves.push({\n        id: 'bluff',\n        label: 'Bluff',\n        description: 'Make a false claim to mislead other players'\n      });\n      \n      moves.push({\n        id: 'analyze_behavior',\n        label: 'Analyze Behavior',\n        description: 'Study other players for tells or suspicious behavior'\n      });\n    }\n    \n    if (gameState.phase === GamePhase.NOMINATION || gameState.phase === GamePhase.VOTE) {\n      if (seat.isAlive) {\n        moves.push({\n          id: 'nominate_player',\n          label: 'Nominate Player',\n          description: 'Nominate a player for execution'\n        });\n        \n        moves.push({\n          id: 'vote_on_nomination',\n          label: 'Vote on Nomination',\n          description: 'Cast your vote on the current nomination'\n        });\n      }\n    }\n    \n    // Always available moves\n    moves.push({\n      id: 'talk_to_storyteller',\n      label: 'Talk to Storyteller',\n      description: 'Ask questions or clarify rules with the storyteller'\n    });\n    \n    return moves;\n  }\n\n  /**\n   * Get character-specific moves based on the character's availableMoves configuration\n   */\n  private static getCharacterSpecificMoves(gameState: GameState, character: Character, seat: Seat): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n    if (!character.actions) return moves;\n    const mapToAvailableMove = (action: any): AvailableMove => ({\n      id: action.id,\n      label: action.label,\n      description: action.description\n    });\n    switch (gameState.phase) {\n      case GamePhase.DAY:\n        if (character.actions.firstNight) {\n          moves.push(...character.actions.firstNight.map(mapToAvailableMove));\n        }\n        if (character.actions.day) {\n          moves.push(...character.actions.day.map(mapToAvailableMove));\n        }\n        break;\n      case GamePhase.NOMINATION:\n        if (character.actions.nominations) {\n          moves.push(...character.actions.nominations.map(mapToAvailableMove));\n        }\n        break;\n      case GamePhase.NIGHT:\n        if (character.actions.night) {\n          moves.push(...character.actions.night.map(mapToAvailableMove));\n        }\n        break;\n    }\n    return moves;\n  }\n\n  /**\n   * Get phase-specific moves that apply to the current game phase\n   */\n  private static getPhaseSpecificMoves(gameState: GameState, seat: Seat): AvailableMove[] {\n    const moves: AvailableMove[] = [];\n    \n    switch (gameState.phase) {\n      case GamePhase.NIGHT:\n        if (seat.isAlive) {\n          moves.push({\n            id: 'use_night_ability',\n            label: 'Use Night Ability',\n            description: 'Use your character\\'s night ability if available'\n          });\n        }\n        break;\n        \n      case GamePhase.DAY:\n        moves.push({\n          id: 'share_information',\n          label: 'Share Information',\n          description: 'Reveal information you learned during the night'\n        });\n        \n        moves.push({\n          id: 'form_alliance',\n          label: 'Form Alliance',\n          description: 'Try to coordinate with other good players'\n        });\n        break;\n    }\n    \n    return moves;\n  }\n\n  /**\n   * Update a player's journal with new available moves\n   */\n  static updatePlayerJournal(gameState: GameState, seatId: string, character?: Character): void {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat) return;\n    \n    // Initialize journal if it doesn't exist\n    if (!seat.journal) {\n      seat.journal = {\n        notes: [],\n        moves: []\n      };\n    }\n    \n    // Update available moves\n    seat.journal.moves = this.getAvailableMovesForPlayer(gameState, seat, character);\n  }\n\n  /**\n   * Add a note to a player's journal\n   */\n  static addJournalNote(gameState: GameState, seatId: string, text: string): void {\n    const seat = gameState.seats.find(s => s.id === seatId);\n    if (!seat) return;\n    \n    // Initialize journal if it doesn't exist\n    if (!seat.journal) {\n      seat.journal = {\n        notes: [],\n        moves: []\n      };\n    }\n    \n    seat.journal.notes.push({\n      text,\n      timestamp: new Date()\n    });\n  }\n\n  /**\n   * Get all player journals for storyteller auditing\n   */\n  static getPlayerJournalsForStoryteller(gameState: GameState): Record<string, { playerName?: string; journal: any }> {\n    const journals: Record<string, any> = {};\n    \n    for (const seat of gameState.seats) {\n      if (seat.journal && seat.journal.notes.length > 0) {\n        journals[seat.id] = {\n          playerName: `Player ${seat.position}`, // You might want to add actual player names\n          journal: seat.journal\n        };\n      }\n    }\n    \n    return journals;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/matchmaking.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token gameEngine",
        "line": 6,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameId, GameState, SeatId } from '@botc/shared';\nimport { GameEngine } from '../game/engine';\nimport { logger } from '../utils/logger';\n\nexport class MatchmakingService {\n  private gameEngine: GameEngine;\n  // Optional callback to notify when a game's public state changes\n  private onUpdate?: (args: { gameId: GameId; game: GameState; eventType: string; payload?: Record<string, any> }) => void;\n\n  constructor(gameEngine: GameEngine) {\n    this.gameEngine = gameEngine;\n  }\n\n  setOnUpdate(cb: (args: { gameId: GameId; game: GameState; eventType: string; payload?: Record<string, any> }) => void) {\n    this.onUpdate = cb;\n  }\n\n  async createGame(scriptId?: string, options?: { isPublic?: boolean }): Promise<GameId> {\n    try {\n      const gameId = await this.gameEngine.createGame(scriptId, options);\n      logger.info(`Matchmaking created game: ${gameId}`);\n      const game = this.gameEngine.getGame(gameId);\n      if (game && this.onUpdate) {\n        this.onUpdate({ gameId, game, eventType: 'game_created' });\n      }\n      return gameId;\n    } catch (error) {\n      logger.error('Failed to create game:', error);\n      throw error;\n    }\n  }\n\n  async joinGame(gameId: GameId, playerId: string): Promise<SeatId | null> {\n    try {\n    const seatId = await this.gameEngine.addPlayer(gameId, playerId);\n    if (seatId) {\n        logger.info(`Player ${playerId} joined game ${gameId}`);\n        const game = this.gameEngine.getGame(gameId);\n        if (game && this.onUpdate) {\n      this.onUpdate({ gameId, game, eventType: 'player_joined', payload: { playerId, seatId } });\n        }\n      } else {\n        logger.warn(`Failed to add player ${playerId} to game ${gameId}`);\n      }\n      return seatId;\n    } catch (error) {\n      logger.error(`Error adding player ${playerId} to game ${gameId}:`, error);\n      return null;\n    }\n  }\n\n  async startGame(gameId: GameId): Promise<boolean> {\n    try {\n      const success = await this.gameEngine.startGame(gameId);\n      if (success) {\n        logger.info(`Game ${gameId} started successfully`);\n        const game = this.gameEngine.getGame(gameId);\n        if (game && this.onUpdate) {\n          this.onUpdate({ gameId, game, eventType: 'phase_changed', payload: { phase: game.phase } });\n        }\n      } else {\n        logger.warn(`Failed to start game ${gameId}`);\n      }\n      return success;\n    } catch (error) {\n      logger.error(`Error starting game ${gameId}:`, error);\n      return false;\n    }\n  }\n\n  async addNPC(gameId: GameId): Promise<boolean> {\n    try {\n      const seatId = await this.gameEngine.addPlayer(gameId, `npc-${Math.random().toString(36).slice(2,8)}`, true);\n      if (seatId) {\n        const game = this.gameEngine.getGame(gameId);\n        if (game && this.onUpdate) {\n          this.onUpdate({ gameId, game, eventType: 'player_joined', payload: { isNPC: true, seatId } });\n        }\n      }\n      return !!seatId;\n    } catch (error) {\n      logger.error(`Error adding NPC to game ${gameId}:`, error);\n      return false;\n    }\n  }\n\n  proposeScript(gameId: GameId, proposer: string, scriptId: string, active: boolean = true): boolean {\n    return !!this.gameEngine.proposeScript(gameId, proposer as any, scriptId, active);\n  }\n\n  voteOnScript(gameId: GameId, voterSeat: string, proposalId: string, vote: boolean | null | undefined): boolean {\n    return this.gameEngine.voteOnScript(gameId, voterSeat as any, proposalId, vote);\n  }\n\n  getActiveGames(): GameState[] {\n    return this.gameEngine.getActiveGames();\n  }\n\n  getPublicGames(): GameState[] {\n    return this.gameEngine.getPublicGames();\n  }\n\n  getGame(gameId: GameId): GameState | undefined {\n    return this.gameEngine.getGame(gameId);\n  }\n\n  // Queue system for matchmaking (future implementation)\n  private playerQueue: string[] = [];\n\n  addToQueue(playerId: string): void {\n    if (!this.playerQueue.includes(playerId)) {\n      this.playerQueue.push(playerId);\n      logger.info(`Player ${playerId} added to matchmaking queue`);\n      \n      // Try to match players\n      this.tryMatchPlayers();\n    }\n  }\n\n  removeFromQueue(playerId: string): void {\n    const index = this.playerQueue.indexOf(playerId);\n    if (index > -1) {\n      this.playerQueue.splice(index, 1);\n      logger.info(`Player ${playerId} removed from matchmaking queue`);\n    }\n  }\n\n  private async tryMatchPlayers(): Promise<void> {\n    // Simple matchmaking: create game when we have enough players\n    const minPlayers = 5;\n    \n    if (this.playerQueue.length >= minPlayers) {\n      try {\n        const gameId = await this.createGame();\n        \n        // Add first N players to the game\n        const playersToMatch = this.playerQueue.splice(0, minPlayers);\n        \n        for (const playerId of playersToMatch) {\n          await this.joinGame(gameId, playerId);\n        }\n\n        logger.info(`Matched ${playersToMatch.length} players to game ${gameId}`);\n      } catch (error) {\n        logger.error('Failed to match players:', error);\n        // Re-add players to queue on failure\n        // this.playerQueue.unshift(...playersToMatch);\n      }\n    }\n  }\n\n  getQueueLength(): number {\n    return this.playerQueue.length;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/services/scriptCache.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: The keyword 'interface' is reserved",
        "line": 7,
        "column": 1,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { promises as fs } from 'fs';\nimport path from 'path';\nimport { LoadedScript, Character, ScriptMetadata } from '@botc/shared';\nimport { logger } from '../utils/logger';\nimport { characterDatabase } from './characterDatabase';\n\ninterface ScriptListItem {\n  id: string;\n  name: string;\n  path: string;\n}\n\nclass ScriptCache {\n  private cache = new Map<string, LoadedScript>();\n  private scriptsMetadata = new Map<string, ScriptListItem>();\n  private initialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    \n    logger.info('🎭 Initializing script cache...');\n    const startTime = Date.now();\n    \n    // Initialize character database first\n    await characterDatabase.initialize();\n    \n    await this.loadAllScripts();\n    \n    const endTime = Date.now();\n    logger.info(`✅ Script cache initialized in ${endTime - startTime}ms - ${this.cache.size} scripts loaded`);\n    this.initialized = true;\n  }\n\n  private async loadAllScripts(): Promise<void> {\n    // Use the new centralized data architecture\n    const dataPath = path.join(__dirname, '../../../../data');\n    const scriptsPath = path.join(dataPath, 'scripts');\n    \n    try {\n      // Read all files in the scripts directory\n      const files = await fs.readdir(scriptsPath);\n      const jsonFiles = files.filter(file => file.endsWith('.json'));\n      \n      // Create script paths from all JSON files found\n      const scriptPaths: ScriptListItem[] = jsonFiles.map(file => {\n        const filePath = path.join('scripts', file);\n        const fullPath = path.join(scriptsPath, file);\n        return {\n          id: file.replace('.json', ''), // Use filename without extension as id\n          name: '', // Will be filled from JSON content\n          path: filePath\n        };\n      });\n\n      // Load all scripts in parallel for maximum speed\n      const loadPromises = scriptPaths.map(async ({ id, path: scriptPath }) => {\n        try {\n          const fullScriptPath = path.join(dataPath, scriptPath);\n          \n          // Load script definition\n          const scriptData = await fs.readFile(fullScriptPath, 'utf-8').then(JSON.parse);\n          \n          // Get characters from centralized database\n          const characters = characterDatabase.getCharacters(scriptData.characters || []);\n          \n          if (characters.length === 0) {\n            logger.warn(`⚠️  No characters found for script ${scriptData.name || id} - check character database`);\n          }\n\n          const script = {\n            id: scriptData.id || id,\n            name: scriptData.name || id,\n            characters: characters as Character[],\n            meta: this.createScriptMetadataFromNewFormat(scriptData, scriptData.id || id),\n            modifiers: Array.isArray(scriptData.modifiers) ? scriptData.modifiers : undefined\n          } as LoadedScript;\n\n          this.cache.set(scriptData.id || id, script);\n          this.scriptsMetadata.set(scriptData.id || id, { \n            id: scriptData.id || id, \n            name: scriptData.name || id, \n            path: scriptPath \n          });\n          \n          logger.info(`📜 Loaded script: ${scriptData.name || id} (${characters.length} characters)`);\n          \n        } catch (error) {\n          logger.warn(`⚠️  Failed to load script ${id}:`, error instanceof Error ? error.message : 'Unknown error');\n          \n          // Create fallback script with empty character list\n          const fallback: LoadedScript = {\n            id,\n            name: id,\n            characters: [],\n            meta: this.createScriptMetadata({ name: id }, id, 0)\n          };\n          this.cache.set(id, fallback);\n          this.scriptsMetadata.set(id, { id, name: id, path: scriptPath });\n        }\n      });\n\n      await Promise.all(loadPromises);\n    } catch (error) {\n      logger.error('Failed to read scripts directory:', error);\n      throw error;\n    }\n  }\n\n  private formatCharacterName(id: string): string {\n    return id\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  private createScriptMetadata(townData: any, scriptId: string, characterCount: number): ScriptMetadata {\n    const fallbackImages: Record<string, string> = {\n      'trouble-brewing': 'https://wiki.bloodontheclocktower.com/File:Logo_trouble_brewing.png',\n      'bad-moon-rising': 'https://wiki.bloodontheclocktower.com/File:Logo_bad_moon_rising.png',\n      'sects-and-violets': 'https://wiki.bloodontheclocktower.com/File:Logo_sects_and_violets.png'\n    };\n\n    const meta: ScriptMetadata = {\n      id: scriptId,\n      name: townData?.name || this.scriptsMetadata.get(scriptId)?.name || scriptId,\n      author: townData?.author,\n      description: townData?.description,\n      version: townData?.version || '1.0.0',\n      tags: townData?.tags,\n      playerCount: townData?.player_count || this.getDefaultPlayerCount(scriptId),\n      complexity: townData?.complexity || this.getComplexity(scriptId),\n      estimatedTime: townData?.estimated_time,\n      characterList: townData?.character_list,\n      characterDistribution: townData?.character_distribution,\n      scriptNotes: townData?.script_notes,\n      // Legacy fields\n      region: townData?.region,\n      population: townData?.population,\n      notableLocations: townData?.notable_locations,\n      resources: townData?.resources,\n      governance: townData?.governance,\n      coordinates: townData?.coordinates,\n      connections: townData?.connections,\n      wikiUrl: townData?.wiki_url,\n      imageUrl: townData?.image_url\n    };\n\n    if (!meta.imageUrl && fallbackImages[scriptId]) {\n      meta.imageUrl = fallbackImages[scriptId];\n    }\n\n    return meta;\n  }\n\n  private createScriptMetadataFromNewFormat(scriptData: any, scriptId: string): ScriptMetadata {\n    const meta: ScriptMetadata = {\n      id: scriptId,\n      name: scriptData.name || scriptId,\n      author: scriptData.author || 'Blood on the Clocktower',\n      description: scriptData.description || `${scriptData.name || scriptId} script for Blood on the Clocktower.`,\n      version: scriptData.version || '1.0.0',\n      tags: scriptData.tags || [],\n      playerCount: scriptData.playerCount || this.getDefaultPlayerCount(scriptId),\n      complexity: scriptData.complexity || this.getComplexity(scriptId),\n      estimatedTime: scriptData.estimatedTime || '60-90 minutes',\n      characterList: scriptData.characters || [],\n      characterDistribution: scriptData.characterDistribution || {},\n      scriptNotes: scriptData.specialRules || [],\n      imageUrl: `/script-art/${scriptId}.png` // Use local script art\n    };\n\n    return meta;\n  }\n\n  private getComplexity(scriptId: string): 'beginner' | 'intermediate' | 'advanced' {\n    const complexityMap: Record<string, 'beginner' | 'intermediate' | 'advanced'> = {\n      'trouble-brewing': 'beginner',\n      'bad-moon-rising': 'intermediate',\n      'sects-and-violets': 'advanced',\n      'experimental': 'advanced',\n      'fabled': 'intermediate',\n      'travellers': 'intermediate',\n      'no-greater-joy': 'beginner',\n      'catfishing': 'intermediate',\n      'chaos-theory': 'advanced',\n      'greatest-hits': 'intermediate',\n      'mad-as-a-hatter': 'advanced',\n      'on-thin-ice': 'intermediate'\n    };\n    return complexityMap[scriptId] || 'intermediate';\n  }\n\n  private getDefaultPlayerCount(scriptId: string): { min: number; max: number; optimal?: string } {\n    const standardCounts: Record<string, { min: number; max: number; optimal?: string }> = {\n      'trouble-brewing': { min: 5, max: 15, optimal: '7-10' },\n      'bad-moon-rising': { min: 5, max: 15, optimal: '7-10' },\n      'sects-and-violets': { min: 5, max: 15, optimal: '7-10' },\n      'experimental': { min: 5, max: 20, optimal: '8-12' },\n      'fabled': { min: 5, max: 20, optimal: '8-12' },\n      'travellers': { min: 5, max: 20, optimal: '8-12' },\n      'no-greater-joy': { min: 5, max: 6, optimal: '5-6' },\n    };\n    \n    return standardCounts[scriptId] || { min: 5, max: 15, optimal: '7-10' };\n  }\n\n  getAllScripts(): LoadedScript[] {\n    return Array.from(this.cache.values());\n  }\n\n  getScript(id: string): LoadedScript | null {\n    return this.cache.get(id) || null;\n  }\n\n  getScriptsList(): Array<{ id: string; name: string }> {\n    return Array.from(this.scriptsMetadata.values()).map(({ id, name }) => ({ id, name }));\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  getStats(): { scriptCount: number; totalCharacters: number } {\n    const scripts = this.getAllScripts();\n    return {\n      scriptCount: scripts.length,\n      totalCharacters: scripts.reduce((total, script) => total + script.characters.length, 0)\n    };\n  }\n}\n\n// Export singleton instance\nexport const scriptCache = new ScriptCache();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/state/journal.test.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token )",
        "line": 6,
        "column": 30,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, Seat, Journal, GamePhase } from '@botc/shared';\nimport { JournalService } from '../services/journal.service';\nimport { AvailableMovesService } from '../services/available-moves.service';\n\n// Mock a basic game state for testing\nconst createMockGameState = (): GameState => ({\n  id: 'test-game',\n  phase: GamePhase.DAY,\n  day: 1,\n  seed: 'test-seed',\n  scriptId: 'trouble-brewing',\n  seats: [\n    {\n      id: 'seat-1',\n      playerId: 'player-1',\n      isNPC: false,\n      position: 0,\n      isAlive: true,\n      votingPower: 1,\n      statuses: [],\n      role: 'chef'\n    }\n  ],\n  abilities: [],\n  availableScriptIds: [],\n  scriptProposals: [],\n  createdAt: new Date(),\n  updatedAt: new Date()\n});\n\ndescribe('Journal Management', () => {\n  let gameState: GameState;\n  let playerSeat: Seat;\n\n  beforeEach(() => {\n    gameState = createMockGameState();\n    playerSeat = gameState.seats[0];\n  });\n\n  it('should allow a player to add a note to their journal', () => {\n    JournalService.initializeJournal(gameState, playerSeat.id);\n    JournalService.addNote(gameState, playerSeat.id, 'This is a test note.');\n    \n    const journal = JournalService.getJournal(gameState, playerSeat.id);\n    expect(journal?.notes).toHaveLength(1);\n    expect(journal?.notes[0].text).toBe('This is a test note.');\n  });\n\n  it('should generate available moves for a player', () => {\n    const moves = AvailableMovesService.generateAvailableMoves(\n      gameState,\n      playerSeat.id,\n      GamePhase.DAY\n    );\n    \n    expect(moves.length).toBeGreaterThan(0);\n    expect(moves.some(move => move.id === 'take_notes')).toBe(true);\n  });\n\n  it('should update available moves when game state changes', () => {\n    JournalService.initializeJournal(gameState, playerSeat.id);\n    \n    const initialJournal = JournalService.getJournal(gameState, playerSeat.id);\n    const initialMovesCount = initialJournal?.moves.length || 0;\n    \n    // Change game phase\n    gameState.phase = GamePhase.NOMINATION;\n    JournalService.updateAvailableMoves(gameState, playerSeat.id);\n    \n    const updatedJournal = JournalService.getJournal(gameState, playerSeat.id);\n    expect(updatedJournal?.moves.length).toBeGreaterThan(0);\n    // Moves should be different for different phases\n    expect(updatedJournal?.moves.some(move => move.id === 'nominate_player')).toBe(true);\n  });\n\n  it('should allow the storyteller to audit all player journals', () => {\n    JournalService.initializeJournal(gameState, playerSeat.id);\n    JournalService.addNote(gameState, playerSeat.id, 'Secret note from player');\n    \n    const allJournals = JournalService.getAllJournals(gameState);\n    expect(allJournals[playerSeat.id]).toBeDefined();\n    expect(allJournals[playerSeat.id].notes).toHaveLength(1);\n  });\n});\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/types/jwks-client.d.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token module",
        "line": 1,
        "column": 9,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "declare module 'jwks-client' {\n  export interface SigningKey {\n    getPublicKey(): string;\n  }\n\n  export interface JwksClient {\n    getSigningKey(kid: string, callback: (err: Error | null, key?: SigningKey) => void): void;\n  }\n\n  export interface ClientOptions {\n    jwksUri: string;\n    requestHeaders?: Record<string, string>;\n    timeout?: number;\n  }\n\n  export default function jwksClient(options: ClientOptions): JwksClient;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/utils/logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/server/src/websocket/handler.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token connections",
        "line": 11,
        "column": 11,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FastifyRequest } from 'fastify';\nimport { SocketStream } from '@fastify/websocket';\nimport { WSMessage, GameId, SeatId } from '@botc/shared';\nimport { maskGameStateForSeat, maskGameStatePublic } from '@botc/shared';\nimport { randomUUID } from 'crypto';\nimport { GameEngine } from '../game/engine';\nimport { MatchmakingService } from '../services/matchmaking';\nimport { logger } from '../utils/logger';\n\nexport class WebSocketHandler {\n  private connections: Map<string, SocketStream> = new Map();\n  private gameSubscriptions: Map<GameId, Set<string>> = new Map();\n  private connectionViewerSeat: Map<string, SeatId | undefined> = new Map();\n\n  constructor(\n    private gameEngine: GameEngine,\n    private matchmaking: MatchmakingService\n  ) {}\n\n  handleConnection(connection: SocketStream, request: FastifyRequest): void {\n    const connectionId = this.generateConnectionId();\n    this.connections.set(connectionId, connection);\n\n    logger.info(`WebSocket connection established: ${connectionId}`);\n\n    connection.socket.on('message', (data: Buffer) => {\n      try {\n        const message: WSMessage = JSON.parse(data.toString());\n        this.handleMessage(connectionId, message);\n      } catch (error) {\n        logger.error(`Failed to parse WebSocket message from ${connectionId}:`, error);\n        this.sendError(connectionId, 'Invalid message format');\n      }\n    });\n\n    connection.socket.on('close', () => {\n      this.handleDisconnection(connectionId);\n    });\n\n  connection.socket.on('error', (error: Error) => {\n      logger.error(`WebSocket error for ${connectionId}:`, error);\n      this.handleDisconnection(connectionId);\n    });\n  }\n\n  private handleMessage(connectionId: string, message: WSMessage): void {\n    switch (message.type) {\n      case 'subscribe':\n        this.handleSubscribe(connectionId, message.gameId, message.viewerSeatId as SeatId | undefined);\n        break;\n      case 'cmd':\n        this.handleCommand(connectionId, message.cmd);\n        break;\n      default:\n        logger.warn(`Unknown message type from ${connectionId}:`, message);\n    }\n  }\n\n  private handleSubscribe(connectionId: string, gameId: GameId, viewerSeatId?: SeatId): void {\n    // Unsubscribe from previous game if any\n    this.unsubscribeFromAll(connectionId);\n\n    // Subscribe to new game\n    if (!this.gameSubscriptions.has(gameId)) {\n      this.gameSubscriptions.set(gameId, new Set());\n    }\n    this.gameSubscriptions.get(gameId)!.add(connectionId);\n  this.connectionViewerSeat.set(connectionId, viewerSeatId);\n\n    // Send current game state\n    const game = this.gameEngine.getGame(gameId);\n    if (game) {\n      // If viewerSeatId provided and not storyteller, mask; storyteller sees full\n      const snapshot = viewerSeatId\n        ? (game.storytellerSeatId === viewerSeatId ? game : maskGameStateForSeat(game, viewerSeatId))\n        : maskGameStatePublic(game);\n      this.sendToConnection(connectionId, {\n        type: 'event',\n        event: {\n          id: randomUUID(),\n          gameId,\n          type: 'game_created',\n          timestamp: new Date(),\n          payload: { gameState: snapshot as any }\n        }\n      });\n    } else {\n      this.sendError(connectionId, `Game ${gameId} not found`);\n    }\n\n    logger.info(`Connection ${connectionId} subscribed to game ${gameId}`);\n  }\n\n  private handleCommand(connectionId: string, cmd: any): void {\n    // Handle game commands\n    switch (cmd.kind) {\n      case 'nominate':\n        // Handle nomination\n        break;\n      case 'vote':\n        // Handle voting\n        break;\n      case 'chat':\n        // Handle chat message\n        break;\n      case 'ability':\n        // Handle ability usage\n        break;\n      default:\n        logger.warn(`Unknown command from ${connectionId}:`, cmd);\n    }\n  }\n\n  private handleDisconnection(connectionId: string): void {\n    this.unsubscribeFromAll(connectionId);\n    this.connections.delete(connectionId);\n    logger.info(`WebSocket connection closed: ${connectionId}`);\n  }\n\n  private unsubscribeFromAll(connectionId: string): void {\n    for (const [gameId, subscribers] of this.gameSubscriptions.entries()) {\n      subscribers.delete(connectionId);\n      if (subscribers.size === 0) {\n        this.gameSubscriptions.delete(gameId);\n      }\n    }\n  this.connectionViewerSeat.delete(connectionId);\n  }\n\n  private sendToConnection(connectionId: string, message: WSMessage): void {\n    const connection = this.connections.get(connectionId);\n    if (connection && connection.socket.readyState === 1) { // WebSocket.OPEN\n      try {\n        connection.socket.send(JSON.stringify(message));\n      } catch (error) {\n        logger.error(`Failed to send message to ${connectionId}:`, error);\n      }\n    }\n  }\n\n  private sendError(connectionId: string, error: string): void {\n    this.sendToConnection(connectionId, {\n      type: 'event',\n      event: {\n        id: randomUUID(),\n        gameId: '' as GameId,\n        type: 'game_created',\n        timestamp: new Date(),\n        payload: { error }\n      }\n    });\n  }\n\n  private generateConnectionId(): string {\n    return Math.random().toString(36).substring(2, 15);\n  }\n\n  // Broadcast event to all subscribers of a game\n  broadcastToGame(gameId: GameId, message: WSMessage): void {\n    const subscribers = this.gameSubscriptions.get(gameId);\n    if (subscribers) {\n      for (const connectionId of subscribers) {\n        // If message contains a snapshot, mask it per viewer\n        if (message.type === 'event' && (message as any).event?.payload?.gameState) {\n          const game = (message as any).event.payload.gameState;\n          const viewerSeatId = this.connectionViewerSeat.get(connectionId);\n          const masked = viewerSeatId\n            ? (game.storytellerSeatId === viewerSeatId ? game : maskGameStateForSeat(game, viewerSeatId))\n            : maskGameStatePublic(game);\n          const cloned = JSON.parse(JSON.stringify(message));\n          (cloned as any).event.payload.gameState = masked;\n          this.sendToConnection(connectionId, cloned);\n        } else {\n          this.sendToConnection(connectionId, message);\n        }\n      }\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-handlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-handlers.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 31,
        "column": 9,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Standard Action Handlers - Implementation of common game actions\n * These handlers implement the core mechanics for character abilities\n */\n\nimport {\n  CharacterActionType,\n  MetaActionType,\n  StatusEffect,\n  createEffect,\n} from './game-definitions';\nimport {\n  GameState,\n  Seat,\n  CharacterAction,\n  MetaAction,\n  ActionContext,\n  ActionResult,\n  RoleType,\n} from './types';\nimport { EffectProcessor } from './action-registry';\n\n// ============================================================================\n// INFORMATION GATHERING ACTIONS\n// ============================================================================\n\n/**\n * Chef: Count pairs of neighboring evil players\n */\nexport function handleLearnEvilPairsCount(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const playerSeats = getPlayerSeats(game);\n  let pairCount = 0;\n  \n  for (let i = 0; i < playerSeats.length; i++) {\n    const current = playerSeats[i];\n    const next = playerSeats[(i + 1) % playerSeats.length];\n    \n    if (isEvil(current) && isEvil(next)) {\n      pairCount++;\n    }\n  }\n\n  const information = action.information?.customMessage \n    ? action.information.customMessage.replace('[COUNT]', pairCount.toString())\n    : `You see ${pairCount} pairs of neighboring evil players`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      count: pairCount\n    }\n  };\n}\n\n/**\n * Empath: Count evil neighbors\n */\nexport function handleLearnEvilNeighborCount(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const playerSeats = getPlayerSeats(game);\n  const actingIndex = playerSeats.findIndex(s => s.id === actingSeat.id);\n  \n  if (actingIndex === -1) {\n    return {\n      actionId: action.id,\n      success: false,\n      errors: ['Acting seat not found among players']\n    };\n  }\n\n  const leftNeighbor = playerSeats[(actingIndex - 1 + playerSeats.length) % playerSeats.length];\n  const rightNeighbor = playerSeats[(actingIndex + 1) % playerSeats.length];\n  \n  const evilCount = (isEvil(leftNeighbor) ? 1 : 0) + (isEvil(rightNeighbor) ? 1 : 0);\n\n  const information = action.information?.customMessage \n    ? action.information.customMessage.replace('[COUNT]', evilCount.toString())\n    : `You see ${evilCount} evil neighbors`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      count: evilCount\n    }\n  };\n}\n\n/**\n * Investigative actions (Washerwoman, Librarian, Investigator, etc.)\n */\nexport function handleLearnPlayerInfo(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  // This is a more complex action that would need character-specific logic\n  // For now, return a placeholder implementation\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: \"You learn information about a player\",\n    }\n  };\n}\n\n// ============================================================================\n// PLAYER TARGETING ACTIONS\n// ============================================================================\n\n/**\n * Choose a player (generic targeting)\n */\nexport function handleChoosePlayer(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  // Apply any effects specified in the action\n  const targets = context.targets ? context.targets.map(id => game.seats.find(s => s.id === id)).filter(Boolean) as Seat[] : [];\n  \n  if (action.effects) {\n    EffectProcessor.applyEffects(action, targets, actingSeat, game);\n  }\n\n  const targetNames = targets.map(t => getSeatDisplayName(t)).join(', ');\n  const information = action.information?.customMessage \n    ? action.information.customMessage.replace('[PLAYER]', targetNames)\n    : `You chose ${targetNames}`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      targets: targets.map(t => t.id)\n    }\n  };\n}\n\n/**\n * Butler: Choose master player\n */\nexport function handleChooseMaster(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const targets = context.targets ? context.targets.map(id => game.seats.find(s => s.id === id)).filter(Boolean) as Seat[] : [];\n  \n  if (targets.length !== 1) {\n    return {\n      actionId: action.id,\n      success: false,\n      errors: ['Butler must choose exactly one master']\n    };\n  }\n\n  const master = targets[0];\n  \n  // Apply master status to selected player and voting restriction to butler\n  EffectProcessor.applyEffects(action, targets, actingSeat, game);\n\n  const information = action.information?.customMessage \n    ? action.information.customMessage.replace('[PLAYER]', getSeatDisplayName(master))\n    : `You chose ${getSeatDisplayName(master)} as your Master`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      master: master.id\n    }\n  };\n}\n\n// ============================================================================\n// KILLING AND PROTECTION ACTIONS\n// ============================================================================\n\n/**\n * Kill a player\n */\nexport function handleKillPlayer(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const targets = context.targets ? context.targets.map(id => game.seats.find(s => s.id === id)).filter(Boolean) as Seat[] : [];\n  \n  if (targets.length === 0) {\n    return {\n      actionId: action.id,\n      success: false,\n      errors: ['No valid targets for kill action']\n    };\n  }\n\n  // Apply death effect to targets\n  EffectProcessor.applyEffects(action, targets, actingSeat, game);\n\n  const killedPlayers = targets.map(t => getSeatDisplayName(t)).join(', ');\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: 'storyteller',\n      message: `${killedPlayers} killed by ${getSeatDisplayName(actingSeat)}`,\n      killed: targets.map(t => t.id)\n    }\n  };\n}\n\n/**\n * Protect a player\n */\nexport function handleProtectPlayer(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const targets = context.targets ? context.targets.map(id => game.seats.find(s => s.id === id)).filter(Boolean) as Seat[] : [];\n  \n  // Apply protection effect to targets\n  EffectProcessor.applyEffects(action, targets, actingSeat, game);\n\n  const protectedPlayers = targets.map(t => getSeatDisplayName(t)).join(', ');\n  const information = action.information?.customMessage \n    ? action.information.customMessage.replace('[PLAYER]', protectedPlayers)\n    : `You protected ${protectedPlayers}`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      protected: targets.map(t => t.id)\n    }\n  };\n}\n\n// ============================================================================\n// STATUS EFFECT ACTIONS\n// ============================================================================\n\n/**\n * Poison a player\n */\nexport function handlePoisonPlayer(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  const targets = context.targets ? context.targets.map(id => game.seats.find(s => s.id === id)).filter(Boolean) as Seat[] : [];\n  \n  // Apply poison effect to targets\n  EffectProcessor.applyEffects(action, targets, actingSeat, game);\n\n  const poisonedPlayers = targets.map(t => getSeatDisplayName(t)).join(', ');\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: 'storyteller',\n      message: `${poisonedPlayers} poisoned by ${getSeatDisplayName(actingSeat)}`,\n      poisoned: targets.map(t => t.id)\n    }\n  };\n}\n\n// ============================================================================\n// VOTING ACTIONS\n// ============================================================================\n\n/**\n * Enforce voting restriction (Butler)\n */\nexport function handleEnforceVotingRestriction(\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n): ActionResult {\n  // This would check if the master is voting and allow/deny the butler's vote\n  // For now, just apply the restriction effect\n  EffectProcessor.applyEffects(action, [], actingSeat, game);\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: 'storyteller',\n      message: `${getSeatDisplayName(actingSeat)} voting restriction enforced`,\n    }\n  };\n}\n\n// ============================================================================\n// META ACTIONS\n// ============================================================================\n\n/**\n * Show team information to minions\n */\nexport function handleShowTeamToMinions(\n  action: MetaAction,\n  context: ActionContext,\n  game: GameState\n): ActionResult {\n  const minions = game.seats.filter(seat => \n    seat.role && isMinion(seat)\n  );\n\n  const evilTeam = game.seats.filter(seat => \n    seat.role && (isMinion(seat) || isDemon(seat))\n  ).map(seat => getSeatDisplayName(seat));\n\n  // Send team information to each minion\n  const results = minions.map(minion => ({\n    recipient: minion.id,\n    message: `Your evil team: ${evilTeam.join(', ')}`,\n    team: evilTeam\n  }));\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipients: minions.map(m => m.id),\n      messages: results\n    }\n  };\n}\n\n/**\n * Show team and bluffs to demon\n */\nexport function handleShowTeamAndBluffsToDemon(\n  action: MetaAction,\n  context: ActionContext,\n  game: GameState\n): ActionResult {\n  const demons = game.seats.filter(seat => \n    seat.role && isDemon(seat)\n  );\n\n  const evilTeam = game.seats.filter(seat => \n    seat.role && (isMinion(seat) || isDemon(seat))\n  ).map(seat => getSeatDisplayName(seat));\n\n  // Generate bluff suggestions (this would be more sophisticated)\n  const bluffs = ['Washerwoman', 'Librarian', 'Investigator']; // Placeholder\n\n  const results = demons.map(demon => ({\n    recipient: demon.id,\n    message: `Your evil team: ${evilTeam.join(', ')}. Suggested bluffs: ${bluffs.join(', ')}`,\n    team: evilTeam,\n    bluffs\n  }));\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipients: demons.map(d => d.id),\n      messages: results\n    }\n  };\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\nfunction getPlayerSeats(game: GameState): Seat[] {\n  return game.seats.filter(seat => !seat.isStoryteller);\n}\n\nfunction getSeatDisplayName(seat: Seat): string {\n  // For now, use the seat ID or position as display name\n  // In a real implementation, this would look up the player name\n  return seat.playerId || `Player ${seat.position}` || `Seat ${seat.id.slice(-4)}`;\n}\n\nfunction isEvil(seat: Seat): boolean {\n  if (!seat.role) return false;\n  return isMinion(seat) || isDemon(seat);\n}\n\nfunction isMinion(seat: Seat): boolean {\n  // This would check the character's team/type\n  // Implementation depends on how we store role information\n  return seat.role?.includes('minion') ?? false; // Placeholder\n}\n\nfunction isDemon(seat: Seat): boolean {\n  // This would check the character's team/type\n  // Implementation depends on how we store role information\n  return seat.role?.includes('demon') ?? false; // Placeholder\n}\n\n// ============================================================================\n// ACTION HANDLER MAP\n// ============================================================================\n\n/**\n * Map of action types to their handler functions\n */\nexport const CHARACTER_ACTION_HANDLERS = {\n  [CharacterActionType.LEARN_EVIL_PAIRS_COUNT]: handleLearnEvilPairsCount,\n  [CharacterActionType.LEARN_EVIL_NEIGHBOR_COUNT]: handleLearnEvilNeighborCount,\n  [CharacterActionType.LEARN_PLAYER_INFO]: handleLearnPlayerInfo,\n  [CharacterActionType.CHOOSE_PLAYER]: handleChoosePlayer,\n  [CharacterActionType.CHOOSE_MASTER]: handleChooseMaster,\n  [CharacterActionType.KILL_PLAYER]: handleKillPlayer,\n  [CharacterActionType.PROTECT_PLAYER]: handleProtectPlayer,\n  [CharacterActionType.POISON_PLAYER]: handlePoisonPlayer,\n  [CharacterActionType.ENFORCE_VOTING_RESTRICTION]: handleEnforceVotingRestriction,\n} as const;\n\nexport const META_ACTION_HANDLERS = {\n  [MetaActionType.SHOW_TEAM_TO_MINIONS]: handleShowTeamToMinions,\n  [MetaActionType.SHOW_TEAM_AND_BLUFFS_TO_DEMON]: handleShowTeamAndBluffsToDemon,\n} as const;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-registry.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'seat' is defined but never used.",
        "line": 167,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 31
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'actionId' is defined but never used.",
        "line": 167,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 41
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'action' is defined but never used.",
        "line": 172,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 172,
        "endColumn": 31
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'context' is defined but never used.",
        "line": 172,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 172,
        "endColumn": 40
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'game' is defined but never used.",
        "line": 228,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 228,
        "endColumn": 9
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 234,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 234,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [9177, 9253], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\n/**\n * Action Registry - Maps action types to their implementation functions\n * This provides a pluggable system for extending game actions without modifying core engine code\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globalActionRegistry = exports.EffectProcessor = exports.ActionValidator = exports.STANDARD_ACTIONS = exports.ActionRegistry = void 0;\nconst game_definitions_1 = require(\"./game-definitions\");\n// ============================================================================\n// ACTION REGISTRY\n// ============================================================================\n/**\n * Registry that maps action types to their handler functions\n */\nclass ActionRegistry {\n    constructor() {\n        this.characterActionHandlers = new Map();\n        this.metaActionHandlers = new Map();\n    }\n    /**\n     * Register a character action handler\n     */\n    registerCharacterAction(actionType, handler) {\n        this.characterActionHandlers.set(actionType, handler);\n    }\n    /**\n     * Register a meta action handler\n     */\n    registerMetaAction(actionType, handler) {\n        this.metaActionHandlers.set(actionType, handler);\n    }\n    /**\n     * Get character action handler\n     */\n    getCharacterActionHandler(actionType) {\n        return this.characterActionHandlers.get(actionType);\n    }\n    /**\n     * Get meta action handler\n     */\n    getMetaActionHandler(actionType) {\n        return this.metaActionHandlers.get(actionType);\n    }\n    /**\n     * Check if character action is supported\n     */\n    hasCharacterAction(actionType) {\n        return this.characterActionHandlers.has(actionType);\n    }\n    /**\n     * Check if meta action is supported\n     */\n    hasMetaAction(actionType) {\n        return this.metaActionHandlers.has(actionType);\n    }\n    /**\n     * Get all registered character action types\n     */\n    getRegisteredCharacterActions() {\n        return Array.from(this.characterActionHandlers.keys());\n    }\n    /**\n     * Get all registered meta action types\n     */\n    getRegisteredMetaActions() {\n        return Array.from(this.metaActionHandlers.keys());\n    }\n}\nexports.ActionRegistry = ActionRegistry;\n// ============================================================================\n// STANDARD ACTION CONFIGURATIONS\n// ============================================================================\n/**\n * Standard action configurations that can be reused across characters\n */\nexports.STANDARD_ACTIONS = {\n    // Information gathering actions\n    LEARN_EVIL_PAIRS: {\n        type: game_definitions_1.CharacterActionType.LEARN_EVIL_PAIRS_COUNT,\n        effects: [],\n        information: {\n            customMessage: \"You see [COUNT] pairs of neighbouring evil players\"\n        }\n    },\n    LEARN_EVIL_NEIGHBORS: {\n        type: game_definitions_1.CharacterActionType.LEARN_EVIL_NEIGHBOR_COUNT,\n        effects: [],\n        information: {\n            customMessage: \"You see [COUNT] evil neighbors\"\n        }\n    },\n    // Player targeting actions\n    CHOOSE_MASTER: {\n        type: game_definitions_1.CharacterActionType.CHOOSE_MASTER,\n        effects: [\n            (0, game_definitions_1.createEffect)(game_definitions_1.StatusEffect.MASTER, game_definitions_1.EffectTarget.SELECTED, game_definitions_1.EffectDuration.ONE_DAY)\n        ],\n        information: {\n            customMessage: \"You chose [PLAYER] as your Master\"\n        }\n    },\n    // Killing actions\n    KILL_PLAYER: {\n        type: game_definitions_1.CharacterActionType.KILL_PLAYER,\n        effects: [\n            (0, game_definitions_1.createEffect)(game_definitions_1.StatusEffect.DEAD, game_definitions_1.EffectTarget.SELECTED, game_definitions_1.EffectDuration.INSTANT)\n        ]\n    },\n    // Protection actions\n    PROTECT_PLAYER: {\n        type: game_definitions_1.CharacterActionType.PROTECT_PLAYER,\n        effects: [\n            (0, game_definitions_1.createEffect)(game_definitions_1.StatusEffect.PROTECTED, game_definitions_1.EffectTarget.SELECTED, game_definitions_1.EffectDuration.TONIGHT)\n        ]\n    },\n    // Status effect actions\n    POISON_PLAYER: {\n        type: game_definitions_1.CharacterActionType.POISON_PLAYER,\n        effects: [\n            (0, game_definitions_1.createEffect)(game_definitions_1.StatusEffect.POISONED, game_definitions_1.EffectTarget.SELECTED, game_definitions_1.EffectDuration.TONIGHT)\n        ]\n    },\n    // Voting restrictions\n    VOTING_RESTRICTION: {\n        type: game_definitions_1.CharacterActionType.ENFORCE_VOTING_RESTRICTION,\n        effects: [\n            (0, game_definitions_1.createEffect)(game_definitions_1.StatusEffect.CAN_VOTE_ONLY_WITH_MASTER, game_definitions_1.EffectTarget.SELF, game_definitions_1.EffectDuration.ONE_DAY)\n        ]\n    },\n};\n// ============================================================================\n// ACTION VALIDATION HELPERS\n// ============================================================================\n/**\n * Validate action requirements before execution\n */\nclass ActionValidator {\n    /**\n     * Check if an action can be performed based on game state\n     */\n    static canPerformAction(action, context, game, actingSeat) {\n        // Check if player is alive (unless action allows dead players)\n        if (!actingSeat.isAlive && !this.actionAllowsDead(action)) {\n            return { valid: false, reason: 'Dead players cannot perform this action' };\n        }\n        // Check if player has already used a once-per-game ability\n        if (this.isOncePerGame(action) && this.hasUsedAbility(actingSeat, action.id)) {\n            return { valid: false, reason: 'This ability can only be used once per game' };\n        }\n        // Check if action is valid for current phase\n        if (!this.isValidPhase(action, context)) {\n            return { valid: false, reason: 'Action not valid in current phase' };\n        }\n        return { valid: true };\n    }\n    static actionAllowsDead(action) {\n        // Check if action has any effects that indicate it can be used by dead players\n        return action.effects?.some(effect => ('status' in effect && effect.status === game_definitions_1.StatusEffect.DEAD_VOTE_USED) ||\n            ('statusEffect' in effect && effect.statusEffect === 'DEAD_VOTE_USED') ||\n            ('target' in effect && effect.target === game_definitions_1.EffectTarget.STORYTELLER) ||\n            ('target' in effect && effect.target === 'STORYTELLER')) ?? false;\n    }\n    static isOncePerGame(action) {\n        // This would check character tags or action metadata\n        return action.description?.includes('once per game') ?? false;\n    }\n    static hasUsedAbility(seat, actionId) {\n        // This would check seat's action history\n        // Implementation depends on how we track used abilities\n        return false; // Placeholder\n    }\n    static isValidPhase(action, context) {\n        // This would validate the action phase against the current game phase\n        // Implementation depends on how we map phases\n        return true; // Placeholder\n    }\n}\nexports.ActionValidator = ActionValidator;\n// ============================================================================\n// EFFECT PROCESSOR\n// ============================================================================\n/**\n * Processes and applies effects from actions\n */\nclass EffectProcessor {\n    /**\n     * Apply all effects from an action\n     */\n    static applyEffects(action, targets, actingSeat, game) {\n        if (!('effects' in action) || !action.effects) {\n            return;\n        }\n        for (const effect of action.effects) {\n            this.applyEffect(effect, targets, actingSeat, game);\n        }\n    }\n    /**\n     * Apply a single effect\n     */\n    static applyEffect(effect, // EffectSpec from types\n    targets, actingSeat, game) {\n        const targetSeats = this.resolveEffectTargets(effect.target, targets, actingSeat);\n        for (const seat of targetSeats) {\n            this.applyEffectToSeat(seat, effect, game);\n        }\n    }\n    /**\n     * Resolve which seats should receive the effect\n     */\n    static resolveEffectTargets(targetType, selectedTargets, actingSeat) {\n        switch (targetType) {\n            case game_definitions_1.EffectTarget.SELF:\n                return actingSeat ? [actingSeat] : [];\n            case game_definitions_1.EffectTarget.SELECTED:\n                return selectedTargets;\n            case game_definitions_1.EffectTarget.ONE_OF_SELECTED:\n                return selectedTargets.length > 0 ? [selectedTargets[0]] : [];\n            case game_definitions_1.EffectTarget.ALL_SELECTED:\n                return selectedTargets;\n            default:\n                return [];\n        }\n    }\n    /**\n     * Apply effect to a specific seat\n     */\n    static applyEffectToSeat(seat, effect, // EffectSpec\n    game) {\n        // This would apply the status effect to the seat\n        // Implementation depends on how we store seat status\n        // For now, just log the effect\n        const status = ('status' in effect) ? effect.status : effect.statusEffect;\n        const duration = ('duration' in effect) ? effect.duration : effect.duration;\n        console.log(`Applying effect ${status} to seat ${seat.id} for ${duration}`);\n    }\n}\nexports.EffectProcessor = EffectProcessor;\n// ============================================================================\n// GLOBAL REGISTRY INSTANCE\n// ============================================================================\n/**\n * Global action registry instance\n */\nexports.globalActionRegistry = new ActionRegistry();\n//# sourceMappingURL=action-registry.js.map",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-registry.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 27,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Action Registry - Maps action types to their implementation functions\n * This provides a pluggable system for extending game actions without modifying core engine code\n */\n\nimport {\n  CharacterActionType,\n  MetaActionType,\n  StatusEffect,\n  EffectDuration,\n  EffectTarget,\n  createEffect,\n} from './game-definitions';\nimport {\n  GameState,\n  Seat,\n  CharacterAction,\n  MetaAction,\n  ActionContext,\n  ActionResult,\n} from './types';\n\n// ============================================================================\n// ACTION HANDLER TYPES\n// ============================================================================\n\nexport type CharacterActionHandler = (\n  action: CharacterAction,\n  context: ActionContext,\n  game: GameState,\n  actingSeat: Seat\n) => Promise<ActionResult> | ActionResult;\n\nexport type MetaActionHandler = (\n  action: MetaAction,\n  context: ActionContext,\n  game: GameState\n) => Promise<ActionResult> | ActionResult;\n\n// ============================================================================\n// ACTION REGISTRY\n// ============================================================================\n\n/**\n * Registry that maps action types to their handler functions\n */\nexport class ActionRegistry {\n  private characterActionHandlers = new Map<CharacterActionType, CharacterActionHandler>();\n  private metaActionHandlers = new Map<MetaActionType, MetaActionHandler>();\n\n  /**\n   * Register a character action handler\n   */\n  registerCharacterAction(actionType: CharacterActionType, handler: CharacterActionHandler): void {\n    this.characterActionHandlers.set(actionType, handler);\n  }\n\n  /**\n   * Register a meta action handler\n   */\n  registerMetaAction(actionType: MetaActionType, handler: MetaActionHandler): void {\n    this.metaActionHandlers.set(actionType, handler);\n  }\n\n  /**\n   * Get character action handler\n   */\n  getCharacterActionHandler(actionType: CharacterActionType): CharacterActionHandler | undefined {\n    return this.characterActionHandlers.get(actionType);\n  }\n\n  /**\n   * Get meta action handler\n   */\n  getMetaActionHandler(actionType: MetaActionType): MetaActionHandler | undefined {\n    return this.metaActionHandlers.get(actionType);\n  }\n\n  /**\n   * Check if character action is supported\n   */\n  hasCharacterAction(actionType: CharacterActionType): boolean {\n    return this.characterActionHandlers.has(actionType);\n  }\n\n  /**\n   * Check if meta action is supported\n   */\n  hasMetaAction(actionType: MetaActionType): boolean {\n    return this.metaActionHandlers.has(actionType);\n  }\n\n  /**\n   * Get all registered character action types\n   */\n  getRegisteredCharacterActions(): CharacterActionType[] {\n    return Array.from(this.characterActionHandlers.keys());\n  }\n\n  /**\n   * Get all registered meta action types\n   */\n  getRegisteredMetaActions(): MetaActionType[] {\n    return Array.from(this.metaActionHandlers.keys());\n  }\n}\n\n// ============================================================================\n// STANDARD ACTION CONFIGURATIONS\n// ============================================================================\n\n/**\n * Standard action configurations that can be reused across characters\n */\nexport const STANDARD_ACTIONS = {\n  // Information gathering actions\n  LEARN_EVIL_PAIRS: {\n    type: CharacterActionType.LEARN_EVIL_PAIRS_COUNT,\n    effects: [],\n    information: {\n      customMessage: \"You see [COUNT] pairs of neighbouring evil players\"\n    }\n  },\n  \n  LEARN_EVIL_NEIGHBORS: {\n    type: CharacterActionType.LEARN_EVIL_NEIGHBOR_COUNT,\n    effects: [],\n    information: {\n      customMessage: \"You see [COUNT] evil neighbors\"\n    }\n  },\n\n  // Player targeting actions\n  CHOOSE_MASTER: {\n    type: CharacterActionType.CHOOSE_MASTER,\n    effects: [\n      createEffect(StatusEffect.MASTER, EffectTarget.SELECTED, EffectDuration.ONE_DAY)\n    ],\n    information: {\n      customMessage: \"You chose [PLAYER] as your Master\"\n    }\n  },\n\n  // Killing actions\n  KILL_PLAYER: {\n    type: CharacterActionType.KILL_PLAYER,\n    effects: [\n      createEffect(StatusEffect.DEAD, EffectTarget.SELECTED, EffectDuration.INSTANT)\n    ]\n  },\n\n  // Protection actions\n  PROTECT_PLAYER: {\n    type: CharacterActionType.PROTECT_PLAYER,\n    effects: [\n      createEffect(StatusEffect.PROTECTED, EffectTarget.SELECTED, EffectDuration.TONIGHT)\n    ]\n  },\n\n  // Status effect actions\n  POISON_PLAYER: {\n    type: CharacterActionType.POISON_PLAYER,\n    effects: [\n      createEffect(StatusEffect.POISONED, EffectTarget.SELECTED, EffectDuration.TONIGHT)\n    ]\n  },\n\n  // Voting restrictions\n  VOTING_RESTRICTION: {\n    type: CharacterActionType.ENFORCE_VOTING_RESTRICTION,\n    effects: [\n      createEffect(StatusEffect.CAN_VOTE_ONLY_WITH_MASTER, EffectTarget.SELF, EffectDuration.ONE_DAY)\n    ]\n  },\n} as const;\n\n// ============================================================================\n// ACTION VALIDATION HELPERS\n// ============================================================================\n\n/**\n * Validate action requirements before execution\n */\nexport class ActionValidator {\n  /**\n   * Check if an action can be performed based on game state\n   */\n  static canPerformAction(\n    action: CharacterAction,\n    context: ActionContext,\n    game: GameState,\n    actingSeat: Seat\n  ): { valid: boolean; reason?: string } {\n    // Check if player is alive (unless action allows dead players)\n    if (!actingSeat.isAlive && !this.actionAllowsDead(action)) {\n      return { valid: false, reason: 'Dead players cannot perform this action' };\n    }\n\n    // Check if player has already used a once-per-game ability\n    if (this.isOncePerGame(action) && this.hasUsedAbility(actingSeat, action.id)) {\n      return { valid: false, reason: 'This ability can only be used once per game' };\n    }\n\n    // Check if action is valid for current phase\n    if (!this.isValidPhase(action, context)) {\n      return { valid: false, reason: 'Action not valid in current phase' };\n    }\n\n    return { valid: true };\n  }\n\n  private static actionAllowsDead(action: CharacterAction): boolean {\n    // Check if action has any effects that indicate it can be used by dead players\n    return action.effects?.some(effect => \n      ('status' in effect && effect.status === StatusEffect.DEAD_VOTE_USED) ||\n      ('statusEffect' in effect && effect.statusEffect === 'DEAD_VOTE_USED') ||\n      ('target' in effect && effect.target === EffectTarget.STORYTELLER) ||\n      ('target' in effect && effect.target === 'STORYTELLER')\n    ) ?? false;\n  }\n\n  private static isOncePerGame(action: CharacterAction): boolean {\n    // This would check character tags or action metadata\n    return action.description?.includes('once per game') ?? false;\n  }\n\n  private static hasUsedAbility(seat: Seat, actionId: string): boolean {\n    // This would check seat's action history\n    // Implementation depends on how we track used abilities\n    return false; // Placeholder\n  }\n\n  private static isValidPhase(action: CharacterAction, context: ActionContext): boolean {\n    // This would validate the action phase against the current game phase\n    // Implementation depends on how we map phases\n    return true; // Placeholder\n  }\n}\n\n// ============================================================================\n// EFFECT PROCESSOR\n// ============================================================================\n\n/**\n * Processes and applies effects from actions\n */\nexport class EffectProcessor {\n  /**\n   * Apply all effects from an action\n   */\n  static applyEffects(\n    action: CharacterAction | MetaAction,\n    targets: Seat[],\n    actingSeat: Seat | null,\n    game: GameState\n  ): void {\n    if (!('effects' in action) || !action.effects) {\n      return;\n    }\n\n    for (const effect of action.effects) {\n      this.applyEffect(effect, targets, actingSeat, game);\n    }\n  }\n\n  /**\n   * Apply a single effect\n   */\n  private static applyEffect(\n    effect: any, // EffectSpec from types\n    targets: Seat[],\n    actingSeat: Seat | null,\n    game: GameState\n  ): void {\n    const targetSeats = this.resolveEffectTargets(effect.target, targets, actingSeat);\n    \n    for (const seat of targetSeats) {\n      this.applyEffectToSeat(seat, effect, game);\n    }\n  }\n\n  /**\n   * Resolve which seats should receive the effect\n   */\n  private static resolveEffectTargets(\n    targetType: EffectTarget,\n    selectedTargets: Seat[],\n    actingSeat: Seat | null\n  ): Seat[] {\n    switch (targetType) {\n      case EffectTarget.SELF:\n        return actingSeat ? [actingSeat] : [];\n      case EffectTarget.SELECTED:\n        return selectedTargets;\n      case EffectTarget.ONE_OF_SELECTED:\n        return selectedTargets.length > 0 ? [selectedTargets[0]] : [];\n      case EffectTarget.ALL_SELECTED:\n        return selectedTargets;\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Apply effect to a specific seat\n   */\n  private static applyEffectToSeat(\n    seat: Seat,\n    effect: any, // EffectSpec\n    game: GameState\n  ): void {\n    // This would apply the status effect to the seat\n    // Implementation depends on how we store seat status\n    // For now, just log the effect\n    const status = ('status' in effect) ? effect.status : effect.statusEffect;\n    const duration = ('duration' in effect) ? effect.duration : effect.duration;\n    console.log(`Applying effect ${status} to seat ${seat.id} for ${duration}`);\n  }\n}\n\n// ============================================================================\n// GLOBAL REGISTRY INSTANCE\n// ============================================================================\n\n/**\n * Global action registry instance\n */\nexport const globalActionRegistry = new ActionRegistry();\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/action-types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 35,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport * as Enums from './enums';\nimport { SeatIdSchema, GameIdSchema } from './core-types';\nimport { MetaActionType, CharacterActionType } from './game-definitions';\nimport {\n  TargetSelectionSchema,\n  EffectSpecSchema,\n  InformationSpecSchema,\n} from './script-dsl';\n\nexport const CharacterActionSchema = z.object({\n  id: z.string(),\n  // Support both old and new formats during migration\n  type: z.enum(['character','meta']).default('character').optional(),\n  // Old format (to be deprecated)\n  action: z.union([z.nativeEnum(CharacterActionType), z.nativeEnum(MetaActionType), z.string()]).optional(),\n  description: z.string(),\n  targets: z.array(z.string()).optional(),\n  // New parameterized format\n  actionType: z.union([z.nativeEnum(CharacterActionType), z.nativeEnum(MetaActionType), z.string()]).optional(),\n  selection: TargetSelectionSchema.optional(),\n  effects: z.array(EffectSpecSchema).optional(),\n  information: InformationSpecSchema.optional(),\n  order: z.number().optional(),\n  condition: z.string().optional()\n}).refine((data) => {\n  // Ensure either old format OR new format is used\n  const hasOldFormat = data.action !== undefined && data.targets !== undefined;\n  const hasNewFormat = data.actionType !== undefined && data.selection !== undefined && data.effects !== undefined;\n\n  return hasOldFormat || hasNewFormat;\n}, {\n  message: \"Action must use either old format (action + targets) or new format (actionType + selection + effects)\"\n});\nexport type CharacterAction = z.infer<typeof CharacterActionSchema>;\n\n// Meta action schema for script-level actions (minion info, demon info, etc.)\nexport const MetaActionSchema = z.object({\n  id: z.string(),\n  type: z.literal('meta').optional(),\n  // Old format (to be deprecated)\n  action: z.union([z.nativeEnum(MetaActionType), z.string()]).optional(),\n  description: z.string(),\n  targets: z.array(z.enum(['townsfolk', 'outsiders', 'minions', 'demons', 'all'])).optional(),\n  // New parameterized format\n  actionType: z.nativeEnum(MetaActionType).optional(),\n  selection: TargetSelectionSchema.optional(),\n  effects: z.array(EffectSpecSchema).optional(),\n  information: InformationSpecSchema.optional(),\n  order: z.number()\n}).refine((data) => {\n  // Ensure either old format OR new format is used\n  const hasOldFormat = data.action !== undefined && data.targets !== undefined;\n  const hasNewFormat = data.actionType !== undefined && data.selection !== undefined && data.effects !== undefined;\n\n  return hasOldFormat || hasNewFormat;\n}, {\n  message: \"Meta action must use either old format (action + targets) or new format (actionType + selection + effects)\"\n});\nexport type MetaAction = z.infer<typeof MetaActionSchema>;\n\n// Union type for night order entries (can be character ID or meta action)\nexport const NightOrderEntrySchema = z.union([\n  z.string(), // Character ID\n  MetaActionSchema\n]);\nexport type NightOrderEntry = z.infer<typeof NightOrderEntrySchema>;\n\n// Action execution context for the engine\nexport const ActionContextSchema = z.object({\n  gameId: GameIdSchema,\n  phase: z.nativeEnum(Enums.GamePhase),\n  day: z.number(),\n  acting: SeatIdSchema.optional(), // The seat performing the action\n  targets: z.array(SeatIdSchema).optional(), // Target seats\n  metadata: z.record(z.any()).optional() // Additional context\n});\nexport type ActionContext = z.infer<typeof ActionContextSchema>;\n\n// Action result for tracking what happened\nexport const ActionResultSchema = z.object({\n  actionId: z.string(),\n  success: z.boolean(),\n  information: z.record(z.any()).optional(), // Information delivered\n  events: z.array(z.string()).optional(), // Event IDs generated\n  errors: z.array(z.string()).optional()\n});\nexport type ActionResult = z.infer<typeof ActionResultSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/actions.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 20,
        "column": 36,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Game Action System - Comprehensive index for all action-related functionality\n * This provides a single entry point for the new action system\n */\n\n// Core definitions\nexport * from './game-definitions';\n\n// Action registry and validation\nexport * from './action-registry';\n\n// Standard action handlers  \nexport * from './action-handlers';\n\n// Legacy bridge functionality (for transitional compatibility)\nexport class ActionSystemBridge {\n  /**\n   * Convert legacy string action to enum if possible\n   */\n  static normalizeActionType(action: string): string {\n    // Map common legacy actions to new enum values\n    const actionMap: Record<string, string> = {\n      'learnEvilPairsCount': 'learnEvilPairsCount',\n      'learnEvilNeighborCount': 'learnEvilNeighborCount',\n      'chooseMaster': 'chooseMaster',\n      'killPlayer': 'killPlayer',\n      'protectPlayer': 'protectPlayer',\n      'poisonPlayer': 'poisonPlayer',\n      'enforceVotingRestriction': 'enforceVotingRestriction',\n      'showTeamToMinions': 'showTeamToMinions',\n      'showTeamAndBluffsToDemon': 'showTeamAndBluffsToDemon',\n    };\n\n    return actionMap[action] || action;\n  }\n\n  /**\n   * Check if action type exists in our system\n   */\n  static isKnownAction(action: string): boolean {\n    return this.normalizeActionType(action) !== action;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token as",
        "line": 9,
        "column": 3,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Game Constants\nexport const GAME_CONSTANTS = {\n  MIN_PLAYERS: 5,\n  MAX_PLAYERS: 20,\n  VOTE_TIMEOUT_MS: 30000,\n  NOMINATION_TIMEOUT_MS: 60000,\n  NIGHT_PHASE_TIMEOUT_MS: 120000,\n  MAX_WHISPER_DISTANCE: 2\n} as const;\n\n// Scoring Weights\nexport const SCORING_WEIGHTS = {\n  INFORMATION_GAIN: 0.35,\n  CONTROL_BALANCE: 0.25,\n  TIME_CUSHION: 0.20,\n  REDUNDANCY_ROBUSTNESS: 0.15,\n  VOLATILITY: 0.05\n} as const;\n\n// Role Values for Information Scoring\nexport const ROLE_INFO_VALUES = {\n  'undertaker': 3,\n  'empath': 2,\n  'fortune-teller': 1.5,\n  'investigator': 2,\n  'librarian': 1.5,\n  'chef': 1,\n  'washerwoman': 2,\n  'steward': 1\n} as const;\n\n// Default Script IDs\nexport const SCRIPTS = {\n  TROUBLE_BREWING: 'trouble-brewing',\n  SECTS_AND_VIOLETS: 'sects-and-violets',\n  BAD_MOON_RISING: 'bad-moon-rising'\n} as const;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants/action-types.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function has too many statements (39). Maximum allowed is 20.",
        "line": 16,
        "column": 2,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 70,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\n/**\n * Action Type Definitions\n * Character and meta action types for game mechanics\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CharacterActionType = exports.MetaActionType = void 0;\nexports.isCharacterAction = isCharacterAction;\nexports.isMetaAction = isMetaAction;\nexports.getAllActionTypes = getAllActionTypes;\n\n/**\n * Character action types - what characters can do\n */\nlet CharacterActionType;\n(function (CharacterActionType) {\n  // Information gathering\n  CharacterActionType[\"LEARN_EVIL_PAIRS_COUNT\"] = \"learnEvilPairsCount\";\n  CharacterActionType[\"LEARN_EVIL_NEIGHBOR_COUNT\"] = \"learnEvilNeighborCount\";\n  CharacterActionType[\"LEARN_PLAYER_INFO\"] = \"learnPlayerInfo\";\n  CharacterActionType[\"LEARN_CHARACTER_TYPE\"] = \"learnCharacterType\";\n  CharacterActionType[\"LEARN_ROLE_IDENTITY\"] = \"learnRoleIdentity\";\n  CharacterActionType[\"DETECT_OUTSIDER\"] = \"detectOutsider\";\n  CharacterActionType[\"DETECT_MINION\"] = \"detectMinion\";\n  CharacterActionType[\"DETECT_DEMON\"] = \"detectDemon\";\n  // Player targeting/selection\n  CharacterActionType[\"CHOOSE_PLAYER\"] = \"choosePlayer\";\n  CharacterActionType[\"CHOOSE_PLAYERS\"] = \"choosePlayers\";\n  CharacterActionType[\"CHOOSE_3_PLAYERS\"] = \"choose3Players\";\n  CharacterActionType[\"CHOOSE_MASTER\"] = \"chooseMaster\";\n  CharacterActionType[\"CHOOSE_CHARACTER_TYPE\"] = \"chooseCharacterType\";\n  CharacterActionType[\"CHOOSE_MINION_OR_DEMON\"] = \"chooseMinion-OrDemon\";\n  // Killing and protection\n  CharacterActionType[\"KILL_PLAYER\"] = \"killPlayer\";\n  CharacterActionType[\"CHOOSE_PLAYER_KILL\"] = \"choosePlayerKill\";\n  CharacterActionType[\"KILL_CHOSEN_PLAYER_ONCE\"] = \"killChosenPlayerOnce\";\n  CharacterActionType[\"PROTECT_PLAYER\"] = \"protectPlayer\";\n  CharacterActionType[\"PROTECT_GOOD_NEIGHBORS_PASSIVE\"] =\n    \"protectGoodNeighborsPassive\";\n  CharacterActionType[\"FIRST_DEATH_SURVIVE\"] = \"firstDeathSurvive\";\n  // Status effects\n  CharacterActionType[\"POISON_PLAYER\"] = \"poisonPlayer\";\n  CharacterActionType[\"MADNESS_PLAYER\"] = \"madnessPlayer\";\n  CharacterActionType[\"DRUNK_PLAYER\"] = \"drunkPlayer\";\n  CharacterActionType[\"CHOOSE_CHARACTER_TO_BE_DRUNK\"] =\n    \"chooseCharacterToBeDeunk\";\n  // Voting and nominations\n  CharacterActionType[\"NOMINATE\"] = \"nominate\";\n  CharacterActionType[\"NOMINATE_AGAIN\"] = \"nominateAgain\";\n  CharacterActionType[\"VOTE_MANIPULATION\"] = \"voteManipulation\";\n  CharacterActionType[\"ENFORCE_VOTING_RESTRICTION\"] =\n    \"enforceVotingRestriction\";\n  CharacterActionType[\"RESTRICT_OWN_VOTE\"] = \"restrictOwnVote\";\n  CharacterActionType[\"DEAD_REGAIN_VOTE\"] = \"deadRegainVote\";\n  // Information sharing\n  CharacterActionType[\"SHARE_LEARNED_INFO\"] = \"shareLearnedInfo\";\n  CharacterActionType[\"GIVE_INCORRECT_INFO\"] = \"giveIncorrectInfo\";\n  CharacterActionType[\"SAY_PHRASE\"] = \"sayPhrase\";\n  // Special abilities\n  CharacterActionType[\"GAIN_ABILITY\"] = \"gainAbility\";\n  CharacterActionType[\"BLOCK_DEMON\"] = \"blockDemon\";\n  CharacterActionType[\"DEMON_MAY_CHOOSE_NOT_TO_ATTACK\"] =\n    \"demonMayChooseNotToAttack\";\n  CharacterActionType[\"STORYTELLER_GAINS_MINION_ABILITY\"] =\n    \"storytellerGainsMinion-Ability\";\n  CharacterActionType[\"KILLED_MINION_KEEPS_ABILITY_POISON_NEIGHBOR\"] =\n    \"killedMinionKeepsAbilityPoisonNeighbor\";\n  // Legion specific\n  CharacterActionType[\"CHOOSE_PLAYER_TO_DIE\"] = \"choosePlayerToDie\";\n})(\n  CharacterActionType ||\n    (exports.CharacterActionType = CharacterActionType = {})\n);\n\n/**\n * Meta action types - script-level actions\n */\nlet MetaActionType;\n(function (MetaActionType) {\n  MetaActionType[\"SHOW_TEAM_TO_MINIONS\"] = \"showTeamToMinions\";\n  MetaActionType[\"SHOW_TEAM_AND_BLUFFS_TO_DEMON\"] = \"showTeamAndBluffsToDemon\";\n  MetaActionType[\"SETUP_MADNESS\"] = \"setupMadness\";\n  MetaActionType[\"DISTRIBUTE_ROLES\"] = \"distributeRoles\";\n  MetaActionType[\"APPLY_FIRST_NIGHT_INFO\"] = \"applyFirstNightInfo\";\n  MetaActionType[\"ASSIGN_RED_HERRING\"] = \"assignRedHerring\";\n  MetaActionType[\"RECEIVE_BLUFF_CHARACTERS\"] = \"receiveBluffCharacters\";\n  MetaActionType[\"COORDINATE_EVIL_TEAM\"] = \"coordinateEvilTeam\";\n  MetaActionType[\"MAINTAIN_BLUFF\"] = \"maintainBluff\";\n  MetaActionType[\"DEFLECT_ATTENTION\"] = \"deflectAttention\";\n  MetaActionType[\"VOTE_TO_SURVIVE\"] = \"voteToSurvive\";\n  MetaActionType[\"AVOID_EXECUTION\"] = \"avoidExecution\";\n  MetaActionType[\"SACRIFICE_MINIONS\"] = \"sacrificeMinions\";\n})(MetaActionType || (exports.MetaActionType = MetaActionType = {}));\n\n/**\n * Check if an action type is a character action\n */\nfunction isCharacterAction(actionType) {\n  return Object.values(CharacterActionType).includes(actionType);\n}\n\n/**\n * Check if an action type is a meta action\n */\nfunction isMetaAction(actionType) {\n  return Object.values(MetaActionType).includes(actionType);\n}\n\n/**\n * Get all action types (both character and meta)\n */\nfunction getAllActionTypes() {\n  return [\n    ...Object.values(CharacterActionType),\n    ...Object.values(MetaActionType),\n  ];\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants/game-constants.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants/selection-criteria.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants/status-effects.js",
    "messages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Function has too many statements (25). Maximum allowed is 20.",
        "line": 17,
        "column": 2,
        "nodeType": "FunctionExpression",
        "messageId": "exceed",
        "endLine": 49,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\n/**\n * Status Effects and Effect System\n * Definitions for status effects, durations, and targets\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StatusEffect = exports.EffectDuration = exports.EffectTarget = void 0;\nexports.isValidStatusEffect = isValidStatusEffect;\nexports.isValidEffectDuration = isValidEffectDuration;\nexports.isValidEffectTarget = isValidEffectTarget;\nexports.createEffect = createEffect;\n\n/**\n * Status effects that can be applied to players\n */\nlet StatusEffect;\n(function (StatusEffect) {\n  // Basic status conditions\n  StatusEffect[\"POISONED\"] = \"poisoned\";\n  StatusEffect[\"DRUNK\"] = \"drunk\";\n  StatusEffect[\"MAD\"] = \"mad\";\n  StatusEffect[\"PROTECTED\"] = \"protected\";\n  StatusEffect[\"DEAD\"] = \"dead\";\n  // Voting restrictions and modifications\n  StatusEffect[\"MASTER\"] = \"master\";\n  StatusEffect[\"CAN_VOTE_ONLY_WITH_MASTER\"] = \"canVoteOnlyWithMaster\";\n  StatusEffect[\"VOTE_COUNTS_NEGATIVELY\"] = \"voteCountsNegatively\";\n  StatusEffect[\"CANNOT_VOTE\"] = \"cannotVote\";\n  StatusEffect[\"DEAD_VOTE_USED\"] = \"deadVoteUsed\";\n  // Character-specific statuses\n  StatusEffect[\"SLAYER_USED\"] = \"slayerUsed\";\n  StatusEffect[\"VIRGIN_TRIGGERED\"] = \"virginTriggered\";\n  StatusEffect[\"BUTLER_MASTER_SET\"] = \"butlerMasterSet\";\n  StatusEffect[\"INNKEEPER_PROTECTION\"] = \"innkeeperProtection\";\n  StatusEffect[\"SOLDIER_PROTECTION\"] = \"soldierProtection\";\n  StatusEffect[\"TEA_LADY_PROTECTION\"] = \"teaLadyProtection\";\n  // Information tracking\n  StatusEffect[\"LEARNED_INFO\"] = \"learnedInfo\";\n  StatusEffect[\"BLUFF_GIVEN\"] = \"bluffGiven\";\n  StatusEffect[\"FALSE_INFO_GIVEN\"] = \"falseInfoGiven\";\n  // Game state modifiers\n  StatusEffect[\"NOMINATED_TODAY\"] = \"nominatedToday\";\n  StatusEffect[\"EXECUTED_TODAY\"] = \"executedToday\";\n  StatusEffect[\"ACTED_TONIGHT\"] = \"actedTonight\";\n  // Special conditions\n  StatusEffect[\"STARPASS_CANDIDATE\"] = \"starpassCandidate\";\n  StatusEffect[\"DEMON_INFO_RECEIVED\"] = \"demonInfoReceived\";\n  StatusEffect[\"MINION_INFO_RECEIVED\"] = \"minionInfoReceived\";\n})(StatusEffect || (exports.StatusEffect = StatusEffect = {}));\n\n/**\n * Duration types for effects\n */\nlet EffectDuration;\n(function (EffectDuration) {\n  EffectDuration[\"INSTANT\"] = \"instant\";\n  EffectDuration[\"TONIGHT\"] = \"tonight\";\n  EffectDuration[\"UNTIL_DUSK\"] = \"untilDusk\";\n  EffectDuration[\"ONE_DAY\"] = \"oneDay\";\n  EffectDuration[\"ONE_NIGHT\"] = \"oneNight\";\n  EffectDuration[\"PERMANENT\"] = \"permanent\";\n  EffectDuration[\"UNTIL_DEATH\"] = \"untilDeath\";\n  EffectDuration[\"UNTIL_ABILITY_USED\"] = \"untilAbilityUsed\";\n})(EffectDuration || (exports.EffectDuration = EffectDuration = {}));\n\n/**\n * Effect target types\n */\nlet EffectTarget;\n(function (EffectTarget) {\n  EffectTarget[\"SELF\"] = \"self\";\n  EffectTarget[\"SELECTED\"] = \"selected\";\n  EffectTarget[\"ONE_OF_SELECTED\"] = \"oneOfSelected\";\n  EffectTarget[\"ALL_SELECTED\"] = \"allSelected\";\n  EffectTarget[\"ALL_PLAYERS\"] = \"allPlayers\";\n  EffectTarget[\"NEIGHBORS\"] = \"neighbors\";\n  EffectTarget[\"STORYTELLER\"] = \"storyteller\";\n})(EffectTarget || (exports.EffectTarget = EffectTarget = {}));\n\n/**\n * Validate that a status effect exists\n */\nfunction isValidStatusEffect(status) {\n  return Object.values(StatusEffect).includes(status);\n}\n\n/**\n * Validate that an effect duration exists\n */\nfunction isValidEffectDuration(duration) {\n  return Object.values(EffectDuration).includes(duration);\n}\n\n/**\n * Validate that an effect target exists\n */\nfunction isValidEffectTarget(target) {\n  return Object.values(EffectTarget).includes(target);\n}\n\n/**\n * Create a standardized effect object\n */\nfunction createEffect(status, target, duration, value) {\n  return {\n    status,\n    target,\n    duration,\n    ...(value !== undefined && { value }),\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/constants/validation-rules.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/core-types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/core-types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 5,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\n// Core Types\nexport const SeatIdSchema = z.string().uuid();\nexport type SeatId = z.infer<typeof SeatIdSchema>;\n\nexport const PlayerIdSchema = z.string().uuid();\nexport type PlayerId = z.infer<typeof PlayerIdSchema>;\n\nexport const GameIdSchema = z.string().uuid();\nexport type GameId = z.infer<typeof GameIdSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/enums.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/enums.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token enum",
        "line": 4,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\n// Game State Enums\nexport enum GamePhase {\n  LOBBY = 'lobby',\n  SETUP = 'setup',\n  NIGHT = 'night',\n  DAY = 'day',\n  NOMINATION = 'nomination',\n  VOTE = 'vote',\n  EXECUTION = 'execution',\n  END = 'end'\n}\n\nexport const Alignment = {\n  GOOD: 'good',\n  EVIL: 'evil'\n} as const;\n\nexport const RoleType = {\n  TOWNSFOLK: 'townsfolk',\n  OUTSIDER: 'outsider',\n  MINION: 'minion',\n  DEMON: 'demon',\n  TRAVELLER: 'traveller',\n  FABLED: 'fabled'\n} as const;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/events.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/events.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 40,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { GameIdSchema, SeatIdSchema } from './core-types';\n\n// Events\nexport const EventSchema = z.object({\n  id: z.string().uuid(),\n  gameId: GameIdSchema,\n  type: z.enum([\n    'game_created',\n    'player_joined',\n    'player_left',\n    'phase_changed',\n    'ability_used',\n    'vote_cast',\n    'nomination_made',\n    'execution_occurred',\n    'chat_message',\n    'script_proposed',\n    'script_vote',\n    'script_selected',\n  'storyteller_changed',\n    'available_scripts_updated',\n    'roles_selected',\n    'setup_characters_selected',\n    'setup_validated',\n    'character_modifications_applied',\n    'reminder_token_added',\n    'reminder_token_removed',\n    'character_pool_created',\n    'ptt_session_started',\n    'ptt_session_ended',\n    'ptt_transcript_ready',\n    'game_event_extracted',\n    'journal_entry_created'\n  ]),\n  timestamp: z.date(),\n  actorId: SeatIdSchema.optional(),\n  payload: z.record(z.any())\n});\nexport type Event = z.infer<typeof EventSchema>;\n\n// WebSocket Messages\nexport const WSMessageSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('subscribe'),\n  gameId: GameIdSchema,\n  viewerSeatId: SeatIdSchema.optional()\n  }),\n  z.object({\n    type: z.literal('event'),\n    event: EventSchema\n  }),\n  z.object({\n    type: z.literal('cmd'),\n    cmd: z.object({\n      kind: z.enum(['nominate', 'vote', 'chat', 'ability', 'ptt_start', 'ptt_end', 'ptt_toggle']),\n      payload: z.record(z.any())\n    })\n  })\n]);\nexport type WSMessage = z.infer<typeof WSMessageSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-definitions.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-definitions.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token enum",
        "line": 13,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Common definitions for game actions, selections, effects, and modifiers\n * This module reduces tight coupling by centralizing all game mechanic constants\n */\n\n// ============================================================================\n// ACTION TYPES\n// ============================================================================\n\n/**\n * Character action types - what characters can do\n */\nexport enum CharacterActionType {\n  // Information gathering\n  LEARN_EVIL_PAIRS_COUNT = 'learnEvilPairsCount',\n  LEARN_EVIL_NEIGHBOR_COUNT = 'learnEvilNeighborCount', \n  LEARN_PLAYER_INFO = 'learnPlayerInfo',\n  LEARN_CHARACTER_TYPE = 'learnCharacterType',\n  LEARN_ROLE_IDENTITY = 'learnRoleIdentity',\n  DETECT_OUTSIDER = 'detectOutsider',\n  DETECT_MINION = 'detectMinion',\n  DETECT_DEMON = 'detectDemon',\n  \n  // Player targeting/selection\n  CHOOSE_PLAYER = 'choosePlayer',\n  CHOOSE_PLAYERS = 'choosePlayers',\n  CHOOSE_3_PLAYERS = 'choose3Players',\n  CHOOSE_MASTER = 'chooseMaster',\n  CHOOSE_CHARACTER_TYPE = 'chooseCharacterType',\n  CHOOSE_MINION_OR_DEMON = 'chooseMinion-OrDemon',\n  \n  // Killing and protection\n  KILL_PLAYER = 'killPlayer',\n  CHOOSE_PLAYER_KILL = 'choosePlayerKill',\n  KILL_CHOSEN_PLAYER_ONCE = 'killChosenPlayerOnce',\n  PROTECT_PLAYER = 'protectPlayer',\n  PROTECT_GOOD_NEIGHBORS_PASSIVE = 'protectGoodNeighborsPassive',\n  FIRST_DEATH_SURVIVE = 'firstDeathSurvive',\n  \n  // Status effects\n  POISON_PLAYER = 'poisonPlayer',\n  MADNESS_PLAYER = 'madnessPlayer',\n  DRUNK_PLAYER = 'drunkPlayer',\n  CHOOSE_CHARACTER_TO_BE_DRUNK = 'chooseCharacterToBeDeunk',\n  \n  // Voting and nominations\n  NOMINATE = 'nominate',\n  NOMINATE_AGAIN = 'nominateAgain',\n  VOTE_MANIPULATION = 'voteManipulation',\n  ENFORCE_VOTING_RESTRICTION = 'enforceVotingRestriction',\n  RESTRICT_OWN_VOTE = 'restrictOwnVote',\n  DEAD_REGAIN_VOTE = 'deadRegainVote',\n  \n  // Information sharing\n  SHARE_LEARNED_INFO = 'shareLearnedInfo',\n  GIVE_INCORRECT_INFO = 'giveIncorrectInfo',\n  SAY_PHRASE = 'sayPhrase',\n  \n  // Special abilities\n  GAIN_ABILITY = 'gainAbility',\n  BLOCK_DEMON = 'blockDemon',\n  DEMON_MAY_CHOOSE_NOT_TO_ATTACK = 'demonMayChooseNotToAttack',\n  STORYTELLER_GAINS_MINION_ABILITY = 'storytellerGainsMinion-Ability',\n  KILLED_MINION_KEEPS_ABILITY_POISON_NEIGHBOR = 'killedMinionKeepsAbilityPoisonNeighbor',\n  \n  // Legion specific\n  CHOOSE_PLAYER_TO_DIE = 'choosePlayerToDie',\n}\n\n/**\n * Meta action types - script-level actions\n */\nexport enum MetaActionType {\n  SHOW_TEAM_TO_MINIONS = 'showTeamToMinions',\n  SHOW_TEAM_AND_BLUFFS_TO_DEMON = 'showTeamAndBluffsToDemon',\n  SETUP_MADNESS = 'setupMadness',\n  DISTRIBUTE_ROLES = 'distributeRoles',\n  APPLY_FIRST_NIGHT_INFO = 'applyFirstNightInfo',\n  ASSIGN_RED_HERRING = 'assignRedHerring',\n  RECEIVE_BLUFF_CHARACTERS = 'receiveBluffCharacters',\n  COORDINATE_EVIL_TEAM = 'coordinateEvilTeam',\n  MAINTAIN_BLUFF = 'maintainBluff',\n  DEFLECT_ATTENTION = 'deflectAttention',\n  VOTE_TO_SURVIVE = 'voteToSurvive',\n  AVOID_EXECUTION = 'avoidExecution',\n  SACRIFICE_MINIONS = 'sacrificeMinions',\n}\n\n// ============================================================================\n// EFFECT TYPES AND STATUS CONDITIONS\n// ============================================================================\n\n/**\n * Status effects that can be applied to players\n */\nexport enum StatusEffect {\n  // Basic status conditions\n  POISONED = 'poisoned',\n  DRUNK = 'drunk',\n  MAD = 'mad',\n  PROTECTED = 'protected',\n  DEAD = 'dead',\n  \n  // Voting restrictions and modifications\n  MASTER = 'master',\n  CAN_VOTE_ONLY_WITH_MASTER = 'canVoteOnlyWithMaster',\n  VOTE_COUNTS_NEGATIVELY = 'voteCountsNegatively',\n  CANNOT_VOTE = 'cannotVote',\n  DEAD_VOTE_USED = 'deadVoteUsed',\n  \n  // Character-specific statuses\n  SLAYER_USED = 'slayerUsed',\n  VIRGIN_TRIGGERED = 'virginTriggered',\n  BUTLER_MASTER_SET = 'butlerMasterSet',\n  INNKEEPER_PROTECTION = 'innkeeperProtection',\n  SOLDIER_PROTECTION = 'soldierProtection',\n  TEA_LADY_PROTECTION = 'teaLadyProtection',\n  \n  // Information tracking\n  LEARNED_INFO = 'learnedInfo',\n  BLUFF_GIVEN = 'bluffGiven',\n  FALSE_INFO_GIVEN = 'falseInfoGiven',\n  \n  // Game state modifiers\n  NOMINATED_TODAY = 'nominatedToday',\n  EXECUTED_TODAY = 'executedToday',\n  ACTED_TONIGHT = 'actedTonight',\n  \n  // Special conditions\n  STARPASS_CANDIDATE = 'starpassCandidate',\n  DEMON_INFO_RECEIVED = 'demonInfoReceived',\n  MINION_INFO_RECEIVED = 'minionInfoReceived',\n}\n\n/**\n * Duration types for effects\n */\nexport enum EffectDuration {\n  INSTANT = 'instant',\n  TONIGHT = 'tonight',\n  UNTIL_DUSK = 'untilDusk',\n  ONE_DAY = 'oneDay',\n  ONE_NIGHT = 'oneNight',\n  PERMANENT = 'permanent',\n  UNTIL_DEATH = 'untilDeath',\n  UNTIL_ABILITY_USED = 'untilAbilityUsed',\n}\n\n/**\n * Effect target types\n */\nexport enum EffectTarget {\n  SELF = 'self',\n  SELECTED = 'selected',\n  ONE_OF_SELECTED = 'oneOfSelected',\n  ALL_SELECTED = 'allSelected',\n  ALL_PLAYERS = 'allPlayers',\n  NEIGHBORS = 'neighbors',\n  STORYTELLER = 'storyteller',\n}\n\n// ============================================================================\n// SELECTION CRITERIA\n// ============================================================================\n\n/**\n * Player teams for selection restrictions\n */\nexport enum PlayerTeam {\n  TOWNSFOLK = 'townsfolk',\n  OUTSIDERS = 'outsiders', \n  MINIONS = 'minions',\n  DEMONS = 'demons',\n  TRAVELLER = 'traveller',\n  FABLED = 'fabled',\n}\n\n/**\n * Selection modifiers\n */\nexport enum SelectionModifier {\n  ALLOW_SELF = 'allowSelf',\n  ALLOW_DEAD = 'allowDead',\n  REQUIRE_ALIVE = 'requireAlive',\n  ADJACENT_ONLY = 'adjacentOnly',\n  DIFFERENT_TEAM = 'differentTeam',\n  SAME_TEAM = 'sameTeam',\n  NOT_STORYTELLER = 'notStoryteller',\n}\n\n/**\n * Common character tags for selection restrictions\n */\nexport enum CharacterTag {\n  ACTIVE = 'active',\n  PASSIVE = 'passive',\n  ONCE_PER_GAME = 'once-per-game',\n  EACH_NIGHT = 'each-night',\n  INFORMATION = 'information',\n  KILL = 'kill',\n  PROTECT = 'protect',\n  MANIPULATE = 'manipulate',\n  VOTE_MODIFIER = 'vote-modifier',\n  SETUP_MODIFIER = 'setup-modifier',\n  CHARACTER_CHANGE = 'character-change',\n  STATUS_EFFECT = 'status-effect',\n}\n\n// ============================================================================\n// GAME PHASE DEFINITIONS\n// ============================================================================\n\n/**\n * Game phases when actions can occur\n */\nexport enum ActionPhase {\n  FIRST_NIGHT = 'firstNight',\n  OTHER_NIGHTS = 'otherNights', \n  DAY = 'day',\n  NOMINATIONS = 'nominations',\n  VOTING = 'voting',\n  EXECUTION = 'execution',\n}\n\n// ============================================================================\n// TARGET SELECTION DEFINITIONS  \n// ============================================================================\n\n/**\n * Standard target selection configurations\n */\nexport const TARGET_SELECTIONS = {\n  SINGLE_PLAYER: {\n    minTargets: 1,\n    maxTargets: 1,\n    allowSelf: false,\n    requireAlive: true,\n  },\n  SINGLE_PLAYER_ALLOW_SELF: {\n    minTargets: 1,\n    maxTargets: 1,\n    allowSelf: true,\n    requireAlive: true,\n  },\n  SINGLE_PLAYER_ALLOW_DEAD: {\n    minTargets: 1,\n    maxTargets: 1,\n    allowSelf: false,\n    allowDead: true,\n  },\n  TWO_PLAYERS: {\n    minTargets: 2,\n    maxTargets: 2,\n    allowSelf: false,\n    requireAlive: true,\n  },\n  THREE_PLAYERS: {\n    minTargets: 3,\n    maxTargets: 3,\n    allowSelf: false,\n    requireAlive: true,\n  },\n  ADJACENT_NEIGHBORS: {\n    minTargets: 2,\n    maxTargets: 2,\n    allowSelf: false,\n    adjacentOnly: true,\n    requireAlive: true,\n  },\n  ANY_PLAYER_INCLUDING_DEAD: {\n    minTargets: 1,\n    maxTargets: 1,\n    allowSelf: true,\n    allowDead: true,\n  },\n} as const;\n\n// ============================================================================\n// COMMON EFFECT DEFINITIONS\n// ============================================================================\n\n/**\n * Standard effect configurations\n */\nexport const COMMON_EFFECTS = {\n  POISON_TONIGHT: {\n    status: StatusEffect.POISONED,\n    target: EffectTarget.SELECTED,\n    duration: EffectDuration.TONIGHT,\n  },\n  POISON_PERMANENT: {\n    status: StatusEffect.POISONED,\n    target: EffectTarget.SELECTED,\n    duration: EffectDuration.PERMANENT,\n  },\n  PROTECT_TONIGHT: {\n    status: StatusEffect.PROTECTED,\n    target: EffectTarget.SELECTED,\n    duration: EffectDuration.TONIGHT,\n  },\n  KILL_INSTANTLY: {\n    status: StatusEffect.DEAD,\n    target: EffectTarget.SELECTED,\n    duration: EffectDuration.INSTANT,\n  },\n  SET_AS_MASTER: {\n    status: StatusEffect.MASTER,\n    target: EffectTarget.SELECTED,\n    duration: EffectDuration.ONE_DAY,\n  },\n  VOTING_RESTRICTION: {\n    status: StatusEffect.CAN_VOTE_ONLY_WITH_MASTER,\n    target: EffectTarget.SELF,\n    duration: EffectDuration.ONE_DAY,\n  },\n  MARK_ABILITY_USED: {\n    status: StatusEffect.SLAYER_USED,\n    target: EffectTarget.SELF,\n    duration: EffectDuration.PERMANENT,\n  },\n} as const;\n\n// ============================================================================\n// INFORMATION PATTERNS\n// ============================================================================\n\n/**\n * Common information delivery patterns\n */\nexport const INFO_PATTERNS = {\n  COUNT_MESSAGE: \"You see [COUNT] {description}\",\n  PLAYER_IDENTITY: \"You learn that [PLAYER] is the {role}\",\n  YES_NO_ANSWER: \"{question}: [YES/NO]\",\n  PLAYER_LIST: \"These players are {description}: [PLAYERS]\",\n  CUSTOM_TEMPLATE: \"[CUSTOM_MESSAGE]\",\n} as const;\n\n// ============================================================================\n// VALIDATION RULES\n// ============================================================================\n\n/**\n * Common validation patterns for actions\n */\nexport const VALIDATION_RULES = {\n  ONCE_PER_GAME: {\n    maxUses: 1,\n    scope: 'game',\n  },\n  ONCE_PER_NIGHT: {\n    maxUses: 1,\n    scope: 'night',\n  },\n  ONCE_PER_DAY: {\n    maxUses: 1,\n    scope: 'day',\n  },\n  UNLIMITED: {\n    maxUses: -1,\n    scope: 'none',\n  },\n} as const;\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if an action type is a character action\n */\nexport function isCharacterAction(actionType: string): actionType is CharacterActionType {\n  return Object.values(CharacterActionType).includes(actionType as CharacterActionType);\n}\n\n/**\n * Check if an action type is a meta action\n */\nexport function isMetaAction(actionType: string): actionType is MetaActionType {\n  return Object.values(MetaActionType).includes(actionType as MetaActionType);\n}\n\n/**\n * Get all action types (both character and meta)\n */\nexport function getAllActionTypes(): string[] {\n  return [...Object.values(CharacterActionType), ...Object.values(MetaActionType)];\n}\n\n/**\n * Validate that a status effect exists\n */\nexport function isValidStatusEffect(status: string): status is StatusEffect {\n  return Object.values(StatusEffect).includes(status as StatusEffect);\n}\n\n/**\n * Validate that an effect duration exists\n */\nexport function isValidEffectDuration(duration: string): duration is EffectDuration {\n  return Object.values(EffectDuration).includes(duration as EffectDuration);\n}\n\n/**\n * Validate that an effect target exists\n */\nexport function isValidEffectTarget(target: string): target is EffectTarget {\n  return Object.values(EffectTarget).includes(target as EffectTarget);\n}\n\n/**\n * Create a standardized effect object\n */\nexport function createEffect(\n  status: StatusEffect,\n  target: EffectTarget,\n  duration: EffectDuration,\n  value?: string | number | boolean\n) {\n  return {\n    status,\n    target,\n    duration,\n    ...(value !== undefined && { value }),\n  };\n}\n\n/**\n * Create a standardized selection object\n */\nexport function createSelection(\n  minTargets: number,\n  maxTargets: number,\n  modifiers: Partial<{\n    allowSelf: boolean;\n    allowDead: boolean;\n    requireAlive: boolean;\n    adjacentOnly: boolean;\n    restrictByTeam: PlayerTeam[];\n    restrictByTags: CharacterTag[];\n  }> = {}\n) {\n  return {\n    minTargets,\n    maxTargets,\n    ...modifiers,\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-state-types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-state-types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 21,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { JournalSchema } from './journal';\nimport { SeatIdSchema, PlayerIdSchema } from './core-types';\nimport * as Enums from './enums';\n\n// Game State Types\nexport const SeatSchema = z.object({\n  id: SeatIdSchema,\n  playerId: PlayerIdSchema.optional(),\n  isNPC: z.boolean(),\n  position: z.number(),\n  alignment: z.nativeEnum(Enums.Alignment).optional(), // Hidden from clients\n  role: z.string().optional(), // Hidden from clients\n  statuses: z.array(z.string()).default([]),\n  isAlive: z.boolean().default(true),\n  votingPower: z.number().default(1),\n  // Marks this seat as the storyteller in the lobby (storyteller gets full grimoire view)\n  isStoryteller: z.boolean().optional(),\n  journal: JournalSchema.optional(),\n});\nexport type Seat = z.infer<typeof SeatSchema>;\n\nexport const AbilitySchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  roleId: z.string(),\n  actorSeat: SeatIdSchema,\n  targets: z.array(SeatIdSchema),\n  timing: z.enum(['night', 'day', 'passive']),\n  remainingUses: z.number().optional(),\n  precedence: z.number() // Lower = earlier in night order\n});\nexport type Ability = z.infer<typeof AbilitySchema>;\n\n// Day Phase: Nominations & Votes\nexport const NominationSchema = z.object({\n  id: z.string().uuid(),\n  nominator: SeatIdSchema,\n  nominee: SeatIdSchema,\n  createdAt: z.date(),\n  closed: z.boolean().default(false)\n});\nexport type Nomination = z.infer<typeof NominationSchema>;\n\nexport const VoteRecordSchema = z.object({\n  voter: SeatIdSchema,\n  vote: z.boolean(),\n  timestamp: z.date()\n});\nexport type VoteRecord = z.infer<typeof VoteRecordSchema>;\n\nexport const VoteSessionSchema = z.object({\n  nominationId: z.string().uuid(),\n  startedAt: z.date(),\n  votes: z.array(VoteRecordSchema),\n  tally: z.object({ yes: z.number(), no: z.number() }).default({ yes: 0, no: 0 }),\n  finished: z.boolean().default(false)\n});\nexport type VoteSession = z.infer<typeof VoteSessionSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-state.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/game-state.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 49,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { JournalSchema } from './journal';\nimport * as Enums from './enums';\nimport { SeatIdSchema, PlayerIdSchema, GameIdSchema } from './core-types';\nimport { SeatSchema, AbilitySchema, NominationSchema, VoteSessionSchema } from './game-state-types';\nimport { SetupStateSchema, GrimoireStateSchema } from './setup-types';\n\nexport const GameStateSchema = z.object({\n  id: GameIdSchema,\n  phase: z.nativeEnum(Enums.GamePhase),\n  day: z.number(),\n  seed: z.string(),\n  // Human-friendly name for the game (set by host)\n  gameName: z.string().optional(),\n  // Whether this game is visible in public game lists (default: true)\n  isPublic: z.boolean().default(true),\n  scriptId: z.string(),\n  seats: z.array(SeatSchema),\n  abilities: z.array(AbilitySchema),\n  // Day phase structures\n  currentNomination: NominationSchema.optional(),\n  currentVote: VoteSessionSchema.optional(),\n  // Storyteller seat (if any)\n  storytellerSeatId: SeatIdSchema.optional(),\n  // Scripts made available by storyteller for players to see/propose\n  availableScriptIds: z.array(z.string()).default([]),\n  // Script proposals and voting while in lobby\n  scriptProposals: z.array(z.object({\n    id: z.string().uuid(),\n    scriptId: z.string(),\n    proposers: z.array(SeatIdSchema).default([]),\n    // Legacy yes/no votes (kept for compatibility)\n    votes: z.record(z.boolean()).default({}),\n    // New difficulty votes per seat\n    difficultyVotes: z.record(z.enum(['beginner','intermediate','advanced'])).default({}),\n    createdAt: z.date()\n  })).default([]),\n  // Optional list of role IDs selected by the storyteller for this game\n  selectedRoles: z.array(z.string()).optional(),\n  // Optional map of seatId -> roleId claimed/picked before start\n  roleClaims: z.record(z.string()).optional(),\n  // Setup state for SETUP phase\n  setupState: SetupStateSchema.optional(),\n  // Grimoire state for storyteller\n  grimoireState: GrimoireStateSchema.optional(),\n  createdAt: z.date(),\n  updatedAt: z.date()\n});\nexport type GameState = z.infer<typeof GameStateSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/handlers/information-handlers.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'getSeatDisplayName' is assigned a value but never used.",
        "line": 13,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\n/**\n * Information Gathering Action Handlers\n * Handles character abilities that provide information to players\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.handleLearnEvilPairsCount = handleLearnEvilPairsCount;\nexports.handleLearnEvilNeighborCount = handleLearnEvilNeighborCount;\nexports.handleLearnPlayerInfo = handleLearnPlayerInfo;\n\nconst {\n  getPlayerSeats,\n  getSeatDisplayName,\n  isEvil,\n} = require(\"../utils/game-utils\");\n\n/**\n * Chef: Count pairs of neighboring evil players\n */\nfunction handleLearnEvilPairsCount(action, context, game, actingSeat) {\n  const playerSeats = getPlayerSeats(game);\n  let pairCount = 0;\n\n  for (let i = 0; i < playerSeats.length; i++) {\n    const current = playerSeats[i];\n    const next = playerSeats[(i + 1) % playerSeats.length];\n    if (isEvil(current) && isEvil(next)) {\n      pairCount++;\n    }\n  }\n\n  const information = action.information?.customMessage\n    ? action.information.customMessage.replace(\"[COUNT]\", pairCount.toString())\n    : `You see ${pairCount} pairs of neighboring evil players`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      count: pairCount,\n    },\n  };\n}\n\n/**\n * Empath: Count evil neighbors\n */\nfunction handleLearnEvilNeighborCount(action, context, game, actingSeat) {\n  const playerSeats = getPlayerSeats(game);\n  const actingIndex = playerSeats.findIndex((s) => s.id === actingSeat.id);\n\n  if (actingIndex === -1) {\n    return {\n      actionId: action.id,\n      success: false,\n      errors: [\"Acting seat not found among players\"],\n    };\n  }\n\n  const leftNeighbor =\n    playerSeats[(actingIndex - 1 + playerSeats.length) % playerSeats.length];\n  const rightNeighbor = playerSeats[(actingIndex + 1) % playerSeats.length];\n  const evilCount =\n    (isEvil(leftNeighbor) ? 1 : 0) + (isEvil(rightNeighbor) ? 1 : 0);\n\n  const information = action.information?.customMessage\n    ? action.information.customMessage.replace(\"[COUNT]\", evilCount.toString())\n    : `You see ${evilCount} evil neighbors`;\n\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: information,\n      count: evilCount,\n    },\n  };\n}\n\n/**\n * Investigative actions (Washerwoman, Librarian, Investigator, etc.)\n */\nfunction handleLearnPlayerInfo(action, context, game, actingSeat) {\n  // This is a more complex action that would need character-specific logic\n  // For now, return a placeholder implementation\n  return {\n    actionId: action.id,\n    success: true,\n    information: {\n      recipient: actingSeat.id,\n      message: \"You learn information about a player\",\n    },\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/handlers/meta-handlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/handlers/status-handlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/handlers/targeting-handlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/handlers/voting-handlers.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/importSchemas.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 34,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport * as Enums from './enums';\n\n// Raw scraped town/edition metadata from the wiki\nexport const ScrapedTownSchema = z.object({\n  id: z.string().min(1), // slug, e.g., 'trouble-brewing'\n  name: z.string().min(1), // display name\n  wikiUrl: z.string().url().optional(),\n  imageUrl: z.string().url().optional(),\n  description: z.string().optional(),\n  region: z.string().optional(),\n  population: z.number().int().nonnegative().optional(),\n  notableLocations: z.array(z.string()).optional(),\n  resources: z.array(z.string()).optional(),\n  governance: z.string().optional(),\n  coordinates: z.object({\n    x: z.number().optional(),\n    y: z.number().optional()\n  }).optional(),\n  connections: z.array(z.string()).optional(),\n  // Optional distribution details per player count (5..15). If absent, engine fallback rules apply.\n  distributionByPlayerCount: z\n    .record(\n      z.string(), // player count as string key e.g., '5'\n      z.object({\n  [Enums.RoleType.TOWNSFOLK]: z.number().int().nonnegative(),\n  [Enums.RoleType.OUTSIDER]: z.number().int().nonnegative(),\n  [Enums.RoleType.MINION]: z.number().int().nonnegative(),\n  [Enums.RoleType.DEMON]: z.number().int().nonnegative()\n      })\n    )\n    .optional()\n});\nexport type ScrapedTown = z.infer<typeof ScrapedTownSchema>;\n\n// Raw scraped character from the wiki\nexport const ScrapedCharacterSchema = z.object({\n  id: z.string().min(1), // machine-friendly slug, e.g., 'empath'\n  name: z.string().min(1), // character name\n  category: z.enum(['Townsfolk', 'Outsider', 'Minion', 'Demon', 'Traveller', 'Fabled']),\n  edition: z.array(z.string()).min(1), // list of editions the character appears in\n  abilitySummary: z.string().min(1), // concise ability description\n  firstNightAction: z.string().nullable().optional(), // instructions for the first night (or null)\n  otherNightsAction: z.string().nullable().optional(), // instructions for every other night (or null)\n  dayAction: z.string().nullable().optional(), // actions triggered during the day (if any)\n  tags: z.array(z.string()).optional(), // [\"information\", \"misinformation\", \"killing\", etc.]\n  tokensUsed: z.array(z.string()).optional(), // names of reminder tokens used by the Storyteller\n  wikiUrl: z.string().url().optional(), // source page\n  imageUrl: z.string().url().optional() // link to character art if available\n});\nexport type ScrapedCharacter = z.infer<typeof ScrapedCharacterSchema>;\n\n// Bulk payloads\nexport const ScrapedCharactersFileSchema = z.object({\n  characters: z.array(ScrapedCharacterSchema)\n});\nexport type ScrapedCharactersFile = z.infer<typeof ScrapedCharactersFileSchema>;\n\nexport const ScrapedTownsFileSchema = z.object({\n  towns: z.array(ScrapedTownSchema)\n});\nexport type ScrapedTownsFile = z.infer<typeof ScrapedTownsFileSchema>;\n\n// Helpers\nexport function toAlignment(category: ScrapedCharacter['category']): typeof Enums.Alignment[keyof typeof Enums.Alignment] {\n  switch (category) {\n    case 'Townsfolk':\n    case 'Outsider':\n  return Enums.Alignment.GOOD;\n    case 'Minion':\n    case 'Demon':\n  return Enums.Alignment.EVIL;\n    default:\n  return Enums.Alignment.GOOD; // Travellers and Fabled default to good\n  }\n}\n\nexport function toRoleType(category: ScrapedCharacter['category']): typeof Enums.RoleType[keyof typeof Enums.RoleType] | null {\n  switch (category) {\n    case 'Townsfolk':\n  return Enums.RoleType.TOWNSFOLK;\n    case 'Outsider':\n  return Enums.RoleType.OUTSIDER;\n    case 'Minion':\n  return Enums.RoleType.MINION;\n    case 'Demon':\n  return Enums.RoleType.DEMON;\n    default:\n      return null; // travellers and fabled are not modeled (yet)\n  }\n}\n\n// Utility functions for data transformation\nexport class WikiDataTransformer {\n  static generateId(name: string): string {\n    return name.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');\n  }\n\n  static parseNumber(value: string | number | undefined): number {\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string') {\n      const parsed = parseInt(value.replace(/[^\\d]/g, ''), 10);\n      return isNaN(parsed) ? 0 : parsed;\n    }\n    return 0;\n  }\n\n  static cleanArray(arr: string[] | undefined): string[] {\n    return arr?.filter(item => item && item.trim()) || [];\n  }\n\n  static validateTownData(rawData: any): ScrapedTown {\n    // Transform raw scraped data to match schema\n    const transformed = {\n      id: rawData.id || this.generateId(rawData.name),\n      name: rawData.name,\n      description: rawData.description || '',\n      region: rawData.region || '',\n      population: this.parseNumber(rawData.population),\n      notableLocations: this.cleanArray(rawData.notable_locations || rawData.notableLocations),\n      resources: this.cleanArray(rawData.resources),\n      governance: rawData.governance || '',\n      coordinates: {\n        x: rawData.coordinates?.x || 0,\n        y: rawData.coordinates?.y || 0\n      },\n      connections: this.cleanArray(rawData.connections),\n      wikiUrl: rawData.wiki_url || rawData.wikiUrl,\n      imageUrl: rawData.image_url || rawData.imageUrl,\n      distributionByPlayerCount: rawData.distributionByPlayerCount\n    };\n    \n    return ScrapedTownSchema.parse(transformed);\n  }\n\n  static validateCharacterData(rawData: any): ScrapedCharacter {\n    // Transform raw scraped data to match schema\n    const transformed = {\n      id: rawData.id || this.generateId(rawData.name),\n      name: rawData.name,\n      category: rawData.category || this.mapLegacyTypeToCategory(rawData.type),\n      edition: Array.isArray(rawData.edition) ? rawData.edition : \n               rawData.edition ? [rawData.edition] : \n               rawData.editionId ? [rawData.editionId] : ['Unknown'],\n      abilitySummary: rawData.ability_summary || rawData.abilitySummary || rawData.abilityText || '',\n      firstNightAction: rawData.first_night_action || rawData.firstNightAction || null,\n      otherNightsAction: rawData.other_nights_action || rawData.otherNightsAction || null,\n      dayAction: rawData.day_action || rawData.dayAction || null,\n      tags: this.cleanArray(rawData.tags),\n      tokensUsed: this.cleanArray(rawData.tokens_used || rawData.tokensUsed || rawData.reminders),\n      wikiUrl: rawData.wiki_url || rawData.wikiUrl,\n      imageUrl: rawData.image_url || rawData.imageUrl || rawData.iconUrl\n    };\n    \n    return ScrapedCharacterSchema.parse(transformed);\n  }\n\n  private static mapLegacyTypeToCategory(type: string): string {\n    if (!type) return 'Townsfolk';\n    \n    const typeMap: Record<string, string> = {\n      'townsfolk': 'Townsfolk',\n      'outsider': 'Outsider', \n      'minion': 'Minion',\n      'demon': 'Demon',\n      'traveller': 'Traveller',\n      'fabled': 'Fabled'\n    };\n    \n    return typeMap[type.toLowerCase()] || 'Townsfolk';\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/journal.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/journal.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 7,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\nexport const JournalEntrySchema = z.object({\n  text: z.string(),\n  timestamp: z.date(),\n});\nexport type JournalEntry = z.infer<typeof JournalEntrySchema>;\n\nexport const AvailableMoveSchema = z.object({\n  id: z.string(),\n  label: z.string(),\n  description: z.string(),\n});\nexport type AvailableMove = z.infer<typeof AvailableMoveSchema>;\n\nexport const JournalSchema = z.object({\n  notes: z.array(JournalEntrySchema).default([]),\n  moves: z.array(AvailableMoveSchema).default([]),\n});\nexport type Journal = z.infer<typeof JournalSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/llm-tools.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/llm-tools.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 9,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { SeatIdSchema, GameIdSchema } from './core-types';\n\n// LLM Tool Schemas\nexport const GameStateReadInputSchema = z.object({\n  mask: z.enum(['seat', 'public', 'narrator']),\n  includeChat: z.boolean().optional()\n});\nexport type GameStateReadInput = z.infer<typeof GameStateReadInputSchema>;\n\nexport const NightActionInputSchema = z.object({\n  abilityId: z.string(),\n  targets: z.array(SeatIdSchema)\n});\nexport type NightActionInput = z.infer<typeof NightActionInputSchema>;\n\nexport const VoteCastInputSchema = z.object({\n  nominee: SeatIdSchema,\n  vote: z.boolean()\n});\nexport type VoteCastInput = z.infer<typeof VoteCastInputSchema>;\n\nexport const TalkSendInputSchema = z.object({\n  channel: z.enum(['table', 'whisper']),\n  text: z.string().optional(),\n  emotion: z.string().optional()\n});\nexport type TalkSendInput = z.infer<typeof TalkSendInputSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/ptt-types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 6,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport * as CoreTypes from './core-types';\n\n// PTT-related types\nexport const PTTModeSchema = z.enum(['hold', 'toggle']);\nexport type PTTMode = z.infer<typeof PTTModeSchema>;\n\nexport const PTTSessionSchema = z.object({\n  id: z.string().uuid(),\n  seatId: CoreTypes.SeatIdSchema,\n  startTime: z.date(),\n  endTime: z.date().optional(),\n  audioUri: z.string().optional(),\n  transcript: z.string().optional(),\n  wordLevelTranscript: z.array(z.object({\n    word: z.string(),\n    start: z.number(),\n    end: z.number(),\n    confidence: z.number()\n  })).optional()\n});\nexport type PTTSession = z.infer<typeof PTTSessionSchema>;\n\nexport const GameEventSchema = z.object({\n  id: z.string().uuid(),\n  type: z.enum(['nomination', 'vote', 'claim', 'contradiction', 'other']),\n  seatId: CoreTypes.SeatIdSchema,\n  timestamp: z.date(),\n  content: z.string(),\n  confidence: z.number().optional(),\n  relatedSeats: z.array(CoreTypes.SeatIdSchema).optional()\n});\nexport type GameEvent = z.infer<typeof GameEventSchema>;\n\nexport const PTTJournalEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.date(),\n  phase: z.string(),\n  highlights: z.array(z.string()),\n  watchlist: z.array(z.object({\n  seatId: CoreTypes.SeatIdSchema,\n    reason: z.string(),\n    priority: z.enum(['low', 'medium', 'high'])\n  })),\n  summary: z.string(),\n  redactedContent: z.record(z.any()).optional() // For night info redaction\n});\nexport type PTTJournalEntry = z.infer<typeof PTTJournalEntrySchema>;\n\nexport const PTTStateSchema = z.object({\n  isMuted: z.boolean(),\n  isSpeaking: z.boolean(),\n  mode: PTTModeSchema,\n  cooldownEndTime: z.date().optional(),\n  currentSession: PTTSessionSchema.optional(),\n  lastSession: PTTSessionSchema.optional()\n});\nexport type PTTState = z.infer<typeof PTTStateSchema>;\n\nexport const VideoTileStateSchema = z.object({\n  seatId: CoreTypes.SeatIdSchema,\n  isMuted: z.boolean(),\n  isSpeaking: z.boolean(),\n  volume: z.number(), // 0-1\n  isDucked: z.boolean()\n});\nexport type VideoTileState = z.infer<typeof VideoTileStateSchema>;\n\n// API request/response types\nexport const ASRSummaryRequestSchema = z.object({\n  turns: z.array(PTTSessionSchema),\n  events: z.array(GameEventSchema),\n  viewerRole: z.string(),\n  phase: z.string()\n});\nexport type ASRSummaryRequest = z.infer<typeof ASRSummaryRequestSchema>;\n\nexport const ASRSummaryResponseSchema = z.object({\n  highlights: z.array(z.string()),\n  watchlist: z.array(z.object({\n  seatId: CoreTypes.SeatIdSchema,\n    reason: z.string(),\n    priority: z.enum(['low', 'medium', 'high'])\n  })),\n  summary: z.string()\n});\nexport type ASRSummaryResponse = z.infer<typeof ASRSummaryResponseSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/scoring.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 7,
        "column": 50,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 7,
        "endColumn": 53
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 8,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 8,
        "endColumn": 52
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 9,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 9,
        "endColumn": 49
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 10,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 10,
        "endColumn": 58
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 11,
        "column": 45,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 11,
        "endColumn": 48
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: -100.",
        "line": 12,
        "column": 36,
        "nodeType": "UnaryExpression",
        "messageId": "noMagic",
        "endLine": 12,
        "endColumn": 40
      },
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: 100.",
        "line": 12,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "noMagic",
        "endLine": 12,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScoringMetricsSchema = void 0;\nconst zod_1 = require(\"zod\");\n// Scoring Types\nexports.ScoringMetricsSchema = zod_1.z.object({\n    informationGain: zod_1.z.number().min(0).max(100),\n    controlBalance: zod_1.z.number().min(0).max(100),\n    timeCushion: zod_1.z.number().min(0).max(100),\n    redundancyRobustness: zod_1.z.number().min(0).max(100),\n    volatility: zod_1.z.number().min(0).max(100),\n    momentum: zod_1.z.number().min(-100).max(100)\n});\n//# sourceMappingURL=scoring.js.map",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/scoring.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 12,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\n// Scoring Types\nexport const ScoringMetricsSchema = z.object({\n  informationGain: z.number().min(0).max(100),\n  controlBalance: z.number().min(0).max(100),\n  timeCushion: z.number().min(0).max(100),\n  redundancyRobustness: z.number().min(0).max(100),\n  volatility: z.number().min(0).max(100),\n  momentum: z.number().min(-100).max(100)\n});\nexport type ScoringMetrics = z.infer<typeof ScoringMetricsSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/script-dsl.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/script-dsl.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 36,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport {\n  CharacterActionType,\n  MetaActionType,\n  StatusEffect,\n  EffectDuration,\n  EffectTarget,\n  PlayerTeam,\n  SelectionModifier,\n  CharacterTag,\n  ActionPhase,\n} from './game-definitions';\nimport * as Enums from './enums';\n\n// Script DSL Types\nexport const RoleDefinitionSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  alignment: z.nativeEnum(Enums.Alignment),\n  type: z.nativeEnum(Enums.RoleType),\n  ability: z.object({\n    id: z.string(),\n    when: z.enum(['night', 'day', 'passive']),\n    target: z.string(), // DSL expression\n    effect: z.array(z.record(z.any()))\n  }).optional(),\n  visibility: z.object({\n    reveals: z.object({\n      public: z.enum(['none', 'role', 'alignment']),\n      privateTo: z.array(z.string())\n    })\n  }),\n  precedence: z.number(),\n  reminderTokens: z.array(z.string()).optional() // Text for reminder tokens\n});\nexport type RoleDefinition = z.infer<typeof RoleDefinitionSchema>;\n\n// Target selection schema with standardized options (supports both old and new formats)\nexport const TargetSelectionSchema = z.union([\n  // Old format\n  z.object({\n    minTargets: z.number().min(0),\n    maxTargets: z.number().min(0),\n    allowSelf: z.boolean().optional(),\n    allowDead: z.boolean().optional(),\n    requireAlive: z.boolean().optional(),\n    restrictByTeam: z.array(z.nativeEnum(PlayerTeam)).optional(),\n    restrictByTags: z.array(z.nativeEnum(CharacterTag)).optional(),\n    adjacentOnly: z.boolean().optional(),\n  }),\n  // New parameterized format\n  z.object({\n    type: z.string(), // Selection type like \"ADJACENT_PLAYERS\", \"ANY_PLAYER\", etc.\n    criteria: z.record(z.any()).optional(), // Flexible criteria object\n  })\n]);\nexport type TargetSelection = z.infer<typeof TargetSelectionSchema>;\n\n// Effect specification schema with standardized types (supports both old and new formats)\nexport const EffectSpecSchema = z.union([\n  // Old format\n  z.object({\n    status: z.nativeEnum(StatusEffect),\n    target: z.nativeEnum(EffectTarget),\n    duration: z.nativeEnum(EffectDuration),\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    note: z.string().optional(),\n  }),\n  // New parameterized format\n  z.object({\n    type: z.string(), // Effect type like \"LEARN_INFORMATION\", \"KILL_PLAYER\", etc.\n    target: z.string(), // Target like \"SELF\", \"TARGET\", \"ALL_PLAYERS\", etc.\n    duration: z.string(), // Duration like \"IMMEDIATE\", \"NIGHT\", \"PERMANENT\", etc.\n    information: z.record(z.any()).optional(), // Information to convey\n    statusEffect: z.string().optional(), // Status effect to apply\n    newRole: z.string().optional(), // For role changes\n    condition: z.string().optional(), // Conditional effects\n    value: z.union([z.string(), z.number(), z.boolean()]).optional(),\n    note: z.string().optional(),\n  })\n]);\nexport type EffectSpec = z.infer<typeof EffectSpecSchema>;\n\n// Information spec shared with script meta actions\nexport const InformationSpecSchema = z.object({\n  showPlayersByTeam: z.array(z.nativeEnum(PlayerTeam)).optional(),\n  showPlayers: z.array(z.string()).optional(),\n  showPlayer: z.string().optional(),\n  showRoles: z.boolean().optional(),\n  giveBluffs: z.number().optional(),\n  customMessage: z.string().optional()\n});\nexport type InformationSpec = z.infer<typeof InformationSpecSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/script.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/script.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 36,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { RoleDefinitionSchema } from './script-dsl';\nimport { NightOrderEntrySchema, CharacterActionSchema } from './action-types';\n\nexport const ScriptMetadataSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  author: z.string().optional(),\n  description: z.string().optional(),\n  version: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  playerCount: z.object({\n    min: z.number(),\n    max: z.number(),\n    optimal: z.string().optional()\n  }).optional(),\n  complexity: z.enum(['beginner', 'intermediate', 'advanced']).optional(),\n  estimatedTime: z.string().optional(),\n  characterList: z.array(z.string()).optional(),\n  characterDistribution: z.record(z.number()).optional(),\n  scriptNotes: z.string().optional(),\n  // Legacy fields\n  region: z.string().optional(),\n  population: z.number().optional(),\n  notableLocations: z.array(z.string()).optional(),\n  resources: z.array(z.string()).optional(),\n  governance: z.string().optional(),\n  coordinates: z.object({\n    x: z.number(),\n    y: z.number()\n  }).optional(),\n  connections: z.array(z.string()).optional(),\n  wikiUrl: z.string().url().optional(),\n  imageUrl: z.string().url().optional()\n});\nexport type ScriptMetadata = z.infer<typeof ScriptMetadataSchema>;\n\nexport const ScriptSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  version: z.string(),\n  roles: z.array(RoleDefinitionSchema),\n  setup: z.object({\n    playerCount: z.object({\n      min: z.number(),\n      max: z.number()\n    }),\n    distribution: z.record(z.number()) // roleType -> count\n  }),\n  // Structured night order with meta actions and character actions\n  firstNight: z.array(NightOrderEntrySchema).optional(),\n  nightOrder: z.array(NightOrderEntrySchema).optional(),\n  // Metadata about the script\n  meta: ScriptMetadataSchema.optional()\n});\nexport type Script = z.infer<typeof ScriptSchema>;\n\n// Enhanced Character Types for better data representation\nexport const CharacterSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  team: z.enum(['townsfolk', 'outsider', 'minion', 'demon', 'traveller', 'fabled']),\n  ability: z.string(),\n  firstNight: z.number().optional(),\n  otherNights: z.number().optional(),\n  reminders: z.array(z.string()).optional(),\n  setup: z.boolean().optional(),\n  special: z.object({\n    type: z.enum(['bag-disabled', 'bag-duplicate', 'selection-disabled']),\n    description: z.string().optional()\n  }).optional(),\n  jinx: z.array(z.object({\n    id: z.string(),\n    reason: z.string()\n  })).optional(),\n  // Legacy fields for compatibility with existing JSON data\n  category: z.string().optional(),\n  edition: z.array(z.string()).optional(),\n  abilitySummary: z.string().optional(),\n  firstNightAction: z.string().nullable().optional(),\n  otherNightsAction: z.string().nullable().optional(),\n  dayAction: z.string().nullable().optional(),\n  tags: z.array(z.string()).optional(),\n  tokensUsed: z.array(z.string()).optional(),\n  wikiUrl: z.string().url().optional(),\n  imageUrl: z.string().url().optional(),\n  // New fields for programmatic game engine\n  goal: z.object({\n    action: z.string(),\n    description: z.string(),\n    targets: z.array(z.string()).optional(),\n    effect: z.string().optional(),\n    frequency: z.string().optional()\n  }).optional(),\n  actions: z.object({\n  firstNight: z.array(z.lazy(() => CharacterActionSchema)).optional(),\n  night: z.array(z.lazy(() => CharacterActionSchema)).optional(),\n  day: z.array(z.lazy(() => CharacterActionSchema)).optional(),\n  nominations: z.array(z.lazy(() => CharacterActionSchema)).optional(),\n  voting: z.array(z.lazy(() => CharacterActionSchema)).optional(),\n  execution: z.array(z.lazy(() => CharacterActionSchema)).optional()\n  }).optional()\n});\nexport type Character = z.infer<typeof CharacterSchema>;\n\nexport const LoadedScriptSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  characters: z.array(CharacterSchema),\n  meta: ScriptMetadataSchema.optional(),\n  modifiers: z.array(z.any()).optional(),\n  // Night order with structured actions\n  firstNight: z.array(NightOrderEntrySchema).optional(),\n  nightOrder: z.array(NightOrderEntrySchema).optional(),\n  // Legacy fields for compatibility\n  firstNightOrder: z.array(z.string()).optional(),\n  otherNightOrder: z.array(z.string()).optional()\n});\nexport type LoadedScript = z.infer<typeof LoadedScriptSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/scriptLoader.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token interface",
        "line": 4,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as Types from './types';\nimport * as Script from './script';\n\nexport interface ScriptDataSource {\n  loadCharacters(scriptPath: string): Promise<any>;\n  loadMetadata(scriptPath: string): Promise<any>;\n}\n\nexport class ScriptLoader {\n  private static scriptsCache = new Map<string, Types.LoadedScript>();\n  \n  constructor(private dataSource: ScriptDataSource) {}\n\n  async loadScript(scriptName: string): Promise<Types.LoadedScript> {\n    if (ScriptLoader.scriptsCache.has(scriptName)) {\n      return ScriptLoader.scriptsCache.get(scriptName)!;\n    }\n\n    try {\n      const [charactersData, metaData] = await Promise.all([\n        this.dataSource.loadCharacters(scriptName),\n        this.dataSource.loadMetadata(scriptName).catch(() => null)\n      ]);\n\n      const characters = this.parseCharacters(charactersData);\n      const meta = metaData ? this.parseMetadata(metaData) : undefined;\n\n  const script: Types.LoadedScript = {\n        id: scriptName,\n        name: this.formatScriptName(scriptName),\n        characters,\n        meta,\n        modifiers: metaData?.modifiers,\n        // Include structured night order data from metadata\n        firstNight: metaData?.firstNight,\n        nightOrder: metaData?.nightOrder,\n        // Legacy fields for compatibility\n        firstNightOrder: metaData?.firstNightOrder,\n        otherNightOrder: metaData?.otherNightOrder\n      };\n\n      ScriptLoader.scriptsCache.set(scriptName, script);\n      return script;\n    } catch (error) {\n      throw new Error(`Failed to load script: ${scriptName} - ${error}`);\n    }\n  }\n\n  async getAllScripts(): Promise<Types.LoadedScript[]> {\n    const scriptNames = [\n      'trouble-brewing',\n      'bad-moon-rising', \n      'sects-and-violets',\n      'experimental',\n      'fabled',\n      'travellers',\n      'catfishing',\n      'chaos-theory',\n      'greatest-hits',\n      'mad-as-a-hatter',\n      'no-greater-joy',\n      'on-thin-ice'\n    ];\n\n    return Promise.all(scriptNames.map(name => this.loadScript(name)));\n  }\n\n  private parseCharacters(data: any): Types.Character[] {\n    // Handle different JSON formats\n    let characterArray: any[];\n    \n    if (Array.isArray(data)) {\n      // Check if it's an array of strings or objects\n      if (data.length > 0 && typeof data[0] === 'string') {\n        // Format: [\"character-id\", \"character-id\", ...]\n        characterArray = data.map(id => ({ id, name: this.formatCharacterName(id) }));\n      } else {\n        // Format: [{...}, {...}] - array of character objects\n        characterArray = data;\n      }\n    } else if (data.characters && Array.isArray(data.characters)) {\n      // Format: { \"characters\": [{...}, {...}] }\n      characterArray = data.characters;\n    } else {\n      throw new Error('Invalid character data format');\n    }\n\n    return characterArray.map(char => this.validateAndTransformCharacter(char));\n  }\n\n  private parseMetadata(data: any): Types.ScriptMetadata {\n  return Script.ScriptMetadataSchema.parse({\n  id: data.id,\n      name: data.name,\n      author: data.author,\n      description: data.description,\n      version: data.version,\n      tags: data.tags,\n      playerCount: data.playerCount || data.player_count ? {\n        min: (data.playerCount || data.player_count).min,\n        max: (data.playerCount || data.player_count).max,\n        optimal: (data.playerCount || data.player_count).optimal\n      } : undefined,\n      complexity: data.complexity,\n      estimatedTime: data.estimated_time,\n      characterList: data.character_list,\n      characterDistribution: data.character_distribution,\n      scriptNotes: data.script_notes,\n      // Legacy fields\n      region: data.region,\n      population: data.population,\n      notableLocations: data.notable_locations,\n      resources: data.resources,\n      governance: data.governance,\n      coordinates: data.coordinates,\n      connections: data.connections,\n      wikiUrl: data.wiki_url,\n      imageUrl: data.image_url\n    });\n  }\n\n  private validateAndTransformCharacter(data: any): Types.Character {\n    // Transform legacy format to new format\n    const transformed = {\n      id: data.id,\n      name: data.name || this.formatCharacterName(data.id),\n      team: this.mapCategoryToTeam(data.category),\n      ability: data.abilitySummary || data.ability_summary || data.ability || '',\n      firstNight: data.firstNight || undefined,\n      otherNights: data.otherNights || undefined,\n      reminders: data.tokensUsed || data.tokens_used || [],\n      setup: data.tags?.includes('setup') || false,\n      special: data.special || undefined,\n      // Add actions field from the character data\n      actions: data.actions || undefined,\n      // Legacy fields\n      category: data.category,\n      edition: data.edition || data.editions,\n      abilitySummary: data.abilitySummary || data.ability_summary,\n      firstNightAction: data.firstNightAction || data.first_night_action,\n      otherNightsAction: data.otherNightsAction || data.other_nights_action,\n      dayAction: data.dayAction || data.day_action,\n      tags: data.tags || [],\n      tokensUsed: data.tokensUsed || data.tokens_used || [],\n      wikiUrl: data.wikiUrl || data.wiki_url || undefined,\n      imageUrl: data.imageUrl || data.image_url || undefined\n    };\n\n  return Script.CharacterSchema.parse(transformed);\n  }\n\n  private mapCategoryToTeam(category?: string): 'townsfolk' | 'outsider' | 'minion' | 'demon' | 'traveller' | 'fabled' {\n    if (!category) return 'townsfolk';\n    \n    switch (category.toLowerCase()) {\n      case 'townsfolk': return 'townsfolk';\n      case 'outsider': return 'outsider';\n      case 'minion': return 'minion';\n      case 'demon': return 'demon';\n      case 'traveller': return 'traveller';\n      case 'fabled': return 'fabled';\n      default: return 'townsfolk';\n    }\n  }\n\n  private parseNightOrder(action?: string | null): number | undefined {\n    if (!action || action === null) return undefined;\n    // This could be enhanced to parse actual night order from action text\n    return undefined;\n  }\n\n  private formatScriptName(scriptName: string): string {\n    return scriptName\n      .split('/')\n      .pop()!\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  private formatCharacterName(id: string): string {\n    return id\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  clearCache(): void {\n    ScriptLoader.scriptsCache.clear();\n  }\n}\n\n// Validation utilities\nexport function validateCharacter(data: any): data is Types.Character {\n  try {\n  Script.CharacterSchema.parse(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function validateScript(data: any): data is Types.LoadedScript {\n  return (\n    typeof data.id === 'string' &&\n    typeof data.name === 'string' &&\n    Array.isArray(data.characters) &&\n    data.characters.every(validateCharacter)\n  );\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/setup-types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/setup-types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token type",
        "line": 13,
        "column": 8,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport { JournalSchema } from './journal';\nimport { SeatIdSchema } from './core-types';\n\n// Setup Phase Types\nexport const ReminderTokenSchema = z.object({\n  id: z.string().uuid(),\n  roleId: z.string(),\n  text: z.string(),\n  seatId: SeatIdSchema.optional(), // Which seat this reminder is attached to\n  isActive: z.boolean().default(true)\n});\nexport type ReminderToken = z.infer<typeof ReminderTokenSchema>;\n\nexport const CharacterModificationSchema = z.object({\n  type: z.enum(['add_outsiders', 'remove_townsfolk', 'add_minions', 'remove_outsiders']),\n  count: z.number(),\n  condition: z.string().optional() // Description of when this applies\n});\nexport type CharacterModification = z.infer<typeof CharacterModificationSchema>;\n\nexport const SetupStateSchema = z.object({\n  selectedCharacters: z.array(z.string()).default([]), // Character IDs chosen by storyteller\n  characterModifications: z.array(CharacterModificationSchema).default([]), // From characters like Baron\n  reminderTokens: z.array(ReminderTokenSchema).default([]),\n  distributionOverride: z.object({\n    townsfolk: z.number(),\n    outsiders: z.number(),\n    minions: z.number(),\n    demons: z.number()\n  }).optional(), // Override calculated distribution\n  isValidated: z.boolean().default(false),\n  characterPool: z.array(z.string()).default([]) // Final pool for random distribution\n});\nexport type SetupState = z.infer<typeof SetupStateSchema>;\n\nexport const GrimoireStateSchema = z.object({\n  characterPositions: z.record(SeatIdSchema, z.string()), // seatId -> characterId\n  reminderTokens: z.array(ReminderTokenSchema).default([]),\n  nightOrder: z.array(z.string()).default([]), // Character IDs in night order\n  setupState: SetupStateSchema.optional(),\n  journals: z.record(SeatIdSchema, JournalSchema).optional(),\n});\nexport type GrimoireState = z.infer<typeof GrimoireStateSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/utils.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token :",
        "line": 7,
        "column": 31,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { GameState, SeatId, Seat } from './types';\n\n/**\n * Utility functions for game logic\n */\n\nexport function generateSeed(): string {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nexport function shuffleArray<T>(array: T[], seed?: string): T[] {\n  const shuffled = [...array];\n  // Simple seeded shuffle - in production, use a proper seeded RNG\n  let currentIndex = shuffled.length;\n  \n  while (currentIndex !== 0) {\n    const randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    [shuffled[currentIndex], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[currentIndex]];\n  }\n  \n  return shuffled;\n}\n\nexport function getSeatById(gameState: GameState, seatId: SeatId): Seat | undefined {\n  return gameState.seats.find(seat => seat.id === seatId);\n}\n\nexport function getAlivePlayers(gameState: GameState): Seat[] {\n  return gameState.seats.filter(seat => seat.isAlive);\n}\n\nexport function getPlayersByAlignment(gameState: GameState, alignment: 'good' | 'evil'): Seat[] {\n  return gameState.seats.filter(seat => seat.alignment === alignment);\n}\n\nexport function calculateParity(gameState: GameState): { goodCount: number; evilCount: number; atParity: boolean } {\n  const aliveSeats = getAlivePlayers(gameState);\n  const goodCount = aliveSeats.filter(seat => seat.alignment === 'good').length;\n  const evilCount = aliveSeats.filter(seat => seat.alignment === 'evil').length;\n  \n  return {\n    goodCount,\n    evilCount,\n    atParity: goodCount <= evilCount\n  };\n}\n\nexport function isValidTarget(gameState: GameState, actorId: SeatId, targetId: SeatId, targetExpression: string): boolean {\n  // Simple target validation - in production, implement full DSL parser\n  const actor = getSeatById(gameState, actorId);\n  const target = getSeatById(gameState, targetId);\n  \n  if (!actor || !target) return false;\n  \n  // Basic rules\n  if (targetExpression.includes('seat!=self') && actorId === targetId) {\n    return false;\n  }\n  \n  if (targetExpression.includes('alive') && !target.isAlive) {\n    return false;\n  }\n  \n  return true;\n}\n\nexport function maskGameStateForSeat(gameState: GameState, seatId: SeatId): Partial<GameState> {\n  const seat = getSeatById(gameState, seatId);\n  if (!seat) throw new Error('Seat not found');\n  \n  // Return a masked version that only includes public information and own seat details\n  const withTallies = (p: any) => {\n    const voteVals = Object.values(p.votes || {}) as boolean[];\n    const yes = voteVals.filter(Boolean).length;\n    const no = voteVals.length - yes;\n    const diffs = Object.values(p.difficultyVotes || {}) as string[];\n    const diffCounts: Record<string, number> = { beginner: 0, intermediate: 0, advanced: 0 };\n    for (const d of diffs) if (diffCounts[d] !== undefined) diffCounts[d]++;\n    return {\n      id: p.id,\n      scriptId: p.scriptId,\n      proposers: p.proposers || (p.proposedBy ? [p.proposedBy] : []),\n      votes: {},\n      difficultyVotes: {},\n      createdAt: p.createdAt,\n      tallies: { yes, no, difficulty: diffCounts }\n    };\n  };\n  return {\n    id: gameState.id,\n    phase: gameState.phase,\n    day: gameState.day,\n  gameName: (gameState as any).gameName,\n  storytellerSeatId: (gameState as any).storytellerSeatId,\n  // Publicly visible list of scripts the storyteller has made available\n  availableScriptIds: (gameState as any).availableScriptIds || [],\n    seats: gameState.seats.map(s => ({\n      ...s,\n      // Hide alignment and role for other players\n      alignment: s.id === seatId ? s.alignment : undefined,\n      role: s.id === seatId ? s.role : undefined\n    })),\n    // Don't include abilities that this seat shouldn't know about\n    abilities: gameState.abilities.filter(ability => \n      ability.actorSeat === seatId || \n      // Include publicly known abilities\n      false\n    ),\n    scriptId: gameState.scriptId,\n  // Show proposals with aggregate tallies only\n  scriptProposals: gameState.scriptProposals?.map(withTallies) || [],\n    createdAt: gameState.createdAt,\n    updatedAt: gameState.updatedAt\n  };\n}\n\nexport function maskGameStatePublic(gameState: GameState): Partial<GameState> {\n  const withTallies = (p: any) => {\n    const voteVals = Object.values(p.votes || {}) as boolean[];\n    const yes = voteVals.filter(Boolean).length;\n    const no = voteVals.length - yes;\n    const diffs = Object.values(p.difficultyVotes || {}) as string[];\n    const diffCounts: Record<string, number> = { beginner: 0, intermediate: 0, advanced: 0 };\n    for (const d of diffs) if (diffCounts[d] !== undefined) diffCounts[d]++;\n    return {\n      id: p.id,\n      scriptId: p.scriptId,\n      proposers: p.proposers || (p.proposedBy ? [p.proposedBy] : []),\n      votes: {},\n      difficultyVotes: {},\n      createdAt: p.createdAt,\n      tallies: { yes, no, difficulty: diffCounts }\n    };\n  };\n  return {\n    id: gameState.id,\n    phase: gameState.phase,\n    day: gameState.day,\n  gameName: (gameState as any).gameName,\n  storytellerSeatId: (gameState as any).storytellerSeatId,\n  // Publicly visible list of scripts the storyteller has made available\n  availableScriptIds: (gameState as any).availableScriptIds || [],\n    seats: gameState.seats.map(s => ({\n      id: s.id,\n      playerId: s.playerId,\n      isNPC: s.isNPC,\n      position: s.position,\n      statuses: s.statuses,\n      isAlive: s.isAlive,\n      votingPower: s.votingPower\n    })),\n    createdAt: gameState.createdAt,\n    updatedAt: gameState.updatedAt,\n    scriptId: gameState.scriptId,\n  // expose proposals with tallies only\n  scriptProposals: gameState.scriptProposals?.map(withTallies) || []\n  } as Partial<GameState>;\n}\n\nexport function isStorytellerSeat(gameState: GameState, seatId?: SeatId): boolean {\n  return !!seatId && gameState.storytellerSeatId === seatId;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adamburdett/Github/botct/packages/shared/src/utils/game-utils.js",
    "messages": [
      {
        "ruleId": "no-magic-numbers",
        "severity": 1,
        "message": "No magic number: -4.",
        "line": 21,
        "column": 73,
        "nodeType": "UnaryExpression",
        "messageId": "noMagic",
        "endLine": 21,
        "endColumn": 75
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\"use strict\";\n/**\n * Game Utility Functions\n * Common helper functions used across action handlers\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPlayerSeats = getPlayerSeats;\nexports.getSeatDisplayName = getSeatDisplayName;\nexports.isEvil = isEvil;\nexports.isMinion = isMinion;\nexports.isDemon = isDemon;\n\nfunction getPlayerSeats(game) {\n  return game.seats.filter((seat) => !seat.isStoryteller);\n}\n\nfunction getSeatDisplayName(seat) {\n  // For now, use the seat ID or position as display name\n  // In a real implementation, this would look up the player name\n  return (\n    seat.playerId || `Player ${seat.position}` || `Seat ${seat.id.slice(-4)}`\n  );\n}\n\nfunction isEvil(seat) {\n  if (!seat.role) return false;\n  return isMinion(seat) || isDemon(seat);\n}\n\nfunction isMinion(seat) {\n  // This would check the character's team/type\n  // Implementation depends on how we store role information\n  return seat.role?.includes(\"minion\") ?? false; // Placeholder\n}\n\nfunction isDemon(seat) {\n  // This would check the character's team/type\n  // Implementation depends on how we store role information\n  return seat.role?.includes(\"demon\") ?? false; // Placeholder\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  }
]
